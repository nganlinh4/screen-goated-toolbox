<files>
This section contains the contents of the repository's files.

<file path=".cargo/config.toml">
[build]
# Optimize compilation
rustflags = [
    "-Z", "location-detail=none",
    "-C", "target-cpu=native"
]
</file>

<file path=".gitignore">
/target
Cargo.lock
.env
.DS_Store
*.swp
*.swo
tools/

# Cursor build artifacts
build_cursor.exe
cursor_data.txt
broom.cur
screen-goated-toolbox-*.exe

# Patched dependencies (cloned by scripts/setup-egui-snarl.ps1)
libs/egui-snarl/
</file>

<file path="app.rc">
id ICON "assets/app.ico"

1 VERSIONINFO
FILEVERSION 3,5,1,0
PRODUCTVERSION 3,5,1,0
BEGIN
  BLOCK "StringFileInfo"
  BEGIN
    BLOCK "040904E4"
    BEGIN
      VALUE "CompanyName", "nganlinh4 - Open Source Developer"
      VALUE "FileDescription", "Screen Goated Toolbox - AI-powered screen capture and productivity tool. Open source on GitHub."
      VALUE "FileVersion", "3.5.1.0"
      VALUE "InternalName", "screen-goated-toolbox"
      VALUE "LegalCopyright", "Copyright (c) 2024-2025 nganlinh4. MIT License. https://github.com/nganlinh4/screen-goated-toolbox"
      VALUE "OriginalFilename", "ScreenGoatedToolbox.exe"
      VALUE "ProductName", "Screen Goated Toolbox (SGT)"
      VALUE "ProductVersion", "3.5.1.0"
    END
  END
  BLOCK "VarFileInfo"
  BEGIN
    VALUE "Translation", 0x409, 1252
  END
END
</file>

<file path="docs/WEBVIEW2_INITIALIZATION.md">
# WebView2 Initialization on Windows - Critical Notes

## The Problem

WebView2 (`wry` crate) creation can hang indefinitely on Windows when:
1. Called from deeply nested spawned threads
2. Called without proper warmup of the WebView2 infrastructure

## Root Cause

WebView2 requires the first `WebViewBuilder::build_as_child()` call to happen in a specific context:
- Thread spawned **directly from the main thread** 
- With a proper message loop running
- Window styles matching: `WS_EX_TOPMOST | WS_EX_TOOLWINDOW | WS_EX_LAYERED` (NO `WS_EX_NOACTIVATE`)
- Base style: `WS_POPUP` (NO `WS_CLIPCHILDREN`)

When the first WebView is created from a thread that was spawned several levels deep in the call stack (e.g., hotkey handler → capture thread → process thread → result window thread), the WebView2 controller initialization hangs at `CreateCoreWebView2Controller`.

## The Solution: Warmup Pattern

Follow the same pattern as `text_input.rs`:

1. **Call warmup at app startup** (in `main.rs`):
```rust
overlay::result::markdown_view::warmup();
```

2. **Warmup spawns a dedicated thread** from the main thread context:
```rust
pub fn warmup() {
    std::thread::spawn(|| {
        warmup_internal();
    });
}
```

3. **Create a hidden window with WebView** in that thread:
```rust
fn warmup_internal() {
    // Create hidden window
    let hwnd = CreateWindowExW(
        WS_EX_TOPMOST | WS_EX_TOOLWINDOW | WS_EX_LAYERED,
        class_name,
        w!("MarkdownWarmup"),
        WS_POPUP,
        0, 0, 100, 100,
        None, None, instance, None
    );
    
    // Make transparent
    SetLayeredWindowAttributes(hwnd, COLORREF(0), 0, LWA_ALPHA);
    
    // Create WebView - this "warms up" the WebView2 infrastructure
    let result = WebViewBuilder::new()
        .with_bounds(...)
        .with_html("<html><body>Warmup</body></html>")
        .with_transparent(false)
        .build_as_child(&wrapper);
    
    // Run message loop forever to keep thread alive
    while GetMessageW(&mut msg, None, 0, 0).into() {
        TranslateMessage(&msg);
        DispatchMessageW(&msg);
    }
}
```

4. **After warmup succeeds**, all subsequent WebView2 creations work - even from deeply nested threads!

## Why This Works

The first WebView2 creation initializes the shared WebView2 runtime infrastructure. Once initialized from a "good" thread context (spawned directly from main), all other threads can successfully create WebViews.

## Window Style Requirements for WebView2

| Style | Required for WebView2 |
|-------|----------------------|
| `WS_EX_NOACTIVATE` | ❌ AVOID - blocks initialization |
| `WS_CLIPCHILDREN` | ❌ AVOID - can interfere |
| `WS_EX_LAYERED` | ✅ OK |
| `WS_EX_TOOLWINDOW` | ✅ OK |
| `WS_EX_TOPMOST` | ✅ OK |
| `WS_POPUP` | ✅ Use as base style |

## Debug Tips

If WebView creation hangs:
1. Check if `[WARMUP] WebView created successfully!` appears at startup
2. If not, the warmup itself is failing
3. Add `eprintln!` at each step to find where it hangs
4. The typical hang point is Step 6 (`build_as_child()`)

## Related Files

- `src/overlay/result/markdown_view.rs` - Contains `warmup()` function
- `src/overlay/text_input.rs` - Reference implementation that works
- `src/main.rs` - Where warmup is called

---
*This issue was debugged in December 2024. The fix involved extensive investigation of thread spawning hierarchies, window styles, and COM initialization.*
</file>

<file path="installer.nsi">
; Screen Goated Toolbox Installer
!include "MUI2.nsh"
!include "x64.nsh"

; Basic Settings
Name "Screen Goated Toolbox"
OutFile "target\release\screen-goated-toolbox-installer.exe"
InstallDir "$PROGRAMFILES\ScreenGoatedToolbox"
RequestExecutionLevel admin
Icon ".\assets\app.ico"

; MUI Settings
!insertmacro MUI_PAGE_WELCOME
!insertmacro MUI_PAGE_DIRECTORY
!insertmacro MUI_PAGE_INSTFILES
!insertmacro MUI_PAGE_FINISH

!insertmacro MUI_LANGUAGE "English"

; Installer Sections
Section "Install Application"
  SetOutPath "$INSTDIR"
  
  ; Copy main executable
  File "target\release\screen-goated-toolbox.exe"
  
  ; Copy Visual C++ Runtime and install it
  File "vc_redist.x64.exe"
  DetailPrint "Installing Visual C++ Runtime..."
  ExecWait "$INSTDIR\vc_redist.x64.exe /quiet /norestart" $0
  Delete "$INSTDIR\vc_redist.x64.exe"
  
  ; Create Start Menu shortcut
  CreateDirectory "$SMPROGRAMS\Screen Goated Toolbox"
  CreateShortcut "$SMPROGRAMS\Screen Goated Toolbox\Screen Goated Toolbox.lnk" "$INSTDIR\screen-goated-toolbox.exe"
  CreateShortcut "$SMPROGRAMS\Screen Goated Toolbox\Uninstall.lnk" "$INSTDIR\uninstall.exe"
  
  ; Create Desktop shortcut (optional, uncomment if desired)
  ; CreateShortcut "$DESKTOP\Screen Goated Toolbox.lnk" "$INSTDIR\screen-goated-toolbox.exe"
  
  ; Write uninstaller
  WriteUninstaller "$INSTDIR\uninstall.exe"
  
  ; Write registry entry for Add/Remove Programs
  WriteRegStr HKLM "Software\Microsoft\Windows\CurrentVersion\Uninstall\ScreenGoatedToolbox" "DisplayName" "Screen Goated Toolbox"
  WriteRegStr HKLM "Software\Microsoft\Windows\CurrentVersion\Uninstall\ScreenGoatedToolbox" "UninstallString" "$INSTDIR\uninstall.exe"
  WriteRegStr HKLM "Software\Microsoft\Windows\CurrentVersion\Uninstall\ScreenGoatedToolbox" "InstallLocation" "$INSTDIR"
  WriteRegStr HKLM "Software\Microsoft\Windows\CurrentVersion\Uninstall\ScreenGoatedToolbox" "DisplayVersion" "1.6"
SectionEnd

; Uninstaller Section
Section "Uninstall"
  Delete "$INSTDIR\screen-goated-toolbox.exe"
  Delete "$INSTDIR\uninstall.exe"
  RMDir "$INSTDIR"
  
  Delete "$SMPROGRAMS\Screen Goated Toolbox\Screen Goated Toolbox.lnk"
  Delete "$SMPROGRAMS\Screen Goated Toolbox\Uninstall.lnk"
  RMDir "$SMPROGRAMS\Screen Goated Toolbox"
  
  Delete "$DESKTOP\Screen Goated Toolbox.lnk"
  
  DeleteRegKey HKLM "Software\Microsoft\Windows\CurrentVersion\Uninstall\ScreenGoatedToolbox"
SectionEnd
</file>

<file path="README.md">
# Screen Goated Toolbox (SGT)

A powerful Windows utility that captures any region of your screen **or records system/microphone audio** and processes it using advanced AI models. Whether you need to translate text, extract code (OCR), summarize content, get image descriptions, **or transcribe meetings**, SGT handles it with customizable presets and global hotkeys.

## Key Features

- **Multi-Modal Support:** Utilize **Groq** (Llama 4, Whisper, GPT-OSS) or **Google Gemini** (Flash, Pro) for Vision, Text, and Audio processing.
- **Audio Intelligence:** Record and transcribe/translate audio from your **Microphone** or **System Sound** (Device Audio/Loopback).
- **Preset System:** Create unlimited custom profiles (e.g., "Translate Image", "Transcribe Meeting", "Quick 4NR reply").
- **Advanced Hotkeys:** Assign custom key combinations (e.g., `Ctrl+Alt+T`, `Win+Shift+S`) to specific presets.
- **Retranslation Pipeline:** Chain models (e.g., Vision/Audio -> Text Model) for higher accuracy.
- **Smart Overlay:**
  - Streaming text support (Typewriter effect).
  - Auto-copy to clipboard.
  - "Broom" cursor for precise selection.
  - Linked windows for dual-view.
- **Usage Statistics:** Monitor your API usage limits directly in the app.
- **Localization:** UI available in English, Vietnamese, and Korean.

## Screenshot

![Screenshot](docs/images/screenshot.png)
![Demo Video](docs/images/demo-video.gif)

## Prerequisites

- **OS:** Windows 10 or Windows 11.
- **API Keys:**
  - **Groq:** [Get a free key here](https://console.groq.com/keys) (Required for Llama, Whisper, & GPT-OSS models).
  - **Google Gemini:** [Get a free key here](https://aistudio.google.com/app/apikey) (Required for Gemini Vision & Audio models).

### Build Prerequisites (if building from source)
- **Rust Nightly:** [Install from rustup](https://rustup.rs/), then run `rustup default nightly`.
- **Visual Studio Build Tools 2022:** [Download here](https://visualstudio.microsoft.com/downloads/) and install with "Desktop development with C++" workload.
- **MinGW-w64 with windres:** [Download from here](https://github.com/niXman/mingw-builds-binaries/releases), extract to `C:\mingw-w64`, and add `C:\mingw-w64\mingw64\bin` to your system PATH.

## Installation

### Option 1: Download Release
Download the latest `.exe` from the [Releases](https://github.com/nganlinh4/screen-goated-toolbox/releases) page.

### Option 2: Build from Source
Ensure [Rust](https://www.rust-lang.org/tools/install) is installed.

```bash
git clone https://github.com/nganlinh4/screen-goated-toolbox
cd screen-goated-toolbox

# Setup patched egui-snarl (required before building)
powershell -ExecutionPolicy Bypass -File scripts/setup-egui-snarl.ps1

# The build script will handle icon resource embedding automatically
cargo build --release
```

Run the executable found in `target/release/`.

## Getting Started

1. **Launch the App:** Open `screen-goated-toolbox.exe`.
2. **Global Settings:**
   - Paste your **Groq API Key** and/or **Gemini API Key**.
   - Toggle **Run at Windows Startup** if desired.
3. **Configure a Preset:**
   - Select a preset on the left or create a new one.
   - **Type:** Choose `Image Understanding` or `Audio Understanding`.
   - **Prompt:** Define the AI instruction (e.g., "Translate to {language1}").
   - **Model:** Select your preferred model (e.g., `Llama 4 Scout`, `Gemini Flash`, `Whisper`).
   - **Hotkeys:** Click "Add Key" to assign a shortcut.
4. **Capture:**
   - **Image:** Press hotkey -> Drag to select area -> Result appears in overlay.
   - **Audio:** Press hotkey -> Recording overlay appears -> Press hotkey again to finish.

## Configuration Guide

### Preset Types
* **Image Understanding:** Captures a screen region (OCR, Translation, Description).
* **Audio Understanding:** Records audio from **Mic** or **Device** (System Audio). Useful for meetings, videos, or quick voice commands.
* **Video Understanding:** (Upcoming feature).

### Retranslation (Pipeline)
For higher quality results, SGT can chain models:
1. **Extraction:** Vision/Audio model extracts raw text/transcript.
2. **Retranslation:** A specialized Text model (e.g., `GPT-OSS`, `Kimi`, `Gemini`) translates/refines the output.

### Available Models

**Vision Models (Image):**
* `Scout` (Llama 4 Scout 17B) - Extremely fast, good for general text.
* `Maverick` (Llama 4 Maverick 17B) - Highly accurate instruction following.
* `Gemini Flash Lite` (Google) - Efficient and fast.
* `Gemini Flash` (Google) - Balanced performance.
* `Gemini 2.5 Pro` (Google) - Highest accuracy, best for reasoning.

**Audio Models (Speech):**
* `Whisper Fast` (Large v3 Turbo) - Fast transcription via Groq.
* `Whisper Accurate` (Large v3) - High accuracy transcription via Groq.
* `Gemini Audio` (Flash Lite / Flash / 2.5 Pro) - Native multimodal audio understanding (can summarize/translate directly).

**Text Models (Retranslation):**
* `Fast Text` (GPT-OSS 20B) - Super fast.
* `Fast 120B` (GPT-OSS 120B) - Balanced speed/quality.
* `Accurate` (Kimi k2-instruct) - High quality Chinese/English handling.
* `Quick Search` (Groq Compound Mini) - **NEW!** Search the web quickly for answers.
* `Deep Search` (Groq Compound) - **NEW!** Comprehensive web search with detailed sources.
* `Gemini Text` (Flash Lite / Flash / 2.5 Pro) - Google's text capabilities.

## Troubleshooting

**Hotkey conflict / Not working:**
* If using the app in games or elevated applications, **run SGT as Administrator**.
* Check for conflicts with other apps.

**"NO_API_KEY" Error:**
* Ensure keys are entered in "Global Settings".
* Verify the selected preset uses a model matching the provider key you entered (Groq vs Google).

**Audio Recording Issues:**
* Ensure your default microphone or output device is active in Windows Sound Settings.
* If recording "Device Audio", play some sound to ensure the loopback stream has data.

## License

MIT — See [LICENSE](LICENSE) file.

## Credits

Developed by **nganlinh4**.
* Powered by [Groq](https://groq.com) and [Google DeepMind](https://deepmind.google/technologies/gemini/).
* Built with [Rust](https://www.rust-lang.org/) and [egui](https://github.com/emilk/egui).
</file>

<file path="scripts/setup-egui-snarl.ps1">
# Setup script for patched egui-snarl
# This clones egui-snarl and patches it for scroll-to-zoom support

$snarlDir = Join-Path $PSScriptRoot "..\libs\egui-snarl"
$patchFile = Join-Path $PSScriptRoot "egui-snarl-scroll-zoom.patch"

# Check if already set up
if (Test-Path $snarlDir) {
    Write-Host "egui-snarl already exists at $snarlDir"
    Write-Host "To re-patch, delete the folder and run this script again."
    exit 0
}

# Clone egui-snarl (latest version)
Write-Host "Cloning egui-snarl..."
git clone --depth 1 https://github.com/zakarumych/egui-snarl.git $snarlDir

if (-not (Test-Path $snarlDir)) {
    Write-Error "Failed to clone egui-snarl"
    exit 1
}

# Apply the patch
Write-Host "Applying scroll-to-zoom patch..."

# Read the ui.rs file
$uiRsPath = Join-Path $snarlDir "src\ui.rs"
$content = Get-Content $uiRsPath -Raw

# The original code we're replacing (Scene::register_pan_and_zoom)
$originalCode = @"
    clamp_scale(&mut to_global, min_scale, max_scale, ui_rect);

    let mut snarl_resp = ui.response();
    Scene::new()
        .zoom_range(min_scale..=max_scale)
        .register_pan_and_zoom(&ui, &mut snarl_resp, &mut to_global);

    if snarl_resp.changed() {
        ui.ctx().request_repaint();
    }
"@

# The patched code (scroll-to-zoom without Ctrl + double-click reset + external reset trigger)
$patchedCode = @"
    clamp_scale(&mut to_global, min_scale, max_scale, ui_rect);

    let mut snarl_resp = ui.response();
    
    // CUSTOM SCROLL-TO-ZOOM: Instead of using Scene::register_pan_and_zoom which uses Ctrl+scroll for zoom,
    // we manually handle scroll as zoom directly (no Ctrl required)
    
    // Disable native double-click centering to prevent it from overriding our custom reset logic
    style.centering = Some(false);

    {
        let scroll_delta = ui.ctx().input(|i| i.raw_scroll_delta);
        let zoom_delta = ui.ctx().input(|i| i.zoom_delta());
        let pointer_in_canvas = ui.ctx().input(|i| {
            i.pointer.hover_pos().map(|pos| ui_rect.contains(pos)).unwrap_or(false)
        });
        
        // Check for external reset request (set by application code via egui context data)
        let reset_id = egui::Id::new("snarl_reset_view");
        let should_reset = ui.ctx().data_mut(|d| {
            let reset = d.get_temp::<bool>(reset_id).unwrap_or(false);
            if reset {
                d.insert_temp(reset_id, false); // Clear the flag
            }
            reset
        });
        
        // Reset view on double-click OR external reset request
        let double_clicked = snarl_resp.double_clicked();
        if (double_clicked && pointer_in_canvas) || should_reset {
            to_global.scaling = 1.0;
            
            // "Fit View" - Center the nodes in the viewport
            let mut min_pos = egui::pos2(f32::INFINITY, f32::INFINITY);
            let mut max_pos = egui::pos2(f32::NEG_INFINITY, f32::NEG_INFINITY);
            let mut has_nodes = false;
            
            for (pos, _) in snarl.nodes_pos() {
                has_nodes = true;
                if pos.x < min_pos.x { min_pos.x = pos.x; }
                if pos.y < min_pos.y { min_pos.y = pos.y; }
                
                // Assume generic node size approx 200x150 for centering
                let right = pos.x + 200.0;
                let bottom = pos.y + 150.0;
                
                if right > max_pos.x { max_pos.x = right; }
                if bottom > max_pos.y { max_pos.y = bottom; }
            }
            
            if has_nodes {
                 let graph_center = min_pos.lerp(max_pos, 0.5);
                 // Center the graph content
                 to_global.translation = ui_rect.center().to_vec2() - graph_center.to_vec2();
            } else {
                 // Fallback if no nodes (center origin logic)
                 to_global.translation = ui_rect.center().to_vec2();
            }
            
            snarl_resp.mark_changed();
        }
        
        // Check if any popup is open (ComboBox dropdowns, context menus, etc.)
        // If a popup is open, we should NOT capture scroll, let the popup handle it
        let any_popup_open = egui::Popup::is_any_open(ui.ctx());
        
        // Check if pointer is over a higher layer (Modal windows, Panels, etc.)
        // Only capture scroll if the pointer is on the Background layer (the canvas itself)
        let pointer_on_foreground = if let Some(pos) = ui.ctx().input(|i| i.pointer.hover_pos()) {
            if let Some(layer_id) = ui.ctx().layer_id_at(pos) {
                // Background order is 0, anything higher means a window/panel/modal is above
                layer_id.order != egui::Order::Background && layer_id.order != egui::Order::Middle
            } else {
                false
            }
        } else {
            false
        };
        
        // Handle scroll wheel as zoom (not pan) - works anywhere in the canvas, including over nodes
        // BUT skip if a popup is open OR pointer is over a modal/window so they can scroll properly
        if scroll_delta.y.abs() > 0.1 && pointer_in_canvas && !any_popup_open && !pointer_on_foreground {
            let zoom_factor = if scroll_delta.y > 0.0 { 1.1 } else { 0.9 };
            let pointer_pos = ui.ctx().input(|i| i.pointer.hover_pos()).unwrap_or(ui_rect.center());
            
            // Apply zoom centered on pointer position
            let new_scale = (to_global.scaling * zoom_factor).clamp(min_scale, max_scale);
            if new_scale != to_global.scaling {
                // Zoom towards the pointer: adjust translation so pointer stays at same graph position
                let scale_ratio = new_scale / to_global.scaling;
                to_global.translation = pointer_pos.to_vec2() + (to_global.translation - pointer_pos.to_vec2()) * scale_ratio;
                to_global.scaling = new_scale;
                snarl_resp.mark_changed();
            }
        }
        
        // Also handle pinch zoom gestures (zoom_delta from touch)
        if zoom_delta != 1.0 && pointer_in_canvas {
            let pointer_pos = ui.ctx().input(|i| i.pointer.hover_pos()).unwrap_or(ui_rect.center());
            let new_scale = (to_global.scaling * zoom_delta).clamp(min_scale, max_scale);
            if new_scale != to_global.scaling {
                let scale_ratio = new_scale / to_global.scaling;
                to_global.translation = pointer_pos.to_vec2() + (to_global.translation - pointer_pos.to_vec2()) * scale_ratio;
                to_global.scaling = new_scale;
                snarl_resp.mark_changed();
            }
        }
        
        // Handle drag for panning (left mouse button, middle mouse button, or right mouse button)
        if snarl_resp.dragged_by(PointerButton::Primary) || snarl_resp.dragged_by(PointerButton::Middle) || snarl_resp.dragged_by(PointerButton::Secondary) {
            to_global.translation += snarl_resp.drag_delta();
            snarl_resp.mark_changed();
        }
    }

    if snarl_resp.changed() {
        ui.ctx().request_repaint();
    }
"@

# Replace the code
$newContent = $content -replace [regex]::Escape($originalCode), $patchedCode

if ($newContent -eq $content) {
    Write-Warning "Could not find the exact code to patch. egui-snarl may have updated."
    Write-Warning "Please check libs/egui-snarl/src/ui.rs manually around line 989."
    exit 1
}

# Also remove unused Scene import to avoid warning
$newContent = $newContent -replace "Pos2, Rect, Scene, Sense,", "Pos2, Rect, Sense,"

# Write the patched file
Set-Content -Path $uiRsPath -Value $newContent -NoNewline

Write-Host "Patch applied successfully!"
Write-Host "egui-snarl is ready at: $snarlDir"
</file>

<file path="src/api/client.rs">
use lazy_static::lazy_static;
lazy_static! {
</file>

<file path="src/api/mod.rs">
pub mod types;
pub mod client;
pub mod vision;
pub mod audio;
pub mod text;
pub mod realtime_audio;
pub mod ollama;
pub mod tts;
pub use vision::translate_image_streaming;
⋮----
pub use audio::record_audio_and_transcribe;
</file>

<file path="src/api/ollama.rs">
use anyhow::Result;
⋮----
use serde::Deserialize;
use super::client::UREQ_AGENT;
use crate::gui::locale::LocaleText;
⋮----
pub struct OllamaStreamChunk {
⋮----
pub struct OllamaGenerateResponse {
⋮----
pub struct OllamaModel {
⋮----
pub struct OllamaTagsResponse {
⋮----
pub struct OllamaModelWithCaps {
⋮----
struct OllamaShowResponse {
⋮----
struct OllamaModelDetails {
⋮----
pub fn fetch_ollama_models(base_url: &str) -> Result<Vec<OllamaModel>> {
let url = format!("{}/api/tags", base_url.trim_end_matches('/'));
let resp = UREQ_AGENT.get(&url)
.timeout(std::time::Duration::from_secs(5))
.call()
.map_err(|e| anyhow::anyhow!("Failed to connect to Ollama: {}", e))?;
let tags: OllamaTagsResponse = resp.into_json()
.map_err(|e| anyhow::anyhow!("Failed to parse Ollama response: {}", e))?;
Ok(tags.models)
⋮----
fn check_model_has_vision(base_url: &str, model_name: &str) -> bool {
let url = format!("{}/api/show", base_url.trim_end_matches('/'));
⋮----
let resp = match UREQ_AGENT.post(&url)
.timeout(std::time::Duration::from_secs(3))
.send_json(&payload) {
⋮----
let families_str = show_resp.details.families.join(" ").to_lowercase();
if families_str.contains("clip") || families_str.contains("vision") {
⋮----
let modelfile_lower = show_resp.modelfile.to_lowercase();
if modelfile_lower.contains("projector") || modelfile_lower.contains("vision") {
⋮----
let name_lower = model_name.to_lowercase();
if name_lower.contains("vision") || name_lower.contains("-vl") ||
name_lower.contains("llava") || name_lower.contains("bakllava") ||
name_lower.contains("moondream") || name_lower.contains("minicpm-v") {
⋮----
pub fn fetch_ollama_models_with_caps(base_url: &str) -> Result<Vec<OllamaModelWithCaps>> {
let models = fetch_ollama_models(base_url)?;
⋮----
let has_vision = check_model_has_vision(base_url, &model.name);
result.push(OllamaModelWithCaps {
⋮----
Ok(result)
⋮----
pub fn ollama_generate_text<F>(
⋮----
let url = format!("{}/api/generate", base_url.trim_end_matches('/'));
⋮----
let resp = UREQ_AGENT.post(&url)
.timeout(std::time::Duration::from_secs(300))
.send_json(&payload)
.map_err(|e| anyhow::anyhow!("Ollama API Error: {}", e))?;
⋮----
let reader = BufReader::new(resp.into_reader());
⋮----
for line in reader.lines() {
⋮----
if line.is_empty() { continue; }
⋮----
if !thinking.is_empty() && !thinking_shown && !content_started {
on_chunk(locale.model_thinking);
⋮----
if !chunk.response.is_empty() {
⋮----
full_content.push_str(&chunk.response);
let wipe_content = format!("{}{}", crate::api::WIPE_SIGNAL, full_content);
on_chunk(&wipe_content);
⋮----
on_chunk(&chunk.response);
⋮----
let ollama_resp: OllamaGenerateResponse = resp.into_json()
⋮----
on_chunk(&full_content);
⋮----
Ok(full_content)
⋮----
pub fn ollama_generate_vision<F>(
⋮----
image.write_to(&mut Cursor::new(&mut image_data), image::ImageFormat::Png)?;
let b64_image = general_purpose::STANDARD.encode(&image_data);
⋮----
.map_err(|e| anyhow::anyhow!("Ollama Vision API Error: {}", e))?;
</file>

<file path="src/api/realtime_audio/utils.rs">
use std::sync::Mutex;
⋮----
pub fn update_overlay_text(hwnd: HWND, text: &str) {
if let Ok(mut display) = REALTIME_DISPLAY_TEXT.lock() {
*display = text.to_string();
⋮----
let _ = PostMessageW(Some(hwnd), WM_REALTIME_UPDATE, WPARAM(0), LPARAM(0));
⋮----
pub fn update_translation_text(hwnd: HWND, text: &str) {
if let Ok(mut display) = TRANSLATION_DISPLAY_TEXT.lock() {
⋮----
let _ = PostMessageW(Some(hwnd), WM_TRANSLATION_UPDATE, WPARAM(0), LPARAM(0));
⋮----
pub fn refresh_transcription_window() {
⋮----
if !realtime_hwnd.is_invalid() {
let _ = PostMessageW(Some(realtime_hwnd), WM_REALTIME_UPDATE, WPARAM(0), LPARAM(0));
</file>

<file path="src/api/realtime_audio/websocket.rs">
use anyhow::Result;
⋮----
use std::net::TcpStream;
use std::time::Duration;
use super::REALTIME_MODEL;
pub fn connect_websocket(api_key: &str) -> Result<tungstenite::WebSocket<native_tls::TlsStream<TcpStream>>> {
let ws_url = format!(
⋮----
let host = url.host_str().ok_or_else(|| anyhow::anyhow!("No host in URL"))?;
⋮----
use std::net::ToSocketAddrs;
let addr = format!("{}:{}", host, port)
.to_socket_addrs()?
.next()
.ok_or_else(|| anyhow::anyhow!("Failed to resolve hostname: {}", host))?;
⋮----
tcp_stream.set_read_timeout(Some(Duration::from_secs(30)))?;
tcp_stream.set_write_timeout(Some(Duration::from_secs(30)))?;
tcp_stream.set_nodelay(true)?;
⋮----
let tls_stream = connector.connect(host, tcp_stream)?;
⋮----
Ok(socket)
⋮----
pub fn set_socket_nonblocking(socket: &mut tungstenite::WebSocket<native_tls::TlsStream<TcpStream>>) -> Result<()> {
let stream = socket.get_mut();
let tcp_stream = stream.get_mut();
tcp_stream.set_read_timeout(Some(Duration::from_millis(50)))?;
Ok(())
⋮----
pub fn send_setup_message(socket: &mut tungstenite::WebSocket<native_tls::TlsStream<TcpStream>>) -> Result<()> {
⋮----
let msg_str = setup.to_string();
socket.write(tungstenite::Message::Text(msg_str))?;
socket.flush()?;
⋮----
pub fn send_audio_chunk(socket: &mut tungstenite::WebSocket<native_tls::TlsStream<TcpStream>>, pcm_data: &[i16]) -> Result<()> {
let mut bytes = Vec::with_capacity(pcm_data.len() * 2);
⋮----
bytes.extend_from_slice(&sample.to_le_bytes());
⋮----
let b64_audio = general_purpose::STANDARD.encode(&bytes);
⋮----
socket.write(tungstenite::Message::Text(msg.to_string()))?;
⋮----
pub fn parse_input_transcription(msg: &str) -> Option<String> {
⋮----
if let Some(server_content) = json.get("serverContent") {
if let Some(input_transcription) = server_content.get("inputTranscription") {
if let Some(text) = input_transcription.get("text").and_then(|t| t.as_str()) {
return Some(text.to_string());
</file>

<file path="src/api/tts/instance.rs">
use std::sync::Arc;
use lazy_static::lazy_static;
use super::manager::TtsManager;
lazy_static! {
</file>

<file path="src/api/tts/websocket.rs">
use anyhow::Result;
⋮----
use std::net::TcpStream;
use std::time::Duration;
use native_tls::TlsStream;
use tungstenite::WebSocket;
use super::types::TTS_MODEL;
pub fn connect_tts_websocket(api_key: &str) -> Result<WebSocket<TlsStream<TcpStream>>> {
let ws_url = format!(
⋮----
let host = url.host_str().ok_or_else(|| anyhow::anyhow!("No host in URL"))?;
⋮----
use std::net::ToSocketAddrs;
let addr = format!("{}:{}", host, port)
.to_socket_addrs()?
.next()
.ok_or_else(|| anyhow::anyhow!("Failed to resolve hostname: {}", host))?;
⋮----
tcp_stream.set_read_timeout(Some(Duration::from_secs(30)))?;
tcp_stream.set_write_timeout(Some(Duration::from_secs(30)))?;
tcp_stream.set_nodelay(true)?;
⋮----
let tls_stream = connector.connect(host, tcp_stream)?;
⋮----
Ok(socket)
⋮----
pub fn send_tts_setup(socket: &mut WebSocket<TlsStream<TcpStream>>, voice_name: &str, speed: &str, custom_instructions: Option<&str>) -> Result<()> {
let mut system_text = "You are a text-to-speech reader. Your ONLY job is to read the user's text out loud, exactly as written, word for word. Do NOT respond conversationally. Do NOT add commentary. Do NOT ask questions. ".to_string();
⋮----
"Slow" => system_text.push_str("Speak slowly, clearly, and with deliberate pacing. "),
"Fast" => system_text.push_str("Speak quickly, efficiently, and with a brisk pace. "),
_ => system_text.push_str("Simply read the provided text aloud naturally and clearly. "),
⋮----
if !instructions.trim().is_empty() {
system_text.push_str(" Additional instructions: ");
system_text.push_str(instructions.trim());
system_text.push(' ');
⋮----
system_text.push_str("Start reading immediately.");
⋮----
let msg_str = setup.to_string();
socket.write(tungstenite::Message::Text(msg_str))?;
socket.flush()?;
Ok(())
⋮----
pub fn send_tts_text(socket: &mut WebSocket<TlsStream<TcpStream>>, text: &str) -> Result<()> {
let prompt = format!("[READ ALOUD VERBATIM - START NOW]\n\n{}", text);
⋮----
socket.write(tungstenite::Message::Text(msg.to_string()))?;
⋮----
pub fn parse_audio_data(msg: &str) -> Option<Vec<u8>> {
⋮----
if let Some(server_content) = json.get("serverContent") {
if let Some(model_turn) = server_content.get("modelTurn") {
if let Some(parts) = model_turn.get("parts").and_then(|p| p.as_array()) {
⋮----
if let Some(inline_data) = part.get("inlineData") {
if let Some(data_b64) = inline_data.get("data").and_then(|d| d.as_str()) {
if let Ok(audio_bytes) = general_purpose::STANDARD.decode(data_b64) {
return Some(audio_bytes);
⋮----
pub fn is_turn_complete(msg: &str) -> bool {
⋮----
if let Some(turn_complete) = server_content.get("turnComplete") {
if turn_complete.as_bool().unwrap_or(false) {
⋮----
if let Some(gen_complete) = server_content.get("generationComplete") {
if gen_complete.as_bool().unwrap_or(false) {
</file>

<file path="src/api/tts/wsola.rs">
use std::f32;
pub struct WsolaStretcher {
⋮----
impl WsolaStretcher {
pub fn new(sample_rate: u32) -> Self {
⋮----
.map(|i| {
⋮----
0.5 * (1.0 - (2.0 * std::f32::consts::PI * t).cos())
⋮----
.collect();
⋮----
fn find_best_offset(&self, input_pos: usize, target_hop: usize) -> usize {
let start = target_hop.saturating_sub(self.search_range);
let end = (target_hop + self.search_range).min(self.input_buffer.len().saturating_sub(self.frame_size + input_pos).saturating_sub(1));
⋮----
if ref_pos + compare_len > self.input_buffer.len() {
⋮----
if candidate_pos + compare_len > self.input_buffer.len() {
⋮----
pub fn stretch(&mut self, input: &[i16], speed_ratio: f64) -> Vec<i16> {
if (speed_ratio - 1.0).abs() < 0.05 || input.is_empty() {
if !self.output_overlap.is_empty() {
let result: Vec<i16> = self.output_overlap.drain(..)
.map(|s| s.clamp(-32768.0, 32767.0) as i16)
⋮----
combined.extend(input.iter().cloned());
⋮----
return input.to_vec();
⋮----
if (speed_ratio - self.last_speed).abs() > 0.15 {
self.input_buffer.clear();
self.output_overlap.clear();
⋮----
self.input_buffer.extend(input.iter().map(|&s| s as f32));
if self.input_buffer.len() < self.frame_size + self.search_range {
⋮----
let target_analysis_hop = (self.hop_size as f64 * speed_ratio).round() as usize;
⋮----
let estimated_frames = self.input_buffer.len() / target_analysis_hop.max(1);
let mut output = vec![0.0f32; estimated_frames * synthesis_hop + self.frame_size];
for (i, &v) in self.output_overlap.iter().enumerate() {
if i < output.len() {
⋮----
if input_pos + self.frame_size + self.search_range + target_analysis_hop > self.input_buffer.len() {
⋮----
if output_pos + self.frame_size > output.len() {
output.resize(output_pos + self.frame_size * 2, 0.0);
⋮----
let actual_analysis_hop = self.find_best_offset(input_pos, target_analysis_hop);
⋮----
let complete_len = output_pos.min(output.len());
⋮----
if complete_len < output.len() {
self.output_overlap.extend_from_slice(&output[complete_len..]);
⋮----
let consumed = input_pos.min(self.input_buffer.len());
⋮----
self.input_buffer.drain(0..consumed);
⋮----
output[..complete_len].iter()
.map(|&s| s.clamp(-32768.0, 32767.0) as i16)
.collect()
</file>

<file path="src/api/types.rs">
pub struct StreamChunk {
⋮----
pub struct Choice {
⋮----
pub struct Delta {
⋮----
pub struct ChatCompletionResponse {
⋮----
pub struct ChatChoice {
⋮----
pub struct ChatMessage {
⋮----
pub struct ExecutedTool {
⋮----
pub struct SearchResults {
⋮----
pub struct SearchResult {
</file>

<file path="src/gui/key_mapping.rs">
use eframe::egui;
pub fn egui_key_to_vk(key: &egui::Key) -> Option<u32> {
⋮----
egui::Key::Num0 => Some(0x30), egui::Key::Num1 => Some(0x31), egui::Key::Num2 => Some(0x32),
egui::Key::Num3 => Some(0x33), egui::Key::Num4 => Some(0x34), egui::Key::Num5 => Some(0x35),
egui::Key::Num6 => Some(0x36), egui::Key::Num7 => Some(0x37), egui::Key::Num8 => Some(0x38),
egui::Key::Num9 => Some(0x39),
egui::Key::A => Some(0x41), egui::Key::B => Some(0x42), egui::Key::C => Some(0x43),
egui::Key::D => Some(0x44), egui::Key::E => Some(0x45), egui::Key::F => Some(0x46),
egui::Key::G => Some(0x47), egui::Key::H => Some(0x48), egui::Key::I => Some(0x49),
egui::Key::J => Some(0x4A), egui::Key::K => Some(0x4B), egui::Key::L => Some(0x4C),
egui::Key::M => Some(0x4D), egui::Key::N => Some(0x4E), egui::Key::O => Some(0x4F),
egui::Key::P => Some(0x50), egui::Key::Q => Some(0x51), egui::Key::R => Some(0x52),
egui::Key::S => Some(0x53), egui::Key::T => Some(0x54), egui::Key::U => Some(0x55),
egui::Key::V => Some(0x56), egui::Key::W => Some(0x57), egui::Key::X => Some(0x58),
egui::Key::Y => Some(0x59), egui::Key::Z => Some(0x5A),
egui::Key::F1 => Some(0x70), egui::Key::F2 => Some(0x71), egui::Key::F3 => Some(0x72),
egui::Key::F4 => Some(0x73), egui::Key::F5 => Some(0x74), egui::Key::F6 => Some(0x75),
egui::Key::F7 => Some(0x76), egui::Key::F8 => Some(0x77), egui::Key::F9 => Some(0x78),
egui::Key::F10 => Some(0x79), egui::Key::F11 => Some(0x7A), egui::Key::F12 => Some(0x7B),
egui::Key::F13 => Some(0x7C), egui::Key::F14 => Some(0x7D), egui::Key::F15 => Some(0x7E),
egui::Key::F16 => Some(0x7F), egui::Key::F17 => Some(0x80), egui::Key::F18 => Some(0x81),
egui::Key::F19 => Some(0x82), egui::Key::F20 => Some(0x83),
egui::Key::Escape => Some(0x1B),
egui::Key::Insert => Some(0x2D),
egui::Key::Delete => Some(0x2E),
egui::Key::Home => Some(0x24),
egui::Key::End => Some(0x23),
egui::Key::PageUp => Some(0x21),
egui::Key::PageDown => Some(0x22),
egui::Key::ArrowLeft => Some(0x25),
egui::Key::ArrowUp => Some(0x26),
egui::Key::ArrowRight => Some(0x27),
egui::Key::ArrowDown => Some(0x28),
egui::Key::Backspace => Some(0x08),
egui::Key::Enter => Some(0x0D),
egui::Key::Space => Some(0x20),
egui::Key::Tab => Some(0x09),
egui::Key::Backtick => Some(0xC0),
egui::Key::Minus => Some(0xBD),
egui::Key::Plus => Some(0xBB),
egui::Key::OpenBracket => Some(0xDB),
egui::Key::CloseBracket => Some(0xDD),
egui::Key::Backslash => Some(0xDC),
egui::Key::Semicolon => Some(0xBA),
egui::Key::Comma => Some(0xBC),
egui::Key::Period => Some(0xBE),
egui::Key::Slash => Some(0xBF),
⋮----
pub fn egui_pointer_to_vk(btn: &egui::PointerButton) -> Option<u32> {
⋮----
egui::PointerButton::Middle => Some(0x04),
egui::PointerButton::Extra1 => Some(0x05),
egui::PointerButton::Extra2 => Some(0x06),
</file>

<file path="src/gui/settings_ui/mod.rs">
mod sidebar;
mod global;
mod history;
mod preset;
mod footer;
pub mod node_graph;
pub use sidebar::render_sidebar;
pub use sidebar::get_localized_preset_name;
pub use global::render_global_settings;
pub use history::render_history_panel;
pub use preset::render_preset_editor;
pub use footer::render_footer;
⋮----
pub enum ViewMode {
</file>

<file path="src/icon_gen.rs">
use eframe::egui;
pub fn get_tray_icon(is_system_dark: bool) -> tray_icon::Icon {
⋮----
include_bytes!("../assets/tray_icon.png")
⋮----
include_bytes!("../assets/tray_icon-light.png")
⋮----
let img = image::load_from_memory(icon_bytes).expect("Failed to load tray icon");
let img_rgba = img.to_rgba8();
let (width, height) = img_rgba.dimensions();
let rgba = img_rgba.into_raw();
tray_icon::Icon::from_rgba(rgba, width, height).unwrap()
⋮----
pub fn get_window_icon(is_system_dark: bool) -> egui::IconData {
⋮----
include_bytes!("../assets/app-icon-small.png")
⋮----
include_bytes!("../assets/app-icon-small-light.png")
⋮----
let img = image::load_from_memory(icon_bytes).expect("Failed to load app icon");
⋮----
rgba: img_rgba.into_vec(),
</file>

<file path="src/overlay/broom_assets.rs">
pub struct BroomRenderParams {
⋮----
pub fn render_procedural_broom(params: BroomRenderParams) -> Vec<u32> {
let mut pixels = vec![0u32; (BROOM_W * BROOM_H) as usize];
⋮----
let handle_rad = (params.tilt_angle * 0.25).to_radians();
let h_sin = handle_rad.sin();
let h_cos = handle_rad.cos();
let bristle_target_rad = (params.tilt_angle * 0.5).to_radians();
⋮----
let b_sin = current_angle.sin();
let b_cos = current_angle.cos();
⋮----
let start_x = (cx - half_w).round() as i32;
let end_x = (cx + half_w).round() as i32;
let py = cy.round() as i32;
⋮----
draw_pixel(px, py, c_shadow, true);
⋮----
let rel_x = (px as f32 - cx).round() as i32;
⋮----
draw_pixel(px, py, col, false);
⋮----
for px in (cx - half_w).round() as i32 ..= (cx + half_w).round() as i32 {
draw_pixel(px, cy.round() as i32, c_band, false);
⋮----
let px = cx.round() as i32;
⋮----
draw_pixel(px, py, c_handle_dk, false);
draw_pixel(px + 1, py, c_handle_lt, false);
</file>

<file path="src/overlay/html_components/css_modals.rs">
pub fn get() -> String { r###"
⋮----
"###.to_string() }
</file>

<file path="src/overlay/html_components/js_logic.rs">
pub fn get(placeholder_text: &str) -> String { format!(r###"        function updateText(oldText, newText) {{
</file>

<file path="src/overlay/paint_utils.rs">
pub fn hsv_to_rgb(h: f32, s: f32, v: f32) -> u32 {
⋮----
let x = c * (1.0 - (h_prime % 2.0 - 1.0).abs());
⋮----
pub fn sd_rounded_box(px: f32, py: f32, bx: f32, by: f32, r: f32) -> f32 {
let qx = px.abs() - bx + r;
let qy = py.abs() - by + r;
let len_max_q = (qx.max(0.0).powi(2) + qy.max(0.0).powi(2)).sqrt();
let min_max_q = qx.max(qy).min(0.0);
⋮----
pub unsafe fn draw_direct_sdf_glow(
⋮----
if pixels_ptr.is_null() { return; }
⋮----
let eff_radius = CORNER_RADIUS.min(bx).min(by);
let min_dim = (w as f32).min(h as f32);
let dynamic_base_scale = (min_dim * 0.2).clamp(20.0, 60.0);
⋮----
let time_rad = time_offset.to_radians();
⋮----
let qx = px.abs() - bx + eff_radius;
let qy = py.abs() - by + eff_radius;
⋮----
((qx * qx + qy * qy).sqrt()) - eff_radius
⋮----
qx.max(qy) - eff_radius
⋮----
let t = (d / 2.0).clamp(0.0, 1.0);
⋮----
let dist_in = d.abs();
let t_rough = (dist_in / (dynamic_base_scale * 1.4)).clamp(0.0, 1.0);
let base_intensity_rough = (1.0 - t_rough).powi(3);
⋮----
let angle = py.atan2(px);
let noise = (angle * 4.0 + time_rad * 2.0).sin() * 0.5;
⋮----
let t = (dist_in / local_glow_width).clamp(0.0, 1.0);
let intensity = (1.0 - t).powi(3);
⋮----
let deg = angle.to_degrees() + 180.0;
⋮----
let rgb = if dist_in < 2.5 { 0x00FFFFFF } else { hsv_to_rgb(hue, 0.8, 1.0) };
⋮----
pub unsafe fn draw_minimal_glow(
⋮----
for pixel in pixels.iter_mut() {
⋮----
let scan_y = margin + ((t * scan_range as f32) as i32).clamp(0, scan_range - 1);
</file>

<file path="src/overlay/process/types.rs">
use std::sync::Mutex;
use crate::overlay::result::layout::calculate_next_window_rect;
⋮----
pub struct ProcessingState {
⋮----
unsafe impl Send for ProcessingState {}
unsafe impl Sync for ProcessingState {}
impl ProcessingState {
pub fn new(graphics_mode: String) -> Self {
⋮----
pub fn cleanup(&mut self) {
if !self.cache_hbm.is_invalid() {
unsafe { let _ = DeleteObject(self.cache_hbm.into()); }
⋮----
pub fn reset_window_position_queue() {
let mut last = LAST_WINDOW_RECT.lock().unwrap();
⋮----
pub fn get_next_window_position(initial_rect: RECT) -> RECT {
⋮----
let s_w = unsafe { GetSystemMetrics(SM_CXSCREEN) };
let s_h = unsafe { GetSystemMetrics(SM_CYSCREEN) };
⋮----
calculate_next_window_rect(prev, s_w, s_h)
⋮----
*last = Some(next_rect);
</file>

<file path="src/overlay/process/window.rs">
use windows::Win32::System::LibraryLoader::GetModuleHandleW;
⋮----
use std::collections::HashMap;
⋮----
pub unsafe fn create_processing_window(rect: RECT, graphics_mode: String) -> HWND {
let instance = GetModuleHandleW(None).unwrap();
let class_name = w!("SGTProcessingOverlay");
REGISTER_PROC_CLASS.call_once(|| {
⋮----
wc.lpfnWndProc = Some(processing_wnd_proc);
wc.hInstance = instance.into();
wc.hCursor = LoadCursorW(None, IDC_WAIT).unwrap();
⋮----
wc.hbrBackground = HBRUSH(std::ptr::null_mut());
RegisterClassW(&wc);
⋮----
let w = (rect.right - rect.left).abs();
let h = (rect.bottom - rect.top).abs();
⋮----
let hwnd = CreateWindowExW(
⋮----
class_name, w!("Processing"), WS_POPUP, rect.left, rect.top, w, h, None, None, Some(instance.into()), None
).unwrap_or_default();
let mut states = PROC_STATES.lock().unwrap();
states.insert(hwnd.0 as isize, ProcessingState::new(graphics_mode));
drop(states);
SetTimer(Some(hwnd), 1, timer_interval, None);
let _ = ShowWindow(hwnd, SW_SHOWNOACTIVATE);
⋮----
unsafe extern "system" fn processing_wnd_proc(hwnd: HWND, msg: u32, wparam: WPARAM, lparam: LPARAM) -> LRESULT {
⋮----
let state = states.entry(hwnd.0 as isize).or_insert(ProcessingState::new("standard".to_string()));
⋮----
let _ = KillTimer(Some(hwnd), 1); state.timer_killed = true;
SetTimer(Some(hwnd), 2, 25, None);
⋮----
LRESULT(0)
⋮----
let _ = KillTimer(Some(hwnd), 1); let _ = KillTimer(Some(hwnd), 2);
let _ = DestroyWindow(hwnd);
return LRESULT(0);
⋮----
let mut rect = RECT::default(); let _ = GetWindowRect(hwnd, &mut rect);
let w = (rect.right - rect.left).abs(); let h = (rect.bottom - rect.top).abs();
⋮----
let state = states.get_mut(&(hwnd.0 as isize)).unwrap();
⋮----
(MAX_GLOW_BUFFER_DIM as f32 / w as f32).min(MAX_GLOW_BUFFER_DIM as f32 / h as f32).min(1.0)
⋮----
let buf_w = ((w as f32) * scale_factor).ceil() as i32;
let buf_h = ((h as f32) * scale_factor).ceil() as i32;
if state.cache_hbm.is_invalid() || state.scaled_w != buf_w || state.scaled_h != buf_h {
state.cleanup();
let screen_dc = GetDC(None);
⋮----
let res = CreateDIBSection(Some(screen_dc), &bmi, DIB_RGB_COLORS, &mut state.cache_bits, None, 0);
ReleaseDC(None, screen_dc);
if let Ok(hbm) = res { if !hbm.is_invalid() && !state.cache_bits.is_null() { state.cache_hbm = hbm; state.scaled_w = buf_w; state.scaled_h = buf_h; } else { return LRESULT(0); } } else { return LRESULT(0); }
⋮----
if !is_fading && !state.cache_bits.is_null() {
⋮----
let scaled_dc = CreateCompatibleDC(Some(screen_dc)); SelectObject(scaled_dc, state.cache_hbm.into());
⋮----
let dest_hbm = CreateDIBSection(Some(screen_dc), &dest_bmi, DIB_RGB_COLORS, &mut dest_bits, None, 0);
⋮----
if !hbm.is_invalid() {
let dest_dc = CreateCompatibleDC(Some(screen_dc)); SelectObject(dest_dc, hbm.into());
SetStretchBltMode(dest_dc, HALFTONE); let _ = StretchBlt(dest_dc, 0, 0, w, h, Some(scaled_dc), 0, 0, state.scaled_w, state.scaled_h, SRCCOPY);
let _ = DeleteDC(scaled_dc); (Some((dest_dc, hbm)), w, h)
} else { let _ = DeleteDC(scaled_dc); (None, state.scaled_w, state.scaled_h) }
⋮----
let (mem_dc, old_hbm, temp_res) = if let Some((dc, hbm)) = final_hbm { (dc, HGDIOBJ::default(), Some(hbm)) } else { let dc = CreateCompatibleDC(Some(screen_dc)); let old = SelectObject(dc, state.cache_hbm.into()); (dc, old, None) };
⋮----
let _ = UpdateLayeredWindow(hwnd, None, None, Some(&size), Some(mem_dc), Some(&pt_src), COLORREF(0), Some(&blend), ULW_ALPHA);
if temp_res.is_some() { let _ = DeleteDC(mem_dc); if let Some(hbm) = temp_res { let _ = DeleteObject(hbm.into()); } } else { SelectObject(mem_dc, old_hbm); let _ = DeleteDC(mem_dc); }
⋮----
WM_PAINT => { let mut ps = PAINTSTRUCT::default(); BeginPaint(hwnd, &mut ps); let _ = EndPaint(hwnd, &mut ps); LRESULT(0) }
WM_DESTROY => { let mut states = PROC_STATES.lock().unwrap(); if let Some(mut state) = states.remove(&(hwnd.0 as isize)) { state.cleanup(); } LRESULT(0) }
_ => DefWindowProcW(hwnd, msg, wparam, lparam),
</file>

<file path="src/overlay/realtime_webview.rs">
pub mod state;
pub mod webview;
pub mod wndproc;
pub mod app_selection;
pub mod manager;
</file>

<file path="src/overlay/realtime_webview/wndproc.rs">
use std::sync::atomic::Ordering;
use wry::Rect;
⋮----
use super::webview::update_webview_text;
pub unsafe extern "system" fn realtime_wnd_proc(hwnd: HWND, msg: u32, wparam: WPARAM, lparam: LPARAM) -> LRESULT {
⋮----
if let Ok(state) = REALTIME_STATE.lock() {
⋮----
let pos = state.last_committed_pos.min(full.len());
⋮----
let old = old_raw.trim_end();
let new = new_raw.trim_start();
if !old.is_empty() && !new.is_empty() {
(old.to_string(), format!(" {}", new))
⋮----
(old.to_string(), new.to_string())
⋮----
update_webview_text(hwnd, &old_text, &new_text);
LRESULT(0)
⋮----
let rms_bits = REALTIME_RMS.load(Ordering::Relaxed);
⋮----
let script = format!("if(window.updateVolume) window.updateVolume({});", rms);
REALTIME_WEBVIEWS.with(|wvs| {
if let Some(webview) = wvs.borrow().get(&hwnd_key) {
let _ = webview.evaluate_script(&script);
⋮----
let script = format!("if(window.updateTtsSpeed) window.updateTtsSpeed({});", speed);
⋮----
let _ = webview.set_bounds(Rect {
⋮----
REALTIME_STOP_SIGNAL.store(true, Ordering::SeqCst);
let _ = DestroyWindow(hwnd);
if !std::ptr::addr_of!(TRANSLATION_HWND).read().is_invalid() {
let _ = DestroyWindow(TRANSLATION_HWND);
⋮----
PostQuitMessage(0);
⋮----
_ => DefWindowProcW(hwnd, msg, wparam, lparam),
⋮----
pub unsafe extern "system" fn translation_wnd_proc(hwnd: HWND, msg: u32, wparam: WPARAM, lparam: LPARAM) -> LRESULT {
⋮----
let old = state.committed_translation.trim_end();
let new = state.uncommitted_translation.trim_start();
⋮----
let app_selected = SELECTED_APP_PID.load(Ordering::SeqCst) > 0;
let is_mic_mode = NEW_AUDIO_SOURCE.lock().map(|s| s.is_empty() || s.as_str() == "mic").unwrap_or(true);
⋮----
if REALTIME_TTS_ENABLED.load(Ordering::SeqCst) && tts_allowed && !old_text.is_empty() {
let old_len = old_text.len();
if LAST_SPOKEN_LENGTH.load(Ordering::SeqCst) == 0 && old_len > 50 {
let text = old_text.trim_end();
let search_limit = text.len().saturating_sub(1);
⋮----
let last_boundary = text[..search_limit].rfind(|c| c == '.' || c == '?' || c == '!' || c == '\n');
⋮----
LAST_SPOKEN_LENGTH.store(idx + 1, Ordering::SeqCst);
⋮----
let last_spoken = LAST_SPOKEN_LENGTH.load(Ordering::SeqCst);
⋮----
let new_committed = old_text[last_spoken..].to_string();
if !new_committed.trim().is_empty() {
if let Ok(mut queue) = COMMITTED_TRANSLATION_QUEUE.lock() {
queue.push_back(new_committed.clone());
⋮----
crate::api::tts::TTS_MANAGER.speak_realtime(&new_committed, hwnd_val);
⋮----
LAST_SPOKEN_LENGTH.store(old_len, Ordering::SeqCst);
⋮----
let script = format!("if(window.switchModel) window.switchModel('{}');", model_name);
⋮----
let _ = webview.evaluate_script(script);
⋮----
crate::api::tts::TTS_MANAGER.stop();
⋮----
if !std::ptr::addr_of!(REALTIME_HWND).read().is_invalid() {
let _ = DestroyWindow(REALTIME_HWND);
</file>

<file path="src/overlay/result/event_handler/click_actions.rs">
use windows::Win32::UI::Input::KeyboardAndMouse::ReleaseCapture;
use std::mem::size_of;
use windows::Win32::Graphics::Gdi::InvalidateRect;
use windows::core::PCWSTR;
⋮----
use crate::overlay::result::markdown_view;
use crate::overlay::result::refine_input;
use crate::overlay::utils::to_wstring;
use super::misc::WM_CREATE_WEBVIEW;
pub unsafe fn handle_lbutton_up(hwnd: HWND) -> LRESULT {
let _ = ReleaseCapture();
⋮----
let mut states = WINDOW_STATES.lock().unwrap();
if let Some(state) = states.get_mut(&(hwnd.0 as isize)) {
⋮----
if let Some(last) = state.text_history.pop() {
let current_text_for_redo = state.full_text.clone();
prev_text = Some(last.clone());
⋮----
if !current_text_for_redo.is_empty() {
state.redo_history.push(current_text_for_redo);
⋮----
let wide_text = to_wstring(&txt);
let _ = SetWindowTextW(hwnd, PCWSTR(wide_text.as_ptr()));
⋮----
let _ = InvalidateRect(Some(hwnd), None, false);
⋮----
if let Some(redo_text) = state.redo_history.pop() {
let current_text_for_undo = state.full_text.clone();
next_text = Some(redo_text.clone());
⋮----
if !current_text_for_undo.is_empty() {
state.text_history.push(current_text_for_undo);
⋮----
let states = WINDOW_STATES.lock().unwrap();
if let Some(state) = states.get(&(hwnd.0 as isize)) {
⋮----
states.get(&(hwnd.0 as isize)).map(|s| s.is_hovered).unwrap_or(false)
⋮----
let app = crate::APP.lock().unwrap();
app.config.ui_language.clone()
⋮----
let text_len = GetWindowTextLengthW(hwnd) + 1;
let mut buf = vec![0u16; text_len as usize];
GetWindowTextW(hwnd, &mut buf);
let text = String::from_utf16_lossy(&buf[..text_len as usize - 1]).to_string();
⋮----
SetTimer(Some(hwnd), 1, 1500, None);
⋮----
(state.is_markdown_mode, state.full_text.clone())
⋮----
let _ = PostMessageW(Some(hwnd), WM_CREATE_WEBVIEW, WPARAM(0), LPARAM(0));
SetTimer(Some(hwnd), 2, 30, None);
⋮----
let _ = KillTimer(Some(hwnd), 2);
⋮----
let _ = TrackMouseEvent(&mut tme);
⋮----
state.full_text.clone()
⋮----
if !full_text.is_empty() {
⋮----
(state.full_text.clone(), state.tts_request_id, state.tts_loading)
⋮----
} else if current_tts_id != 0 && crate::api::tts::TTS_MANAGER.is_speaking(current_tts_id) {
crate::api::tts::TTS_MANAGER.stop();
⋮----
} else if !full_text.is_empty() {
⋮----
let request_id = crate::api::tts::TTS_MANAGER.speak(&full_text, hwnd.0 as isize);
⋮----
if let Some(state) = states.get(&(hwnd.0 as isize)) { state.linked_window } else { None }
⋮----
if IsWindow(Some(linked)).as_bool() {
let _ = PostMessageW(Some(linked), WM_CLOSE, WPARAM(0), LPARAM(0));
⋮----
let _ = PostMessageW(Some(hwnd), WM_CLOSE, WPARAM(0), LPARAM(0));
⋮----
LRESULT(0)
⋮----
pub unsafe fn handle_rbutton_up(hwnd: HWND) -> LRESULT {
⋮----
pub unsafe fn handle_mbutton_up() -> LRESULT {
⋮----
if let Ok(states) = WINDOW_STATES.lock() {
for (&hwnd_int, _) in states.iter() {
targets.push(HWND(hwnd_int as *mut std::ffi::c_void));
⋮----
if IsWindow(Some(target)).as_bool() {
let _ = PostMessageW(Some(target), WM_CLOSE, WPARAM(0), LPARAM(0));
</file>

<file path="src/overlay/result/event_handler/misc.rs">
use std::sync::Arc;
use crate::overlay::result::state::WINDOW_STATES;
use crate::overlay::result::paint;
use crate::overlay::result::markdown_view;
use crate::overlay::result::refine_input;
⋮----
pub unsafe fn handle_erase_bkgnd(_hwnd: HWND, _wparam: WPARAM) -> LRESULT {
LRESULT(1)
⋮----
pub unsafe fn handle_ctl_color_edit(wparam: WPARAM) -> LRESULT {
let hdc = HDC(wparam.0 as *mut core::ffi::c_void);
SetBkMode(hdc, OPAQUE);
SetBkColor(hdc, COLORREF(0x00FFFFFF));
SetTextColor(hdc, COLORREF(0x00000000));
let hbrush = GetStockObject(WHITE_BRUSH);
LRESULT(hbrush.0 as isize)
⋮----
pub unsafe fn handle_destroy(hwnd: HWND) -> LRESULT {
⋮----
let mut states = WINDOW_STATES.lock().unwrap();
if let Some(state) = states.remove(&(hwnd.0 as isize)) {
⋮----
crate::api::tts::TTS_MANAGER.stop_if_active(state.tts_request_id);
⋮----
token_to_signal = state.cancellation_token.clone();
⋮----
token.store(true, std::sync::atomic::Ordering::Relaxed);
windows_to_close = states.iter()
.filter(|(_, s)| {
⋮----
.map(|(k, _)| HWND(*k as *mut core::ffi::c_void))
.collect();
⋮----
if !state.content_bitmap.is_invalid() {
let _ = DeleteObject(state.content_bitmap.into());
⋮----
if !state.bg_bitmap.is_invalid() {
let _ = DeleteObject(state.bg_bitmap.into());
⋮----
if !state.edit_font.is_invalid() {
let _ = DeleteObject(state.edit_font.into());
⋮----
let _ = KillTimer(Some(hwnd), 2);
⋮----
let _ = PostMessageW(Some(other_hwnd), WM_CLOSE, WPARAM(0), LPARAM(0));
⋮----
LRESULT(0)
⋮----
pub unsafe fn handle_paint(hwnd: HWND) -> LRESULT {
⋮----
pub unsafe fn handle_keydown() -> LRESULT {
⋮----
pub unsafe fn handle_create_webview(hwnd: HWND) -> LRESULT {
⋮----
let states = WINDOW_STATES.lock().unwrap();
if let Some(state) = states.get(&(hwnd.0 as isize)) {
(state.full_text.clone(), state.is_hovered)
⋮----
if let Some(state) = states.get_mut(&(hwnd.0 as isize)) {
⋮----
let _ = InvalidateRect(Some(hwnd), None, false);
</file>

<file path="src/overlay/result/event_handler/mod.rs">
pub mod misc;
pub mod timer_tasks;
pub mod mouse_input;
pub mod click_actions;
pub unsafe extern "system" fn result_wnd_proc(hwnd: HWND, msg: u32, wparam: WPARAM, lparam: LPARAM) -> LRESULT {
⋮----
_ => DefWindowProcW(hwnd, msg, wparam, lparam),
</file>

<file path="src/overlay/result/event_handler/mouse_input.rs">
use std::mem::size_of;
use std::sync::Arc;
⋮----
use crate::overlay::result::markdown_view;
use crate::overlay::result::refine_input;
unsafe fn set_rounded_edit_region(h_edit: HWND, w: i32, h: i32) {
let rgn = CreateRoundRectRgn(0, 0, w, h, 12, 12);
let _ = SetWindowRgn(h_edit, Some(rgn), true);
⋮----
pub unsafe fn handle_set_cursor(hwnd: HWND) -> LRESULT {
let mut cursor_id = PCWSTR(std::ptr::null());
⋮----
let _ = GetClientRect(hwnd, &mut rect);
⋮----
let _ = GetCursorPos(&mut pt);
let _ = ScreenToClient(hwnd, &mut pt);
⋮----
let states = WINDOW_STATES.lock().unwrap();
if let Some(state) = states.get(&(hwnd.0 as isize)) {
⋮----
SetCursor(Some(LoadCursorW(None, IDC_IBEAM).unwrap()));
return LRESULT(1);
⋮----
let edge = get_resize_edge(rect.right, rect.bottom, pt.x, pt.y);
⋮----
if should_show_buttons(rect.right, rect.bottom) {
let copy_rect = get_copy_btn_rect(rect.right, rect.bottom);
let edit_rect = get_edit_btn_rect(rect.right, rect.bottom);
let undo_rect = get_undo_btn_rect(rect.right, rect.bottom);
⋮----
has_history = !state.text_history.is_empty();
⋮----
let md_rect = get_markdown_btn_rect(rect.right, rect.bottom);
⋮----
let dl_rect = get_download_btn_rect(rect.right, rect.bottom);
⋮----
let speaker_rect = get_speaker_btn_rect(rect.right, rect.bottom);
⋮----
if !cursor_id.0.is_null() {
SetCursor(Some(LoadCursorW(None, cursor_id).unwrap()));
LRESULT(1)
⋮----
SetCursor(Some(HCURSOR(std::ptr::null_mut())));
⋮----
pub unsafe fn handle_lbutton_down(hwnd: HWND, lparam: LPARAM) -> LRESULT {
⋮----
let edge = get_resize_edge(width, height, x, y);
⋮----
let _ = GetWindowRect(hwnd, &mut window_rect);
⋮----
let _ = GetCursorPos(&mut screen_pt);
let mut states = WINDOW_STATES.lock().unwrap();
if let Some(state) = states.get_mut(&(hwnd.0 as isize)) {
⋮----
SetCapture(hwnd);
LRESULT(0)
⋮----
pub unsafe fn handle_rbutton_down(hwnd: HWND, _lparam: LPARAM) -> LRESULT {
⋮----
token_to_match = state.cancellation_token.clone();
⋮----
for (&h_val, s) in states.iter() {
⋮----
let h = HWND(h_val as *mut std::ffi::c_void);
⋮----
let _ = GetWindowRect(h, &mut r);
group_snapshot.push((h, r));
⋮----
if group_snapshot.len() <= 1 {
group_snapshot.clear();
⋮----
queue.push_back(hwnd);
visited.insert(hwnd.0);
while let Some(current) = queue.pop_front() {
⋮----
let _ = GetWindowRect(current, &mut r);
group_snapshot.push((current, r));
if let Some(s) = states.get(&(current.0 as isize)) {
⋮----
if states.contains_key(&(linked.0 as isize)) {
if !visited.contains(&linked.0) {
visited.insert(linked.0);
queue.push_back(linked);
⋮----
pub unsafe fn handle_mouse_move(hwnd: HWND, lparam: LPARAM) -> LRESULT {
⋮----
let hover_edge = get_resize_edge(rect.right, rect.bottom, x as i32, y as i32);
⋮----
let drag_impulse = if matches!(&state.interaction_mode, InteractionMode::DraggingWindow | InteractionMode::DraggingGroup(_)) { 0.0 } else { (dx * 1.5).clamp(-20.0, 20.0) };
⋮----
state.physics.current_tilt = state.physics.current_tilt.clamp(-22.5, 22.5);
⋮----
if !state.text_history.is_empty() && !state.is_browsing {
⋮----
let redo_rect = get_redo_btn_rect(rect.right, rect.bottom);
if !state.redo_history.is_empty() && !state.is_browsing {
⋮----
let _ = TrackMouseEvent(&mut tme);
⋮----
let _ = GetCursorPos(&mut curr_pt);
⋮----
if dx.abs() > 3 || dy.abs() > 3 { state.has_moved_significantly = true; }
⋮----
let _ = SetWindowPos(hwnd, Some(HWND::default()), new_x, new_y, 0, 0, SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);
⋮----
group_moves.push((*h, new_x, new_y));
⋮----
ResizeEdge::Right | ResizeEdge::TopRight | ResizeEdge::BottomRight => { new_rect.right = (state.drag_start_window_rect.right + dx).max(state.drag_start_window_rect.left + min_w); }
ResizeEdge::Left | ResizeEdge::TopLeft | ResizeEdge::BottomLeft => { new_rect.left = (state.drag_start_window_rect.left + dx).min(state.drag_start_window_rect.right - min_w); }
⋮----
ResizeEdge::Bottom | ResizeEdge::BottomRight | ResizeEdge::BottomLeft => { new_rect.bottom = (state.drag_start_window_rect.bottom + dy).max(state.drag_start_window_rect.top + min_h); }
ResizeEdge::Top | ResizeEdge::TopLeft | ResizeEdge::TopRight => { new_rect.top = (state.drag_start_window_rect.top + dy).min(state.drag_start_window_rect.bottom - min_h); }
⋮----
let _ = SetWindowPos(hwnd, Some(HWND::default()), new_rect.left, new_rect.top, w, h, SWP_NOZORDER | SWP_NOACTIVATE);
⋮----
let _ = SetWindowPos(state.edit_hwnd, Some(HWND_TOP), 10, 10, edit_w, edit_h, SWP_NOACTIVATE);
set_rounded_edit_region(state.edit_hwnd, edit_w, edit_h);
⋮----
let _ = InvalidateRect(Some(hwnd), None, false);
⋮----
let _ = SetWindowPos(h, Some(HWND::default()), x, y, 0, 0, SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);
⋮----
pub unsafe fn handle_mouse_leave(hwnd: HWND) -> LRESULT {
</file>

<file path="src/overlay/result/event_handler/timer_tasks.rs">
use windows::Win32::Graphics::Gdi::InvalidateRect;
use windows::core::PCWSTR;
⋮----
use crate::overlay::result::markdown_view;
use crate::overlay::result::refine_input;
use super::super::logic;
use crate::overlay::utils::to_wstring;
⋮----
pub unsafe fn handle_timer(hwnd: HWND, wparam: WPARAM) -> LRESULT {
⋮----
let _ = GetCursorPos(&mut cursor_pos);
⋮----
let _ = GetWindowRect(hwnd, &mut window_rect);
⋮----
let states = WINDOW_STATES.lock().unwrap();
if let Some(state) = states.get(&(hwnd.0 as isize)) {
⋮----
let mut states = WINDOW_STATES.lock().unwrap();
if let Some(state) = states.get_mut(&(hwnd.0 as isize)) {
⋮----
let _ = InvalidateRect(Some(hwnd), None, false);
⋮----
return LRESULT(0);
⋮----
.duration_since(UNIX_EPOCH)
.map(|d| d.as_millis() as u32)
.unwrap_or(0);
⋮----
if state.pending_text.is_some() &&
(state.last_text_update_time == 0 || now.wrapping_sub(state.last_text_update_time) > 16) {
pending_update = state.pending_text.take();
⋮----
if submitted && !input_text.trim().is_empty() {
⋮----
text_to_refine = state.full_text.clone();
state.text_history.push(text_to_refine.clone());
state.redo_history.clear();
state.input_text = text_to_refine.clone();
⋮----
state.pending_text = Some(String::new());
⋮----
states.get(&(hwnd.0 as isize)).map(|s| s.is_hovered).unwrap_or(false)
⋮----
let wide_text = to_wstring(&txt);
let _ = SetWindowTextW(hwnd, PCWSTR(wide_text.as_ptr()));
⋮----
state.full_text = txt.clone();
⋮----
(Some(state.full_text.clone()), state.is_hovered)
⋮----
if trigger_refine && !user_input.trim().is_empty() {
⋮----
if let Some(s) = states.get(&(hwnd.0 as isize)) {
(s.context_data.clone(), s.model_id.clone(), s.provider.clone(), s.streaming_enabled, s.preset_prompt.clone())
⋮----
(RefineContext::None, "scout".to_string(), "groq".to_string(), false, "".to_string())
⋮----
let (final_prev_text, final_user_prompt) = if text_to_refine.trim().is_empty() && !preset_prompt.is_empty() {
⋮----
let capture_hwnd = HWND(hwnd_val as *mut std::ffi::c_void);
⋮----
let app = crate::APP.lock().unwrap();
(app.config.api_key.clone(), app.config.gemini_api_key.clone())
⋮----
&app.config.ui_language.clone()
⋮----
if let Some(state) = states.get_mut(&(capture_hwnd.0 as isize)) {
⋮----
if chunk.starts_with(crate::api::WIPE_SIGNAL) {
acc_text.clear();
acc_text.push_str(&chunk[crate::api::WIPE_SIGNAL.len()..]);
⋮----
acc_text.push_str(chunk);
⋮----
state.pending_text = Some(acc_text.clone());
state.full_text = acc_text.clone();
⋮----
state.full_text = final_text.clone();
state.pending_text = Some(final_text);
⋮----
.map(|m| m.full_name)
.unwrap_or_else(|| model_id.to_string());
(app.config.ui_language.clone(), full_name)
⋮----
let err_msg = crate::overlay::utils::get_error_message(&e.to_string(), &lang, Some(&model_full_name));
state.pending_text = Some(err_msg.clone());
⋮----
LRESULT(0)
</file>

<file path="src/overlay/result/layout.rs">
pub fn should_show_buttons(window_w: i32, _window_h: i32) -> bool {
⋮----
fn rects_overlap(a: &RECT, b: &RECT, gap: i32) -> bool {
⋮----
fn get_all_active_window_rects() -> Vec<RECT> {
⋮----
if let Ok(states) = WINDOW_STATES.lock() {
for (&hwnd_key, _state) in states.iter() {
let hwnd = HWND(hwnd_key as *mut std::ffi::c_void);
⋮----
if IsWindow(Some(hwnd)).as_bool() {
⋮----
if GetWindowRect(hwnd, &mut rect).is_ok() {
rects.push(rect);
⋮----
fn would_overlap_existing(proposed: &RECT, existing: &[RECT], gap: i32) -> bool {
existing.iter().any(|r| rects_overlap(proposed, r, gap))
⋮----
pub fn calculate_next_window_rect(prev: RECT, screen_w: i32, screen_h: i32) -> RECT {
⋮----
let w = (prev.right - prev.left).abs();
let h = (prev.bottom - prev.top).abs();
let existing_windows = get_all_active_window_rects();
⋮----
&& !would_overlap_existing(&right_candidate, &existing_windows, gap) {
⋮----
&& !would_overlap_existing(&bottom_candidate, &existing_windows, gap) {
⋮----
&& !would_overlap_existing(&left_candidate, &existing_windows, gap) {
⋮----
&& !would_overlap_existing(&top_candidate, &existing_windows, gap) {
⋮----
&& !would_overlap_existing(&diag, &existing_windows, gap) {
⋮----
&& !would_overlap_existing(&cascade, &existing_windows, gap) {
⋮----
pub fn get_copy_btn_rect(window_w: i32, window_h: i32) -> RECT {
⋮----
pub fn get_edit_btn_rect(window_w: i32, window_h: i32) -> RECT {
let speaker_rect = get_speaker_btn_rect(window_w, window_h);
⋮----
pub fn get_markdown_btn_rect(window_w: i32, window_h: i32) -> RECT {
let edit_rect = get_edit_btn_rect(window_w, window_h);
⋮----
pub fn get_download_btn_rect(window_w: i32, window_h: i32) -> RECT {
let md_rect = get_markdown_btn_rect(window_w, window_h);
⋮----
pub fn get_undo_btn_rect(window_w: i32, window_h: i32) -> RECT {
let dl_rect = get_download_btn_rect(window_w, window_h);
⋮----
pub fn get_redo_btn_rect(window_w: i32, window_h: i32) -> RECT {
let undo_rect = get_undo_btn_rect(window_w, window_h);
⋮----
pub fn get_speaker_btn_rect(window_w: i32, window_h: i32) -> RECT {
let copy_rect = get_copy_btn_rect(window_w, window_h);
⋮----
pub fn get_resize_edge(width: i32, height: i32, x: i32, y: i32) -> ResizeEdge {
</file>

<file path="src/overlay/result/logic.rs">
fn rand_float(min: f32, max: f32) -> f32 {
⋮----
SEED = SEED.wrapping_mul(1103515245).wrapping_add(12345);
⋮----
pub fn handle_timer(hwnd: HWND, wparam: WPARAM) {
⋮----
let mut states = WINDOW_STATES.lock().unwrap();
if let Some(state) = states.get_mut(&(hwnd.0 as isize)) {
⋮----
for mut pt in p.particles.drain(..) {
⋮----
if pt.life > 0.0 { keep.push(pt); }
⋮----
let _ = GetClientRect(hwnd, &mut client_rect);
⋮----
let _ = InvalidateRect(Some(hwnd), Some(&bottom_region), false);
⋮----
let _ = InvalidateRect(Some(hwnd), Some(&left_margin), false);
⋮----
let _ = InvalidateRect(Some(hwnd), Some(&right_margin), false);
⋮----
let _ = InvalidateRect(Some(hwnd), None, false);
⋮----
let _ = SetLayeredWindowAttributes(hwnd, COLORREF(0), 0, LWA_ALPHA);
⋮----
let states = WINDOW_STATES.lock().unwrap();
if let Some(state) = states.get(&(hwnd.0 as isize)) { state.linked_window } else { None }
⋮----
if IsWindow(Some(linked)).as_bool() {
let _ = SetLayeredWindowAttributes(linked, COLORREF(0), 0, LWA_ALPHA);
let _ = PostMessageW(Some(linked), WM_CLOSE, WPARAM(0), LPARAM(0));
⋮----
let _ = PostMessageW(Some(hwnd), WM_CLOSE, WPARAM(0), LPARAM(0));
⋮----
let _ = KillTimer(Some(hwnd), 1);
⋮----
state.physics.particles.push(DustParticle {
x: cx + rand_float(-10.0, 10.0),
⋮----
vx: rand_float(-2.0, 2.0),
vy: rand_float(-2.0, -5.0),
⋮----
size: rand_float(1.0, 3.0),
</file>

<file path="src/overlay/result/mod.rs">
pub mod state;
pub mod paint;
mod logic;
pub mod layout;
mod window;
mod event_handler;
pub mod markdown_view;
pub mod refine_input;
</file>

<file path="src/win_types.rs">
use windows::Win32::UI::WindowsAndMessaging::HHOOK;
use windows::Win32::Graphics::Gdi::HBITMAP;
⋮----
pub struct SendHwnd(pub HWND);
unsafe impl Send for SendHwnd {}
unsafe impl Sync for SendHwnd {}
impl Default for SendHwnd {
fn default() -> Self {
SendHwnd(HWND::default())
⋮----
impl SendHwnd {
pub fn is_invalid(&self) -> bool {
self.0.is_invalid()
⋮----
pub fn as_isize(&self) -> isize {
⋮----
pub fn from_isize(val: isize) -> Self {
SendHwnd(HWND(val as *mut std::ffi::c_void))
⋮----
pub struct SendHandle(pub HANDLE);
unsafe impl Send for SendHandle {}
unsafe impl Sync for SendHandle {}
impl SendHandle {
⋮----
pub struct SendHhook(pub HHOOK);
unsafe impl Send for SendHhook {}
unsafe impl Sync for SendHhook {}
impl Default for SendHhook {
⋮----
SendHhook(HHOOK::default())
⋮----
pub struct SendHbitmap(pub HBITMAP);
unsafe impl Send for SendHbitmap {}
unsafe impl Sync for SendHbitmap {}
impl Default for SendHbitmap {
⋮----
SendHbitmap(HBITMAP::default())
⋮----
impl SendHbitmap {
</file>

<file path="build.ps1">
# Re-patch egui-snarl to ensure custom scroll-to-zoom is applied
Write-Host "Setting up patched egui-snarl..." -ForegroundColor Cyan
$snarlDir = Join-Path $PSScriptRoot "libs\egui-snarl"
if (Test-Path $snarlDir) {
    Remove-Item $snarlDir -Recurse -Force
}
& (Join-Path $PSScriptRoot "scripts\setup-egui-snarl.ps1")

# Extract version from Cargo.toml
$cargoContent = Get-Content "Cargo.toml" -Raw
if ($cargoContent -match 'version\s*=\s*"([^"]+)"') {
    $version = $matches[1]
}
else {
    Write-Host "Failed to extract version from Cargo.toml" -ForegroundColor Red
    exit 1
}

$upxDir = "tools/upx"
$upxPath = "$upxDir/upx.exe"

# Download UPX if not present
if (-not (Test-Path $upxPath)) {
    Write-Host "Downloading UPX..." -ForegroundColor Cyan
    New-Item -ItemType Directory -Path $upxDir -Force | Out-Null
    
    $url = "https://github.com/upx/upx/releases/download/v5.0.2/upx-5.0.2-win64.zip"
    $zip = "$upxDir/upx.zip"
    
    Invoke-WebRequest -Uri $url -OutFile $zip
    Expand-Archive -Path $zip -DestinationPath $upxDir -Force
    Move-Item "$upxDir/upx-5.0.2-win64/upx.exe" $upxPath -Force
    Remove-Item "$upxDir/upx-5.0.2-win64" -Recurse
    Remove-Item $zip
    
    Write-Host "UPX downloaded" -ForegroundColor Green
}

# Output paths
$outputExeNamePacked = "ScreenGoatedToolbox_v$version.exe"
$outputExeNameNoPack = "ScreenGoatedToolbox_v${version}_nopack.exe"
$outputPathPacked = "target/release/$outputExeNamePacked"
$outputPathNoPack = "target/release-safe/$outputExeNameNoPack"
$exePathRelease = "target/release/screen-goated-toolbox.exe"
$exePathSafe = "target/release-safe/screen-goated-toolbox.exe"

# =============================================================================
# STEP 1: Build AV-SAFE version (with debug symbols, no stripping)
# =============================================================================
Write-Host ""
Write-Host "=== Building AV-SAFE version (v$version) ===" -ForegroundColor Cyan
Write-Host "Using 'release-safe' profile with debug symbols for better AV trust..." -ForegroundColor Gray
$env:RUSTFLAGS="--cfg nopack"
cargo build --profile release-safe
$env:RUSTFLAGS=""

if (Test-Path $exePathSafe) {
    if (Test-Path $outputPathNoPack) {
        Remove-Item $outputPathNoPack
    }
    Move-Item $exePathSafe $outputPathNoPack
    $sizeNoPack = (Get-Item $outputPathNoPack).Length / 1MB
    Write-Host "  -> Created: $outputExeNameNoPack ($([Math]::Round($sizeNoPack, 2)) MB)" -ForegroundColor Cyan
}
else {
    Write-Host "  -> FAILED: release-safe build did not produce exe" -ForegroundColor Red
}

# =============================================================================
# STEP 2: Build PACKED version (stripped + UPX compressed)
# =============================================================================
Write-Host ""
Write-Host "=== Building PACKED version (v$version) ===" -ForegroundColor Green
Write-Host "Using 'release' profile with UPX compression..." -ForegroundColor Gray
cargo build --release

if (Test-Path $exePathRelease) {
    Write-Host "Compressing with UPX (--ultra-brute --lzma)..." -ForegroundColor Green
    & $upxPath --ultra-brute --lzma $exePathRelease
    
    if (Test-Path $outputPathPacked) {
        Remove-Item $outputPathPacked
    }
    Move-Item $exePathRelease $outputPathPacked
    $sizePacked = (Get-Item $outputPathPacked).Length / 1MB
    Write-Host "  -> Created: $outputExeNamePacked ($([Math]::Round($sizePacked, 2)) MB)" -ForegroundColor Green
}
else {
    Write-Host "  -> FAILED: release build did not produce exe" -ForegroundColor Red
}

# =============================================================================
# SUMMARY
# =============================================================================
Write-Host ""
Write-Host "=======================================" -ForegroundColor White
Write-Host "         BUILD COMPLETE v$version" -ForegroundColor White
Write-Host "=======================================" -ForegroundColor White
Write-Host ""
if (Test-Path $outputPathPacked) {
    Write-Host "  [PACKED]   $outputExeNamePacked" -ForegroundColor Green
    Write-Host "             Size: $([Math]::Round($sizePacked, 2)) MB | UPX compressed" -ForegroundColor Gray
}
if (Test-Path $outputPathNoPack) {
    Write-Host ""
    Write-Host "  [AV-SAFE]  $outputExeNameNoPack" -ForegroundColor Cyan
    Write-Host "             Size: $([Math]::Round($sizeNoPack, 2)) MB | Has debug symbols, no UPX" -ForegroundColor Gray
}
Write-Host ""
Write-Host "TIP: Offer '_nopack' to users with Windows Defender issues." -ForegroundColor Yellow
Write-Host ""
</file>

<file path="build.rs">
use std::fs;
⋮----
use std::path::Path;
fn main() {
let manifest_dir = std::env::var("CARGO_MANIFEST_DIR").unwrap();
let assets_dir = Path::new(&manifest_dir).join("assets");
⋮----
.join("assets")
.join("tray-icon.png");
if tray_source.exists() {
let tray_icon_path = assets_dir.join("tray_icon.png");
⋮----
let resized = img.resize(32, 32, image::imageops::FilterType::Lanczos3);
let _ = resized.save_with_format(&tray_icon_path, image::ImageFormat::Png);
⋮----
let app_icon_path = assets_dir.join("app-icon-small.png");
let app_icon_small_path = assets_dir.join("app-icon-small.png");
if app_icon_path.exists() {
⋮----
let resized = img.resize(256, 256, image::imageops::FilterType::Lanczos3);
let _ = resized.save(&app_icon_small_path);
⋮----
if app_icon_small_path.exists() {
let ico_path = assets_dir.join("app.ico");
create_multi_size_ico(&app_icon_small_path, &ico_path);
⋮----
let ico_path = Path::new(&manifest_dir).join("assets").join("app.ico");
let rc_path = Path::new(&manifest_dir).join("app.rc");
if ico_path.exists() && rc_path.exists() {
let out_dir = std::env::var("OUT_DIR").unwrap();
let res_path = Path::new(&out_dir).join("resources.o");
⋮----
.arg(&rc_path)
.arg("-o")
.arg(&res_path)
.status();
⋮----
Ok(s) if s.success() => {
println!("cargo:rustc-link-arg={}", res_path.display());
⋮----
panic!("windres failed with exit code: {}", s);
⋮----
panic!("Failed to execute windres: {}", e);
⋮----
println!("cargo:rerun-if-changed=assets/app-icon-small.png");
println!("cargo:rerun-if-changed=icon.png");
println!("cargo:rerun-if-changed=app.rc");
println!("cargo:rerun-if-changed=build.rs");
⋮----
fn create_multi_size_ico(png_path: &Path, ico_path: &Path) {
let img = image::open(png_path).expect("Failed to open PNG");
let mut file = fs::File::create(ico_path).expect("Failed to create ICO");
⋮----
let num_images = sizes.len() as u16;
file.write_all(&[0, 0]).unwrap();
file.write_all(&[1, 0]).unwrap();
file.write_all(&num_images.to_le_bytes()).unwrap();
⋮----
let resized = img.resize(size, size, image::imageops::FilterType::Lanczos3);
⋮----
.write_to(&mut buffer, image::ImageOutputFormat::Png)
.unwrap();
data = buffer.into_inner();
⋮----
let rgba = resized.to_rgba8();
data.extend_from_slice(&40u32.to_le_bytes());
data.extend_from_slice(&(size as i32).to_le_bytes());
data.extend_from_slice(&(size as i32 * 2).to_le_bytes());
data.extend_from_slice(&[1, 0]);
data.extend_from_slice(&[32, 0]);
data.extend_from_slice(&[0, 0, 0, 0]);
⋮----
for row in (0..rgba.height()).rev() {
for col in 0..rgba.width() {
let pixel = rgba.get_pixel(col, row);
data.push(pixel[2]);
data.push(pixel[1]);
data.push(pixel[0]);
data.push(pixel[3]);
⋮----
data.push(0);
⋮----
images_data.push(data);
⋮----
for (i, size) in sizes.iter().enumerate() {
⋮----
let data_size = images_data[i].len() as u32;
file.write_all(&[width]).unwrap();
file.write_all(&[height]).unwrap();
file.write_all(&[0]).unwrap();
⋮----
file.write_all(&[32, 0]).unwrap();
file.write_all(&data_size.to_le_bytes()).unwrap();
file.write_all(&offset.to_le_bytes()).unwrap();
⋮----
file.write_all(&data).unwrap();
</file>

<file path="src/api/realtime_audio/capture.rs">
use anyhow::Result;
⋮----
use std::time::Duration;
use super::REALTIME_RMS;
⋮----
pub fn start_per_app_capture(
⋮----
use std::collections::VecDeque;
⋮----
if wasapi::initialize_mta().is_err() {
eprintln!("Per-app capture: Failed to initialize MTA");
⋮----
eprintln!(
⋮----
if let Err(e) = audio_client.initialize_client(&desired_format, &Direction::Capture, &mode)
⋮----
eprintln!("Hint: Per-app capture requires Windows 10 version 1903 or later");
⋮----
let capture_client = match audio_client.get_audiocaptureclient() {
⋮----
eprintln!("Per-app capture: Failed to get capture client: {:?}", e);
⋮----
let event_handle = match audio_client.set_get_eventhandle() {
⋮----
eprintln!("Per-app capture: Failed to get event handle: {:?}", e);
⋮----
if let Err(e) = audio_client.start_stream() {
eprintln!("Per-app capture: Failed to start stream: {:?}", e);
⋮----
while !stop_signal.load(Ordering::Relaxed) {
if event_handle.wait_for_event(100).is_err() {
⋮----
match capture_client.read_from_device_to_deque(&mut capture_buffer) {
⋮----
if !capture_buffer.is_empty() {
⋮----
let sample_count = capture_buffer.len() / bytes_per_sample;
⋮----
while capture_buffer.len() >= bytes_per_sample {
let low = capture_buffer.pop_front().unwrap_or(0);
let high = capture_buffer.pop_front().unwrap_or(0);
⋮----
samples.push(sample);
⋮----
if let Ok(mut buf) = audio_buffer.lock() {
buf.extend(&samples);
⋮----
if !samples.is_empty() {
⋮----
samples.iter().map(|&s| (s as f64 / 32768.0).powi(2)).sum();
let rms = (sum_sq / samples.len() as f64).sqrt() as f32;
REALTIME_RMS.store(rms.to_bits(), Ordering::Relaxed);
⋮----
eprintln!("Per-app capture: Read error: {:?}", e);
⋮----
let _ = audio_client.stop_stream();
⋮----
Ok(())
⋮----
pub fn start_device_loopback_capture(
⋮----
let host = cpal::host_from_id(cpal::HostId::Wasapi).unwrap_or(cpal::default_host());
⋮----
.default_output_device()
.ok_or_else(|| anyhow::anyhow!("No output device available"))?;
let config = device.default_output_config()?;
let sample_rate = config.sample_rate().0;
let channels = config.channels() as usize;
let audio_buffer_clone = audio_buffer.clone();
⋮----
let stop_signal_audio = stop_signal.clone();
let err_fn = |err| eprintln!("Audio stream error: {}", err);
let stream = match config.sample_format() {
cpal::SampleFormat::F32 => device.build_input_stream(
&config.into(),
⋮----
if stop_signal_audio.load(Ordering::Relaxed) {
⋮----
.chunks(channels)
.map(|frame| {
let sum: f32 = frame.iter().sum();
⋮----
(avg.clamp(-1.0, 1.0) * i16::MAX as f32) as i16
⋮----
.collect();
⋮----
let new_len = (mono_samples.len() as f64 * resample_ratio) as usize;
⋮----
.map(|i| {
⋮----
let idx1 = (idx0 + 1).min(mono_samples.len() - 1);
⋮----
.collect()
⋮----
if let Ok(mut buf) = audio_buffer_clone.lock() {
buf.extend(resampled.iter().cloned());
⋮----
if !resampled.is_empty() {
⋮----
.iter()
.map(|&s| (s as f64 / 32768.0).powi(2))
.sum();
let rms = (sum_sq / resampled.len() as f64).sqrt() as f32;
⋮----
cpal::SampleFormat::I16 => device.build_input_stream(
⋮----
let sum: i32 = frame.iter().map(|&s| s as i32).sum();
⋮----
_ => return Err(anyhow::anyhow!("Unsupported audio format")),
⋮----
stream.play()?;
Ok(stream)
⋮----
pub fn start_mic_capture(
⋮----
.default_input_device()
.ok_or_else(|| anyhow::anyhow!("No microphone available. Please connect a microphone."))?;
let config = device.default_input_config()?;
</file>

<file path="src/api/realtime_audio/mod.rs">
mod capture;
mod state;
mod transcription;
mod translation;
mod utils;
mod websocket;
use windows::Win32::UI::WindowsAndMessaging::WM_APP;
⋮----
pub use transcription::start_realtime_transcription;
pub use translation::translate_with_google_gtx;
</file>

<file path="src/api/realtime_audio/translation.rs">
use isolang;
use std::io::BufRead;
⋮----
use urlencoding;
⋮----
use crate::api::client::UREQ_AGENT;
use crate::config::Preset;
use crate::APP;
use super::state::SharedRealtimeState;
⋮----
pub fn run_translation_loop(
⋮----
let translation_block = match preset.blocks.get(1) {
Some(b) => b.clone(),
⋮----
.lock()
.ok()
.and_then(|lang| {
if lang.is_empty() {
⋮----
Some(lang.clone())
⋮----
from_ui.unwrap_or_else(|| {
if !translation_block.selected_language.is_empty() {
translation_block.selected_language.clone()
⋮----
.get("language")
.cloned()
.or_else(|| translation_block.language_vars.get("language1").cloned())
.unwrap_or_else(|| "English".to_string())
⋮----
while !stop_signal.load(Ordering::Relaxed) {
if translation_hwnd.0 != 0 as _ && !unsafe { IsWindow(Some(translation_hwnd)).as_bool() } {
⋮----
if crate::overlay::realtime_webview::LANGUAGE_CHANGE.load(Ordering::SeqCst) {
if let Ok(new_lang) = crate::overlay::realtime_webview::NEW_TARGET_LANGUAGE.lock() {
if !new_lang.is_empty() {
target_language = new_lang.clone();
if let Ok(mut s) = state.lock() {
s.translation_history.clear();
⋮----
crate::overlay::realtime_webview::LANGUAGE_CHANGE.store(false, Ordering::SeqCst);
⋮----
if crate::overlay::realtime_webview::TRANSLATION_MODEL_CHANGE.load(Ordering::SeqCst) {
⋮----
.store(false, Ordering::SeqCst);
⋮----
let should_force = { state.lock().unwrap().should_force_commit_on_timeout() };
⋮----
s.force_commit_all();
let display = s.display_translation.clone();
update_translation_text(translation_hwnd, &display);
refresh_transcription_window();
⋮----
if last_run.elapsed() >= interval {
if !crate::overlay::realtime_webview::TRANS_VISIBLE.load(Ordering::SeqCst) {
⋮----
let s = state.lock().unwrap();
if s.is_transcript_unchanged() {
⋮----
match s.get_translation_chunk() {
Some((text, has_finished)) => (Some(text), has_finished, false),
⋮----
let mut s = state.lock().unwrap();
s.update_last_processed_len();
s.start_new_translation();
⋮----
let app = APP.lock().unwrap();
let groq = app.config.api_key.clone();
let gemini = app.config.gemini_api_key.clone();
let model = app.config.realtime_translation_model.clone();
drop(app);
let history = if let Ok(s) = state.lock() {
s.get_history_messages(&target_language)
⋮----
let current_model = translation_model.as_str();
⋮----
if let Some(text) = translate_with_google_gtx(&chunk, &target_language) {
⋮----
s.append_translation(&text);
⋮----
if has_finished && s.commit_finished_sentences() {
⋮----
("https://generativelanguage.googleapis.com/v1beta/openai/chat/completions".to_string(), "gemma-3-27b-it".to_string(), gemini_key.clone())
⋮----
"https://api.groq.com/openai/v1/chat/completions".to_string(),
"llama-3.1-8b-instant".to_string(),
groq_key.clone(),
⋮----
let system_instruction = format!("You are a professional translator. Translate text to {} to append suitably to the context. Output ONLY the translation, nothing else.", target_language);
⋮----
messages.extend(history_messages.clone());
messages.push(serde_json::json!({"role": "user", "content": format!("{}\n\nTranslate to {}:\n{}", system_instruction, target_language, chunk)}));
⋮----
messages.push(
⋮----
messages.push(serde_json::json!({"role": "user", "content": format!("Translate to {}:\n{}", target_language, chunk)}));
⋮----
if !api_key.is_empty() {
⋮----
.post(&url)
.set("Authorization", &format!("Bearer {}", api_key))
.set("Content-Type", "application/json")
.send_json(payload)
⋮----
resp.header("x-ratelimit-remaining-requests")
⋮----
.header("x-ratelimit-limit-requests")
.unwrap_or("?");
if let Ok(mut app) = APP.lock() {
app.model_usage_stats.insert(
⋮----
format!("{} / {}", remaining, limit),
⋮----
let reader = std::io::BufReader::new(resp.into_reader());
⋮----
for line in reader.lines().flatten() {
if stop_signal.load(Ordering::Relaxed) {
⋮----
if line.starts_with("data: ") {
let json_str = &line["data: ".len()..];
if json_str.trim() == "[DONE]" {
⋮----
.get("choices")
.and_then(|c| c.as_array())
.and_then(|a| a.first())
.and_then(|f| f.get("delta"))
.and_then(|d| d.get("content"))
.and_then(|t| t.as_str())
⋮----
full_translation.push_str(content);
⋮----
s.append_translation(content);
⋮----
update_translation_text(
⋮----
if has_finished && !full_translation.is_empty() {
⋮----
if s.commit_finished_sentences() {
⋮----
handle_fallback_translation(
⋮----
fn handle_fallback_translation(
⋮----
.duration_since(std::time::UNIX_EPOCH)
.unwrap()
.as_nanos();
pool[(nanos as usize) % pool.len()]
⋮----
let mut app = APP.lock().unwrap();
app.config.realtime_translation_model = alt_model.to_string();
⋮----
let _ = PostMessageW(
Some(translation_hwnd),
⋮----
WPARAM(flag),
LPARAM(0),
⋮----
if let Some(text) = translate_with_google_gtx(chunk, target_language) {
⋮----
.to_string(),
"gemma-3-27b-it".to_string(),
gemini_key.to_string(),
⋮----
groq_key.to_string(),
⋮----
if !alt_key.is_empty() {
⋮----
let alt_sys = format!("You are a professional translator. Translate text to {} to append suitably to the context. Output ONLY the translation, nothing else.", target_language);
⋮----
alt_msgs.extend(history_messages.iter().cloned());
alt_msgs.push(serde_json::json!({"role": "user", "content": format!("{}\n\nTranslate to {}:\n{}", alt_sys, target_language, chunk)}));
⋮----
alt_msgs.push(serde_json::json!({"role": "system", "content": alt_sys}));
⋮----
alt_msgs.push(serde_json::json!({"role": "user", "content": format!("Translate to {}:\n{}", target_language, chunk)}));
⋮----
.post(&alt_url)
.set("Authorization", &format!("Bearer {}", alt_key))
⋮----
if let Some(remaining) = resp.header("x-ratelimit-remaining-requests") {
let limit = resp.header("x-ratelimit-limit-requests").unwrap_or("?");
⋮----
.and_then(|a| a.as_array())
.and_then(|v| v.first())
⋮----
.and_then(|s| s.as_str())
⋮----
full_t.push_str(txt);
⋮----
s.append_translation(txt);
let d = s.display_translation.clone();
update_translation_text(translation_hwnd, &d);
⋮----
if has_finished && !full_t.is_empty() {
⋮----
pub fn translate_with_google_gtx(text: &str, target_lang: &str) -> Option<String> {
⋮----
.and_then(|lang| lang.to_639_1())
.map(|code| code.to_string())
.unwrap_or_else(|| "en".to_string());
⋮----
let url = format!(
⋮----
.get(&url)
.set("User-Agent", "Mozilla/5.0")
.timeout(std::time::Duration::from_secs(10))
.call()
⋮----
if let Some(sentences) = json.get(0).and_then(|v| v.as_array()) {
⋮----
if let Some(segment) = sentence_node.get(0).and_then(|s| s.as_str()) {
full_text.push_str(segment);
⋮----
if !full_text.is_empty() {
return Some(full_text);
</file>

<file path="src/api/tts/types.rs">
pub enum AudioEvent {
⋮----
pub struct QueuedRequest {
⋮----
pub struct TtsRequest {
</file>

<file path="src/api/tts/utils.rs">
use windows::Win32::Foundation::HWND;
use windows::Win32::Graphics::Gdi::InvalidateRect;
⋮----
use crate::overlay::result::state::WINDOW_STATES;
pub fn clear_tts_loading_state(hwnd: isize) {
⋮----
let mut states = WINDOW_STATES.lock().unwrap();
if let Some(state) = states.get_mut(&hwnd) {
⋮----
let _ = InvalidateRect(Some(HWND(hwnd as *mut std::ffi::c_void)), None, false);
⋮----
pub fn clear_tts_state(hwnd: isize) {
⋮----
pub fn get_language_instruction_for_text(
⋮----
let detected_code = detected.code();
⋮----
if condition.language_code.eq_ignore_ascii_case(detected_code) {
return Some(condition.instruction.clone());
⋮----
pub fn get_output_devices() -> Vec<(String, String)> {
⋮----
let _ = CoInitializeEx(None, COINIT_MULTITHREADED);
⋮----
if let Ok(collection) = enumerator.EnumAudioEndpoints(eRender, DEVICE_STATE_ACTIVE) {
if let Ok(count) = collection.GetCount() {
⋮----
if let Ok(device) = collection.Item(i) {
if let Ok(id) = device.GetId() {
let id_str = id.to_string().unwrap_or_default();
let name = if let Ok(_props) = device.OpenPropertyStore(STGM_READ) {
id_str.clone()
⋮----
devices.push((id_str, name));
</file>

<file path="src/api/vision.rs">
use super::client::UREQ_AGENT;
⋮----
use crate::gui::locale::LocaleText;
use crate::APP;
use anyhow::Result;
⋮----
pub fn translate_image_streaming<F>(
⋮----
.lock()
.ok()
.and_then(|app| {
let config = app.config.clone();
if config.openrouter_api_key.is_empty() {
⋮----
Some(config.openrouter_api_key.clone())
⋮----
.unwrap_or_default();
⋮----
image.write_to(&mut Cursor::new(&mut image_data), image::ImageFormat::Png)?;
let b64_image = general_purpose::STANDARD.encode(&image_data);
⋮----
.map(|app| {
⋮----
config.ollama_base_url.clone(),
config.ollama_vision_model.clone(),
config.ui_language.clone(),
⋮----
.unwrap_or_else(|| {
⋮----
"http://localhost:11434".to_string(),
model.clone(),
"en".to_string(),
⋮----
let actual_model = if ollama_vision_model.is_empty() {
model.clone()
⋮----
let ollama_image = image::load_from_memory(&image_data)?.to_rgba8();
⋮----
let boundary = format!(
⋮----
body.extend_from_slice(format!("--{}\r\n", boundary).as_bytes());
body.extend_from_slice(b"Content-Disposition: form-data; name=\"MAX_FILE_SIZE\"\r\n\r\n");
body.extend_from_slice(b"1048576\r\n");
⋮----
body.extend_from_slice(
⋮----
body.extend_from_slice(b"Content-Type: image/png\r\n\r\n");
body.extend_from_slice(&image_data);
body.extend_from_slice(b"\r\n");
body.extend_from_slice(format!("--{}--\r\n", boundary).as_bytes());
⋮----
.post("http://api.qrserver.com/v1/read-qr-code/")
.set(
⋮----
&format!("multipart/form-data; boundary={}", boundary),
⋮----
.send_bytes(&body)
.map_err(|e| anyhow::anyhow!("QR Server API Error: {}", e))?;
⋮----
.into_json()
.map_err(|e| anyhow::anyhow!("Failed to parse QR response: {}", e))?;
if let Some(first) = json.as_array().and_then(|a| a.first()) {
if let Some(symbols) = first.get("symbol").and_then(|s| s.as_array()) {
if let Some(first_symbol) = symbols.first() {
if let Some(data) = first_symbol.get("data").and_then(|d| d.as_str()) {
if !data.is_empty() {
full_content = data.to_string();
on_chunk(&full_content);
return Ok(full_content);
⋮----
if let Some(error) = first_symbol.get("error").and_then(|e| e.as_str()) {
if !error.is_empty() {
return Err(anyhow::anyhow!("QR_NOT_FOUND: {}", error));
⋮----
return Err(anyhow::anyhow!(
⋮----
if gemini_api_key.trim().is_empty() {
return Err(anyhow::anyhow!("NO_API_KEY:gemini"));
⋮----
format!(
⋮----
model.contains("gemini-flash-latest") || model.contains("gemini-robotics");
⋮----
if !model.contains("gemma-3-27b-it") {
⋮----
.post(&url)
.set("x-goog-api-key", gemini_api_key)
.send_json(payload)
.map_err(|e| {
let err_str = e.to_string();
if err_str.contains("401") || err_str.contains("403") {
⋮----
let reader = BufReader::new(resp.into_reader());
⋮----
.map(|app| app.config.ui_language.clone())
.unwrap_or_else(|| "en".to_string());
⋮----
for line in reader.lines() {
let line = line.map_err(|e| anyhow::anyhow!("Failed to read line: {}", e))?;
if line.starts_with("data: ") {
let json_str = &line["data: ".len()..];
if json_str.trim() == "[DONE]" {
⋮----
chunk_resp.get("candidates").and_then(|c| c.as_array())
⋮----
if let Some(first_candidate) = candidates.first() {
⋮----
.get("content")
.and_then(|c| c.get("parts"))
.and_then(|p| p.as_array())
⋮----
.get("thought")
.and_then(|t| t.as_bool())
.unwrap_or(false);
⋮----
part.get("text").and_then(|t| t.as_str())
⋮----
on_chunk(locale.model_thinking);
⋮----
full_content.push_str(text);
let wipe_content = format!(
⋮----
on_chunk(&wipe_content);
⋮----
on_chunk(text);
⋮----
.map_err(|e| anyhow::anyhow!("Failed to parse non-streaming response: {}", e))?;
if let Some(candidates) = chat_resp.get("candidates").and_then(|c| c.as_array()) {
if let Some(first_choice) = candidates.first() {
⋮----
.iter()
.filter(|p| {
!p.get("thought").and_then(|t| t.as_bool()).unwrap_or(false)
⋮----
.filter_map(|p| p.get("text").and_then(|t| t.as_str()))
⋮----
if openrouter_api_key.trim().is_empty() {
return Err(anyhow::anyhow!("NO_API_KEY:openrouter"));
⋮----
.post("https://openrouter.ai/api/v1/chat/completions")
.set("Authorization", &format!("Bearer {}", openrouter_api_key))
.set("Content-Type", "application/json")
⋮----
.get(0)
.and_then(|c| c.delta.reasoning.as_ref())
.filter(|s| !s.is_empty())
⋮----
.and_then(|c| c.delta.content.as_ref())
⋮----
full_content.push_str(content);
⋮----
format!("{}{}", crate::api::WIPE_SIGNAL, full_content);
⋮----
on_chunk(content);
⋮----
if let Some(choice) = chat_resp.choices.first() {
full_content = choice.message.content.clone();
⋮----
if groq_api_key.trim().is_empty() {
return Err(anyhow::anyhow!("NO_API_KEY:groq"));
⋮----
let resp = UREQ_AGENT.post("https://api.groq.com/openai/v1/chat/completions")
.set("Authorization", &format!("Bearer {}", groq_api_key))
⋮----
if err_str.contains("401") {
⋮----
} else if err_str.contains("400") {
⋮----
if let Some(remaining) = resp.header("x-ratelimit-remaining-requests") {
let limit = resp.header("x-ratelimit-limit-requests").unwrap_or("?");
let usage_str = format!("{} / {}", remaining, limit);
if let Ok(mut app) = APP.lock() {
app.model_usage_stats.insert(model.clone(), usage_str);
⋮----
chunk.choices.get(0).and_then(|c| c.delta.content.as_ref())
⋮----
json_obj.get("translation").and_then(|v| v.as_str())
⋮----
full_content = translation.to_string();
⋮----
full_content = content_str.clone();
⋮----
Ok(full_content)
</file>

<file path="src/config/config.rs">
fn default_true() -> bool {
⋮----
fn default_history_limit() -> usize {
⋮----
fn default_graphics_mode() -> String {
"standard".to_string()
⋮----
fn default_tts_voice() -> String {
"Aoede".to_string()
⋮----
fn default_tts_speed() -> String {
"Fast".to_string()
⋮----
fn default_tts_method() -> TtsMethod {
⋮----
fn default_edge_tts_settings() -> EdgeTtsSettings {
⋮----
fn default_realtime_translation_model() -> String {
"groq-llama".to_string()
⋮----
fn default_realtime_font_size() -> u32 {
⋮----
fn default_realtime_window_size() -> (i32, i32) {
⋮----
fn default_realtime_target_language() -> String {
"Vietnamese".to_string()
⋮----
fn default_ollama_base_url() -> String {
"http://localhost:11434".to_string()
⋮----
pub struct Config {
⋮----
impl Default for Config {
fn default() -> Self {
⋮----
presets: get_default_presets(),
⋮----
ui_language: get_system_ui_language(),
⋮----
graphics_mode: "standard".to_string(),
⋮----
ollama_base_url: "http://localhost:11434".to_string(),
⋮----
realtime_translation_model: "groq-llama".to_string(),
⋮----
realtime_audio_source: "device".to_string(),
realtime_target_language: "Vietnamese".to_string(),
⋮----
tts_voice: "Aoede".to_string(),
tts_speed: "Fast".to_string(),
⋮----
tts_language_conditions: default_tts_language_conditions(),
</file>

<file path="src/config/io.rs">
use std::path::PathBuf;
use crate::config::config::Config;
⋮----
pub fn get_config_path() -> PathBuf {
⋮----
.unwrap_or_default()
.join("screen-goated-toolbox");
⋮----
config_dir.join("config_v3.json")
⋮----
pub fn load_config() -> Config {
let path = get_config_path();
if !path.exists() {
⋮----
migrate_config(&mut config);
⋮----
fn migrate_config(config: &mut Config) {
let default_presets = get_default_presets();
⋮----
config.presets.iter().map(|p| p.id.clone()).collect();
⋮----
.iter()
.filter(|p| p.is_builtin() && !existing_ids.contains(&p.id))
.cloned()
.collect();
if !new_presets.is_empty() {
config.presets.extend(new_presets);
⋮----
if !preset.is_builtin() {
⋮----
if let Some(default_preset) = default_presets.iter().find(|p| p.id == preset.id) {
⋮----
if preset.blocks.is_empty() && !preset.is_master {
preset.blocks.push(ProcessingBlock {
block_type: preset.preset_type.clone(),
⋮----
pub fn save_config(config: &Config) {
⋮----
pub fn get_all_languages() -> &'static Vec<String> {
</file>

<file path="src/config/preset/block.rs">
use std::collections::HashMap;
use crate::config::types::BlockType;
⋮----
pub struct ProcessingBlock {
⋮----
fn generate_block_id() -> String {
format!(
⋮----
fn default_true() -> bool {
⋮----
fn default_render_mode() -> String {
"stream".to_string()
⋮----
impl Default for ProcessingBlock {
fn default() -> Self {
⋮----
id: generate_block_id(),
block_type: "text".to_string(),
model: "text_accurate_kimi".to_string(),
prompt: "Translate to {language1}. Output ONLY the translation.".to_string(),
selected_language: "Vietnamese".to_string(),
⋮----
render_mode: "stream".to_string(),
⋮----
pub struct BlockBuilder {
⋮----
impl BlockBuilder {
pub fn text(model: &str) -> Self {
⋮----
model: model.to_string(),
⋮----
pub fn image(model: &str) -> Self {
⋮----
block_type: "image".to_string(),
⋮----
pub fn audio(model: &str) -> Self {
⋮----
block_type: "audio".to_string(),
⋮----
pub fn input_adapter() -> Self {
⋮----
block_type: "input_adapter".to_string(),
⋮----
pub fn prompt(mut self, prompt: &str) -> Self {
self.block.prompt = prompt.to_string();
⋮----
pub fn language(mut self, lang: &str) -> Self {
self.block.selected_language = lang.to_string();
⋮----
.insert("language1".to_string(), lang.to_string());
⋮----
pub fn streaming(mut self, enabled: bool) -> Self {
⋮----
pub fn markdown(mut self) -> Self {
self.block.render_mode = "markdown".to_string();
⋮----
pub fn show_overlay(mut self, show: bool) -> Self {
⋮----
pub fn auto_copy(mut self) -> Self {
⋮----
pub fn auto_speak(mut self) -> Self {
⋮----
pub fn build(self) -> ProcessingBlock {
⋮----
impl ProcessingBlock {
pub fn is_input_adapter(&self) -> bool {
⋮----
pub fn is_image(&self) -> bool {
⋮----
pub fn is_text(&self) -> bool {
⋮----
pub fn is_audio(&self) -> bool {
⋮----
pub fn block_type_enum(&self) -> BlockType {
</file>

<file path="src/config/preset/defaults/master.rs">
use crate::config::preset::Preset;
use crate::config::preset::PresetBuilder;
pub fn create_master_presets() -> Vec<Preset> {
vec![
</file>

<file path="src/config/preset/mod.rs">
mod block;
pub mod defaults;
mod preset;
⋮----
pub use defaults::get_default_presets;
</file>

<file path="src/config/types/enums.rs">
pub enum ThemeMode {
⋮----
pub enum BlockType {
⋮----
impl BlockType {
pub fn from_str(s: &str) -> Self {
⋮----
pub fn get_system_ui_language() -> String {
let sys_locale = sys_locale::get_locale().unwrap_or_default();
let lang_code = sys_locale.split('-').next().unwrap_or("en").to_lowercase();
match lang_code.as_str() {
"vi" => "vi".to_string(),
"ko" => "ko".to_string(),
"ja" => "ja".to_string(),
"zh" => "zh".to_string(),
_ => "en".to_string(),
</file>

<file path="src/config/types/hotkey.rs">
pub struct Hotkey {
⋮----
impl Hotkey {
pub fn new(code: u32, name: &str, modifiers: u32) -> Self {
⋮----
name: name.to_string(),
</file>

<file path="src/config/types/mod.rs">
mod enums;
mod hotkey;
mod tts;
⋮----
pub use hotkey::Hotkey;
</file>

<file path="src/config/types/tts.rs">
pub enum TtsMethod {
⋮----
pub struct EdgeTtsVoiceConfig {
⋮----
impl EdgeTtsVoiceConfig {
pub fn new(language_code: &str, language_name: &str, voice_name: &str) -> Self {
⋮----
language_code: language_code.to_string(),
language_name: language_name.to_string(),
voice_name: voice_name.to_string(),
⋮----
pub struct EdgeTtsSettings {
⋮----
impl Default for EdgeTtsSettings {
fn default() -> Self {
⋮----
voice_configs: default_edge_tts_voice_configs(),
⋮----
pub fn default_edge_tts_voice_configs() -> Vec<EdgeTtsVoiceConfig> {
vec![
⋮----
pub struct TtsLanguageCondition {
⋮----
impl TtsLanguageCondition {
pub fn new(language_code: &str, language_name: &str, instruction: &str) -> Self {
⋮----
instruction: instruction.to_string(),
⋮----
pub fn default_tts_language_conditions() -> Vec<TtsLanguageCondition> {
vec![TtsLanguageCondition::new(
</file>

<file path="src/gui/app/logic.rs">
use crate::gui::app::utils::simple_rand;
⋮----
use crate::gui::locale::LocaleText;
use crate::icon_gen;
⋮----
use eframe::egui;
use std::sync::atomic::Ordering;
⋮----
use windows::Win32::Foundation::POINT;
⋮----
use windows::Win32::UI::WindowsAndMessaging::GetCursorPos;
impl SettingsApp {
pub(crate) fn check_updater(&mut self) {
while let Ok(status) = self.update_rx.try_recv() {
⋮----
pub(crate) fn update_theme_and_tray(&mut self, ctx: &egui::Context) {
let now = ctx.input(|i| i.time);
⋮----
ctx.set_visuals(egui::Visuals::dark());
⋮----
ctx.set_visuals(egui::Visuals::light());
⋮----
let _ = tray.set_icon(Some(new_icon));
⋮----
self.last_ui_language = self.config.ui_language.clone();
⋮----
self.tray_settings_item.set_text(new_locale.tray_settings);
self.tray_quit_item.set_text(new_locale.tray_quit);
⋮----
if self.tray_icon.is_none() {
⋮----
ctx.send_viewport_cmd(egui::ViewportCommand::Visible(true));
⋮----
.with_tooltip("Screen Goated Toolbox (nganlinh4)")
.with_icon(icon)
.build()
⋮----
self.tray_icon = Some(tray);
⋮----
ctx.request_repaint_after(std::time::Duration::from_secs(1));
⋮----
pub(crate) fn update_startup(&mut self, ctx: &egui::Context) {
⋮----
let _ = GetCursorPos(&mut cursor_pos);
let h_monitor = MonitorFromPoint(cursor_pos, MONITOR_DEFAULTTONEAREST);
⋮----
let _ = GetMonitorInfoW(h_monitor, &mut mi);
⋮----
let pixels_per_point = ctx.pixels_per_point();
⋮----
ctx.send_viewport_cmd(egui::ViewportCommand::OuterPosition(egui::pos2(
⋮----
ctx.send_viewport_cmd(egui::ViewportCommand::InnerSize(egui::vec2(
⋮----
ctx.request_repaint();
⋮----
splash.reset_timer(ctx);
⋮----
let should_be_visible = !self.config.start_in_tray || self.tray_icon.is_none();
ctx.send_viewport_cmd(egui::ViewportCommand::Visible(should_be_visible));
⋮----
let has_favorites = self.config.presets.iter().any(|p| p.is_favorite);
⋮----
pub(crate) fn update_bubble_sync(&mut self) {
let current_has_favorites = self.config.presets.iter().any(|p| p.is_favorite);
⋮----
.set_enabled(current_has_favorites);
⋮----
pub(crate) fn update_splash(&mut self, ctx: &egui::Context) {
⋮----
match splash.update(ctx) {
⋮----
pub(crate) fn check_restore_signal(&mut self, ctx: &egui::Context) {
if RESTORE_SIGNAL.swap(false, Ordering::SeqCst) {
self.restore_window(ctx);
⋮----
pub(crate) fn update_tips_logic(&mut self, ctx: &egui::Context) {
⋮----
.get(self.current_tip_idx)
.unwrap_or(&"")
.to_string();
let display_duration = (2.0 + (current_tip.len() as f64 * 0.06)) as f32;
⋮----
// Fading In
self.tip_fade_state = (elapsed / fade_duration as f32).min(1.0);
⋮----
// Fully visible, wait for duration
⋮----
self.tip_is_fading_in = false; // Start fading out
self.tip_timer = now; // Reset timer for fade-out
⋮----
// Fading Out
self.tip_fade_state = (1.0 - (elapsed / fade_duration as f32)).max(0.0);
⋮----
// Switch to next random tip
self.rng_seed = simple_rand(self.rng_seed);
if !text.tips_list.is_empty() {
let next = (self.rng_seed as usize) % text.tips_list.len();
// Avoid repeating same tip if possible
if next == self.current_tip_idx && text.tips_list.len() > 1 {
self.current_tip_idx = (next + 1) % text.tips_list.len();
⋮----
self.tip_timer = now; // Reset timer
self.tip_is_fading_in = true; // Start fading in
⋮----
pub(crate) fn update_hotkey_recording(&mut self, ctx: &egui::Context) {
⋮----
ctx.input(|i| {
if i.key_pressed(egui::Key::Escape) {
⋮----
// Check Keyboard Events
⋮----
if let Some(vk) = egui_key_to_vk(key) {
if !matches!(vk, 16 | 17 | 18 | 91 | 92) {
⋮----
format!("{:?}", key).trim_start_matches("Key").to_string();
key_recorded = Some((vk, modifiers_bitmap, key_name));
⋮----
if key_recorded.is_none() {
⋮----
if i.pointer.button_pressed(btn) {
if let Some(vk) = egui_pointer_to_vk(&btn) {
⋮----
key_recorded = Some((vk, modifiers_bitmap, name));
⋮----
if let Some(msg) = self.check_hotkey_conflict(vk, mods, preset_idx) {
self.hotkey_conflict_msg = Some(msg);
⋮----
name_parts.push("Ctrl".to_string());
⋮----
name_parts.push("Alt".to_string());
⋮----
name_parts.push("Shift".to_string());
⋮----
name_parts.push("Win".to_string());
⋮----
name_parts.push(key_name);
⋮----
name: name_parts.join(" + "),
⋮----
if let Some(preset) = self.config.presets.get_mut(preset_idx) {
⋮----
.iter()
.any(|h| h.code == vk && h.modifiers == mods)
⋮----
preset.hotkeys.push(new_hotkey);
self.save_and_sync();
⋮----
pub(crate) fn handle_events(&mut self, ctx: &egui::Context) {
while let Ok(event) = self.event_rx.try_recv() {
⋮----
match menu_event.id.0.as_str() {
⋮----
.set_checked(self.config.show_favorite_bubble);
⋮----
pub(crate) fn handle_close_request(&mut self, ctx: &egui::Context) {
if ctx.input(|i| i.viewport().close_requested()) {
⋮----
ctx.send_viewport_cmd(egui::ViewportCommand::CancelClose);
ctx.send_viewport_cmd(egui::ViewportCommand::Visible(false));
</file>

<file path="src/gui/settings_ui/footer.rs">
use eframe::egui;
use crate::gui::locale::LocaleText;
⋮----
pub fn render_footer(
⋮----
ui.horizontal(|ui| {
ui.allocate_ui(egui::vec2(180.0, ui.available_height()), |ui| {
ui.horizontal_centered(|ui| {
let is_admin = cfg!(target_os = "windows") && crate::gui::utils::is_running_as_admin();
⋮----
.size(11.0)
.color(egui::Color32::from_rgb(34, 139, 34))
⋮----
.color(ui.visuals().weak_text_color())
⋮----
ui.label(footer_text);
⋮----
let version_text = format!("{} v{}", text.footer_version, env!("CARGO_PKG_VERSION"));
let version_galley = ui.painter().layout_no_wrap(
version_text.clone(),
⋮----
ui.visuals().weak_text_color()
⋮----
let version_width = version_galley.rect.width() + 10.0;
let available_w = ui.available_width() - version_width;
ui.allocate_ui(egui::vec2(available_w, ui.available_height()), |ui| {
ui.vertical_centered(|ui| {
let tip_color = ui.visuals().text_color().linear_multiply(tip_alpha);
⋮----
let is_dark_mode = ui.visuals().dark_mode;
let layout_job = format_footer_tip(&current_tip, tip_color, is_dark_mode, tip_alpha);
let text_galley = ui.painter().layout_job(layout_job);
let total_width = icon_size + icon_spacing + text_galley.rect.width();
let (response, painter) = ui.allocate_painter(
egui::vec2(total_width + 8.0, ui.available_height().max(18.0)),
⋮----
egui::pos2(rect.left(), rect.center().y - icon_size / 2.0),
⋮----
paint_icon(&painter, icon_rect, Icon::Lightbulb, icon_color);
⋮----
icon_rect.right() + icon_spacing,
rect.center().y - text_galley.rect.height() / 2.0
⋮----
painter.galley(text_pos, text_galley, egui::Color32::WHITE);
if response.on_hover_text(text.tips_click_hint).clicked() {
⋮----
ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
ui.label(egui::RichText::new(version_text).size(11.0).color(ui.visuals().weak_text_color()));
⋮----
fn format_footer_tip(text: &str, base_color: egui::Color32, is_dark_mode: bool, alpha_factor: f32) -> LayoutJob {
⋮----
base_color.r(),
base_color.g(),
base_color.b(),
(base_color.a() as f32 * alpha_factor) as u8,
⋮----
bold_color.r(),
bold_color.g(),
bold_color.b(),
⋮----
let mut chars = text.chars().peekable();
⋮----
while let Some(ch) = chars.next() {
if ch == '*' && chars.peek() == Some(&'*') {
chars.next();
if !current_text.is_empty() {
let mut fmt = text_format.clone();
⋮----
job.append(&current_text, 0.0, fmt);
current_text.clear();
⋮----
current_text.push(ch);
</file>

<file path="src/gui/settings_ui/global/mod.rs">
use super::node_graph::request_node_graph_view_reset;
use crate::config::Config;
⋮----
use crate::gui::locale::LocaleText;
⋮----
use auto_launch::AutoLaunch;
use eframe::egui;
use std::collections::HashMap;
mod tts_settings;
mod update_section;
mod usage_stats;
use tts_settings::render_tts_settings_modal;
use update_section::render_update_section_content;
use usage_stats::render_usage_modal;
⋮----
pub fn render_global_settings(
⋮----
let is_dark = ui.visuals().dark_mode;
⋮----
ui.add_space(5.0);
⋮----
.fill(card_bg)
.stroke(card_stroke)
.inner_margin(12.0)
.corner_radius(10.0)
.show(ui, |ui| {
ui.horizontal(|ui| {
ui.label(
⋮----
.strong()
.size(14.0),
⋮----
ui.add_space(16.0);
⋮----
.checkbox(&mut config.use_groq, text.use_groq_checkbox)
.changed()
⋮----
.checkbox(&mut config.use_gemini, text.use_gemini_checkbox)
⋮----
.checkbox(&mut config.use_openrouter, text.use_openrouter_checkbox)
⋮----
if ui.checkbox(&mut config.use_ollama, "Ollama").changed() {
⋮----
ui.add_space(6.0);
⋮----
ui.label(text.groq_label);
if ui.link(text.get_key_link).clicked() {
⋮----
.add(
⋮----
.password(!*show_api_key)
.desired_width(API_KEY_FIELD_WIDTH),
⋮----
if icon_button(ui, eye_icon).clicked() {
⋮----
ui.add_space(8.0);
⋮----
ui.label(text.gemini_api_key_label);
if ui.link(text.gemini_get_key_link).clicked() {
⋮----
.password(!*show_gemini_api_key)
⋮----
ui.label(text.openrouter_api_key_label);
if ui.link(text.openrouter_get_key_link).clicked() {
⋮----
.password(!*show_openrouter_api_key)
⋮----
ui.label("Ollama URL:");
if ui.link(text.ollama_url_guide).clicked() {
⋮----
.ctx()
.memory(|mem| mem.data.get_temp::<String>(egui::Id::new("ollama_status")))
⋮----
ui.label(egui::RichText::new(&status).size(11.0));
⋮----
ui.add_space(10.0);
⋮----
egui::RichText::new(format!("📊 {}", text.usage_statistics_title))
.color(egui::Color32::WHITE)
.strong(),
⋮----
.fill(stats_bg)
.corner_radius(10.0),
⋮----
.on_hover_cursor(egui::CursorIcon::PointingHand)
.on_hover_text(text.usage_statistics_tooltip)
.clicked()
⋮----
egui::RichText::new(format!("🔊 {}", text.tts_settings_button))
⋮----
.fill(tts_bg)
⋮----
render_usage_modal(
⋮----
if render_tts_settings_modal(ui, config, text, show_tts_modal) {
⋮----
render_update_section_content(ui, updater, update_status, text);
⋮----
.checkbox(&mut startup_toggle, text.startup_label)
⋮----
let _ = launcher.disable();
⋮----
let _ = launcher.enable();
⋮----
ui.indent("admin_indent", |ui| {
⋮----
if ui.checkbox(&mut is_admin_mode, checkbox_label).clicked() {
⋮----
ui.add_enabled_ui(false, |ui| {
ui.checkbox(&mut _is_admin_mode_disabled, checkbox_label);
⋮----
.size(11.0)
.color(egui::Color32::from_rgb(200, 100, 50)),
⋮----
.color(egui::Color32::from_rgb(34, 139, 34)),
⋮----
.checkbox(&mut config.start_in_tray, text.start_in_tray_label)
⋮----
ui.label(text.graphics_mode_label);
let current_label = match config.ui_language.as_str() {
⋮----
.selected_text(current_label)
.show_ui(ui, |ui| {
⋮----
.selectable_label(
⋮----
config.graphics_mode = "standard".to_string();
⋮----
config.graphics_mode = "minimal".to_string();
⋮----
ui.add_space(80.0);
⋮----
.color(egui::Color32::WHITE),
⋮----
.fill(reset_bg)
.corner_radius(8.0),
⋮----
let saved_groq_key = config.api_key.clone();
let saved_gemini_key = config.gemini_api_key.clone();
let saved_openrouter_key = config.openrouter_api_key.clone();
let saved_language = config.ui_language.clone();
⋮----
let saved_ollama_base_url = config.ollama_base_url.clone();
⋮----
request_node_graph_view_reset(ui.ctx());
</file>

<file path="src/gui/settings_ui/global/tts_settings.rs">
use eframe::egui;
⋮----
use crate::gui::locale::LocaleText;
⋮----
pub fn render_tts_settings_modal(
⋮----
let male_voices: Vec<_> = VOICES.iter().filter(|(_, g)| *g == "Male").collect();
let female_voices: Vec<_> = VOICES.iter().filter(|(_, g)| *g == "Female").collect();
egui::Window::new(format!("🔊 {}", text.tts_settings_title))
.collapsible(false)
.resizable(false)
.title_bar(false)
.default_width(650.0)
.default_height(600.0)
.anchor(egui::Align2::CENTER_CENTER, egui::vec2(0.0, 0.0))
.show(ui.ctx(), |ui| {
ui.set_min_height(500.0);
ui.horizontal(|ui| {
ui.label(egui::RichText::new(format!("🔊 {}", text.tts_settings_title)).strong().size(14.0));
ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
if icon_button(ui, Icon::Close).clicked() {
⋮----
ui.separator();
ui.add_space(8.0);
⋮----
ui.label(egui::RichText::new(text.tts_method_label).strong());
if ui.radio_value(&mut config.tts_method, TtsMethod::GeminiLive, text.tts_method_standard).clicked() {
⋮----
if ui.radio_value(&mut config.tts_method, TtsMethod::EdgeTTS, text.tts_method_edge).clicked() {
⋮----
if ui.radio_value(&mut config.tts_method, TtsMethod::GoogleTranslate, text.tts_method_fast).clicked() {
⋮----
config.tts_speed = "Normal".to_string();
⋮----
ui.add_space(10.0);
⋮----
ui.columns(2, |columns| {
columns[0].label(egui::RichText::new(text.tts_speed_label).strong());
columns[0].horizontal(|ui| {
if ui.radio_value(&mut config.tts_speed, "Slow".to_string(), text.tts_speed_slow).clicked() { changed = true; }
if ui.radio_value(&mut config.tts_speed, "Normal".to_string(), text.tts_speed_normal).clicked() { changed = true; }
if ui.radio_value(&mut config.tts_speed, "Fast".to_string(), text.tts_speed_fast).clicked() { changed = true; }
⋮----
columns[1].label(egui::RichText::new(text.tts_instructions_label).strong());
⋮----
for (idx, condition) in config.tts_language_conditions.iter_mut().enumerate() {
columns[1].horizontal(|ui| {
let display_name = supported_languages.iter()
.find(|(code, _)| code.eq_ignore_ascii_case(&condition.language_code))
.map(|(_, name)| *name)
.unwrap_or(&condition.language_name);
ui.label(egui::RichText::new(display_name).strong().color(egui::Color32::from_rgb(100, 180, 100)));
ui.label("→");
if ui.add(
⋮----
.desired_width(180.0)
.hint_text(text.tts_instructions_hint)
).changed() {
⋮----
if icon_button(ui, Icon::Close).on_hover_text("Remove").clicked() {
to_remove = Some(idx);
⋮----
config.tts_language_conditions.remove(idx);
⋮----
let used_codes: Vec<_> = config.tts_language_conditions.iter()
.map(|c| c.language_code.as_str())
.collect();
let available: Vec<_> = supported_languages.iter()
.filter(|(code, _)| !used_codes.contains(code))
⋮----
if !available.is_empty() {
⋮----
.selected_text(text.tts_add_condition)
.width(140.0)
.show_ui(ui, |ui| {
⋮----
if ui.selectable_label(false, *name).clicked() {
config.tts_language_conditions.push(crate::config::TtsLanguageCondition {
language_code: code.to_string(),
language_name: name.to_string(),
⋮----
ui.columns(4, |columns| {
⋮----
use std::collections::hash_map::RandomState;
⋮----
if ui.radio(is_selected, "").clicked() {
config.tts_voice = name.to_string();
⋮----
if ui.button("🔊").on_hover_text("Preview").clicked() {
⋮----
if !text.tts_preview_texts.is_empty() {
⋮----
let mut hasher = s.build_hasher();
hasher.write_usize(SystemTime::now().duration_since(UNIX_EPOCH).unwrap_or_default().subsec_nanos() as usize);
let rand_val = hasher.finish();
let len = text.tts_preview_texts.len();
⋮----
let last = LAST_PREVIEW_IDX.load(Ordering::Relaxed);
⋮----
LAST_PREVIEW_IDX.store(idx, Ordering::Relaxed);
let preview_text = text.tts_preview_texts[idx].replace("{}", name);
crate::api::tts::TTS_MANAGER.speak_interrupt(&preview_text, 0);
⋮----
let preview_text = format!("Hello, I am {}. This is a voice preview.", name);
⋮----
ui.label(egui::RichText::new(name).strong());
⋮----
let male_mid = (male_voices.len() + 1) / 2;
let male_col1: Vec<_> = male_voices.iter().take(male_mid).collect();
let male_col2: Vec<_> = male_voices.iter().skip(male_mid).collect();
let female_mid = (female_voices.len() + 1) / 2;
let female_col1: Vec<_> = female_voices.iter().take(female_mid).collect();
let female_col2: Vec<_> = female_voices.iter().skip(female_mid).collect();
columns[0].vertical(|ui| {
ui.label(egui::RichText::new(text.tts_male).strong().underline());
ui.add_space(4.0);
⋮----
render_voice(ui, name, config, text, &mut changed);
⋮----
columns[1].vertical(|ui| {
ui.label(egui::RichText::new("").strong()); // Empty header for alignment
⋮----
// Column 2: Female (first half)
columns[2].vertical(|ui| {
ui.label(egui::RichText::new(text.tts_female).strong().underline());
⋮----
// Column 3: Female (second half)
columns[3].vertical(|ui| {
⋮----
// Simplified UI for Google Translate
ui.vertical_centered(|ui| {
ui.add_space(20.0);
ui.label(egui::RichText::new(text.tts_google_translate_title).size(18.0).strong());
⋮----
ui.label(text.tts_google_translate_desc);
⋮----
ui.label(egui::RichText::new(text.tts_speed_label).strong());
⋮----
ui.label(egui::RichText::new(text.tts_edge_title).size(18.0).strong());
ui.add_space(5.0);
ui.label(text.tts_edge_desc);
ui.add_space(15.0);
⋮----
ui.label(egui::RichText::new(text.tts_pitch_label).strong());
if ui.add(egui::Slider::new(&mut config.edge_tts_settings.pitch, -50..=50).suffix(" Hz")).changed() {
⋮----
ui.label(egui::RichText::new(text.tts_rate_label).strong());
if ui.add(egui::Slider::new(&mut config.edge_tts_settings.rate, -50..=100).suffix("%")).changed() {
⋮----
ui.label(egui::RichText::new(text.tts_voice_per_language_label).strong());
⋮----
let cache = crate::api::tts::edge_voices::EDGE_VOICE_CACHE.lock().unwrap();
(cache.loaded, cache.loading, cache.error.clone())
⋮----
ui.spinner();
ui.label(text.tts_loading_voices);
⋮----
ui.colored_label(egui::Color32::RED, format!("{} {}", text.tts_failed_load_voices, error).replace("{}", ""));
if ui.button(text.tts_retry_label).clicked() {
// Reset cache and retry
let mut cache = crate::api::tts::edge_voices::EDGE_VOICE_CACHE.lock().unwrap();
⋮----
// Loaded - show voice configuration
egui::ScrollArea::vertical().max_height(180.0).show(ui, |ui| {
⋮----
for (idx, voice_config) in config.edge_tts_settings.voice_configs.iter_mut().enumerate() {
⋮----
// Language name (read-only)
ui.label(egui::RichText::new(&voice_config.language_name).strong().color(egui::Color32::from_rgb(100, 180, 100)));
⋮----
// Voice dropdown for this language
⋮----
egui::ComboBox::from_id_salt(format!("edge_voice_{}", idx))
.selected_text(&voice_config.voice_name)
.width(220.0)
⋮----
let display = format!("{} ({})", voice.short_name, voice.gender);
if ui.selectable_label(voice_config.voice_name == voice.short_name, &display).clicked() {
voice_config.voice_name = voice.short_name.clone();
⋮----
// Remove button
⋮----
config.edge_tts_settings.voice_configs.remove(idx);
⋮----
let used_codes: Vec<_> = config.edge_tts_settings.voice_configs.iter()
⋮----
let available: Vec<_> = available_langs.iter()
.filter(|(code, _)| !used_codes.contains(&code.as_str()))
⋮----
.selected_text(text.tts_add_language_label)
.width(150.0)
⋮----
if ui.selectable_label(false, name).clicked() {
⋮----
let default_voice = voices.first()
.map(|v| v.short_name.clone())
.unwrap_or_else(|| format!("{}-??-??Neural", code));
config.edge_tts_settings.voice_configs.push(
⋮----
language_code: code.clone(),
language_name: name.clone(),
⋮----
if ui.button(text.tts_reset_to_defaults_label).clicked() {
⋮----
ui.label(text.tts_initializing_voices);
</file>

<file path="src/gui/settings_ui/global/usage_stats.rs">
use eframe::egui;
use crate::gui::locale::LocaleText;
⋮----
use std::collections::HashMap;
pub fn render_usage_modal(
⋮----
egui::Window::new(format!("📊 {}", text.usage_statistics_title))
.collapsible(false)
.resizable(false)
.title_bar(false)
.default_width(400.0)
.anchor(egui::Align2::CENTER_CENTER, egui::vec2(0.0, 0.0))
.show(ui.ctx(), |ui| {
ui.horizontal(|ui| {
ui.label(egui::RichText::new(format!("📊 {}", text.usage_statistics_title)).strong().size(14.0));
ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
if icon_button(ui, Icon::Close).clicked() {
⋮----
ui.separator();
ui.add_space(4.0);
⋮----
get_all_models_with_ollama()
⋮----
get_all_models().to_vec()
⋮----
.max_height(450.0)
.auto_shrink([false, false])
.show(ui, |ui| {
ui.set_width(ui.available_width());
⋮----
egui::CollapsingHeader::new(egui::RichText::new("⚡ Groq").strong().size(13.0))
.default_open(true)
⋮----
egui::Grid::new("groq_grid").striped(true).show(ui, |ui| {
ui.label(egui::RichText::new(text.usage_model_column).strong().size(11.0));
ui.label(egui::RichText::new(text.usage_remaining_column).strong().size(11.0));
ui.end_row();
⋮----
if shown_models.contains(&model.full_name) { continue; }
shown_models.insert(model.full_name.clone());
ui.label(&model.full_name);
let status = usage_stats.get(&model.full_name).cloned().unwrap_or_else(|| "??? / ?".to_string());
ui.label(status);
⋮----
if !shown_models.contains("llama-3.1-8b-instant") {
shown_models.insert("llama-3.1-8b-instant".to_string());
ui.label("llama-3.1-8b-instant");
let status = usage_stats.get("llama-3.1-8b-instant").cloned().unwrap_or_else(|| "??? / ?".to_string());
⋮----
egui::CollapsingHeader::new(egui::RichText::new("✨ Google Gemini").strong().size(13.0))
⋮----
ui.add_space(120.0);
ui.hyperlink_to(text.usage_check_link, "https://aistudio.google.com/usage?timeRange=last-1-day&tab=rate-limit");
⋮----
egui::CollapsingHeader::new(egui::RichText::new("🌐 OpenRouter").strong().size(13.0))
⋮----
ui.hyperlink_to(text.usage_check_link, "https://openrouter.ai/activity");
⋮----
egui::CollapsingHeader::new(egui::RichText::new("🏠 Ollama (Local)").strong().size(13.0))
⋮----
ui.label("∞ Unlimited");
</file>

<file path="src/gui/settings_ui/history.rs">
use crate::config::Config;
⋮----
use crate::gui::locale::LocaleText;
⋮----
use eframe::egui;
pub fn render_history_panel(
⋮----
let is_dark = ui.visuals().dark_mode;
⋮----
ui.set_max_width(510.0);
ui.add_space(5.0);
⋮----
.fill(card_bg)
.stroke(card_stroke)
.inner_margin(12.0)
.corner_radius(10.0)
.show(ui, |ui| {
ui.horizontal(|ui| {
ui.label(
egui::RichText::new(format!("📜 {}", text.history_title))
.strong()
.size(14.0),
⋮----
ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
⋮----
.add(egui::Slider::new(&mut config.max_history_items, 10..=200))
.changed()
⋮----
history_manager.request_prune(config.max_history_items);
⋮----
ui.label(text.max_items_label);
⋮----
ui.add_space(8.0);
⋮----
ui.add(
⋮----
.hint_text(text.search_placeholder)
.desired_width(220.0),
⋮----
if !search_query.is_empty() {
if icon_button(ui, Icon::Close)
.on_hover_text("Clear search")
.clicked()
⋮----
*search_query = "".to_string();
⋮----
if icon_button(ui, Icon::Folder)
.on_hover_text("Open Media Folder")
⋮----
.unwrap_or_default()
.join("screen-goated-toolbox")
.join("history_media");
⋮----
.add(
⋮----
.color(egui::Color32::WHITE)
.small(),
⋮----
.fill(clear_bg)
.corner_radius(8.0),
⋮----
history_manager.clear_all();
⋮----
let items = history_manager.items.lock().unwrap().clone();
let q = search_query.to_lowercase();
⋮----
.iter()
.filter(|i| q.is_empty() || i.text.to_lowercase().contains(&q) || i.timestamp.contains(&q))
.collect();
if filtered.is_empty() {
ui.centered_and_justified(|ui| {
ui.label(text.history_empty);
⋮----
egui::Frame::new().show(ui, |ui| {
ui.set_height(460.0);
egui::ScrollArea::vertical().show(ui, |ui| {
⋮----
.fill(item_bg)
⋮----
.inner_margin(8.0)
.corner_radius(8.0)
⋮----
draw_icon_static(ui, icon, Some(14.0));
ui.label(egui::RichText::new(&item.timestamp).size(10.0).weak());
ui.with_layout(
⋮----
if icon_button(ui, Icon::DeleteLarge)
.on_hover_text("Delete")
⋮----
id_to_delete = Some(item.id);
⋮----
if icon_button(ui, Icon::Copy)
.on_hover_text("Copy Text")
⋮----
if !item.media_path.is_empty() {
⋮----
if ui.button(btn_text).clicked() {
⋮----
.unwrap()
⋮----
let path = config_dir.join(&item.media_path);
⋮----
ui.label(egui::RichText::new(&item.text).size(13.0));
⋮----
ui.add_space(4.0);
⋮----
history_manager.delete(id);
</file>

<file path="src/gui/settings_ui/node_graph/mod.rs">
pub mod body;
pub mod conversion;
pub mod node;
pub mod utils;
pub mod viewer;
⋮----
pub use node::ChainNode;
pub use utils::request_node_graph_view_reset;
pub use viewer::ChainViewer;
use crate::gui::locale::LocaleText;
use eframe::egui;
use egui_snarl::ui::SnarlStyle;
⋮----
use std::collections::HashMap;
pub fn render_node_graph(
⋮----
snarl.show(&mut viewer, &style, egui::Id::new("chain_graph"), ui);
⋮----
for (out, inp) in snarl.wires() {
⋮----
to_disconnect.push((out, inp));
⋮----
input_count.entry(inp).or_default().push(out);
⋮----
if sources.len() > 1 {
for &src in sources.iter().take(sources.len() - 1) {
to_disconnect.push((src, _inp));
⋮----
snarl.disconnect(out, inp);
</file>

<file path="src/gui/settings_ui/node_graph/viewer.rs">
use super::body::show_body;
use super::node::ChainNode;
⋮----
use crate::gui::locale::LocaleText;
use eframe::egui;
⋮----
pub struct ChainViewer<'a> {
⋮----
pub fn new(
⋮----
ui_language: ui_language.to_string(),
⋮----
preset_type: preset_type.to_string(),
⋮----
/// Check if a model's provider is enabled
    pub fn is_provider_enabled(&self, provider: &str) -> bool {
⋮----
pub fn is_provider_enabled(&self, provider: &str) -> bool {
⋮----
fn title(&mut self, node: &ChainNode) -> String {
⋮----
self.preset_type.as_str()
⋮----
block_type.as_str()
⋮----
format!("{} {}", prefix, type_name)
⋮----
match self.preset_type.as_str() {
"image" => self.text.node_special_image_to_text.to_string(),
"audio" => self.text.node_special_audio_to_text.to_string(),
_ => self.text.node_special_default.to_string(),
⋮----
ChainNode::Process { .. } => self.text.node_process_title.to_string(),
⋮----
fn show_header(
⋮----
ui.horizontal(|ui| {
⋮----
draw_icon_static(ui, icon, Some(16.0));
⋮----
ui.label(format!("{} {}", prefix, type_name));
⋮----
draw_icon_static(ui, Icon::Settings, Some(16.0));
⋮----
ui.label(title);
⋮----
let title = match self.preset_type.as_str() {
⋮----
ui.label(
egui::RichText::new(title).color(egui::Color32::from_rgb(255, 200, 100)),
⋮----
fn inputs(&mut self, node: &ChainNode) -> usize {
⋮----
fn outputs(&mut self, _node: &ChainNode) -> usize {
⋮----
fn show_input(
⋮----
// Green color for text connections
PinInfo::circle().with_fill(egui::Color32::from_rgb(100, 200, 100))
⋮----
fn show_output(
⋮----
PinInfo::circle().with_fill(egui::Color32::from_rgb(100, 150, 255))
⋮----
fn has_body(&mut self, _node: &ChainNode) -> bool {
⋮----
fn show_body(
⋮----
show_body(self, node_id, ui, snarl);
⋮----
fn has_graph_menu(&mut self, _pos: egui::Pos2, _snarl: &mut Snarl<ChainNode>) -> bool {
⋮----
fn show_graph_menu(
⋮----
let add_special_label = match self.preset_type.as_str() {
⋮----
if ui.button(add_process_label).clicked() {
snarl.insert_node(pos, ChainNode::default());
⋮----
ui.close();
⋮----
if ui.button(add_special_label).clicked() {
⋮----
snarl.insert_node(pos, node);
⋮----
fn has_node_menu(&mut self, node: &ChainNode) -> bool {
!node.is_input()
⋮----
fn show_node_menu(
⋮----
let delete_label = match self.ui_language.as_str() {
⋮----
if ui.button(delete_label).clicked() {
snarl.remove_node(node_id);
⋮----
fn connect(&mut self, from: &OutPin, to: &InPin, snarl: &mut Snarl<ChainNode>) {
let to_node = snarl.get_node(to.id.node);
let from_node = snarl.get_node(from.id.node);
⋮----
if to_node.is_special() {
if !from_node.is_input() {
⋮----
snarl.connect(from.id, to.id);
⋮----
fn disconnect(&mut self, from: &OutPin, to: &InPin, snarl: &mut Snarl<ChainNode>) {
snarl.disconnect(from.id, to.id);
</file>

<file path="src/gui/splash.rs">
use eframe::egui;
⋮----
use std::f32::consts::PI;
use std::cmp::Ordering;
⋮----
fn smoothstep(edge0: f32, edge1: f32, x: f32) -> f32 {
let t = ((x - edge0) / (edge1 - edge0)).clamp(0.0, 1.0);
⋮----
fn lerp(a: f32, b: f32, t: f32) -> f32 {
⋮----
struct Vec3 { x: f32, y: f32, z: f32 }
impl Vec3 {
⋮----
fn new(x: f32, y: f32, z: f32) -> Self { Self { x, y, z } }
fn add(self, v: Vec3) -> Self { Self::new(self.x + v.x, self.y + v.y, self.z + v.z) }
fn sub(self, v: Vec3) -> Self { Self::new(self.x - v.x, self.y - v.y, self.z - v.z) }
fn mul(self, s: f32) -> Self { Self::new(self.x * s, self.y * s, self.z * s) }
fn len(self) -> f32 { (self.x*self.x + self.y*self.y + self.z*self.z).sqrt() }
fn normalize(self) -> Self {
let l = self.len();
if l == 0.0 { Self::ZERO } else { self.mul(1.0/l) }
⋮----
fn lerp(self, target: Vec3, t: f32) -> Self {
⋮----
lerp(self.x, target.x, t),
lerp(self.y, target.y, t),
lerp(self.z, target.z, t)
⋮----
fn rotate_x(self, angle: f32) -> Self {
let (s, c) = angle.sin_cos();
⋮----
fn rotate_y(self, angle: f32) -> Self {
⋮----
fn rotate_z(self, angle: f32) -> Self {
⋮----
struct Cloud {
⋮----
struct Star {
⋮----
struct MoonFeature {
⋮----
struct Voxel {
⋮----
pub struct SplashScreen {
⋮----
pub enum SplashStatus {
⋮----
impl SplashScreen {
pub fn new(ctx: &egui::Context) -> Self {
let is_dark = ctx.style().visuals.dark_mode;
⋮----
start_time: ctx.input(|i| i.time),
⋮----
loading_text: "TRANSLATING...".to_string(),
⋮----
pub fn reset_timer(&mut self, ctx: &egui::Context) {
self.start_time = ctx.input(|i| i.time);
⋮----
fn init_scene(&mut self) {
⋮----
rng_state = rng_state.wrapping_mul(6364136223846793005).wrapping_add(1);
⋮----
for (y, row) in map.iter().enumerate() {
for (x, ch) in row.chars().enumerate() {
⋮----
self.voxels.push(Voxel {
⋮----
rot: Vec3::new(rng() * 6.0, rng() * 6.0, rng() * 6.0),
⋮----
color: if rng() > 0.85 { C_WHITE } else { color_theme },
noise_factor: rng(),
⋮----
spawn_letter(&s_map, -120.0, c_secondary);
spawn_letter(&g_map, -35.0, c_primary);
spawn_letter(&t_map, 50.0, c_secondary);
⋮----
let h_y = (rng() * 300.0) - 150.0;
let h_radius = 80.0 + rng() * 60.0;
let h_angle = rng() * PI * 2.0;
let target = Vec3::new(h_angle.cos(), 0.0, h_angle.sin()).mul(800.0);
⋮----
rot: Vec3::new(rng(), rng(), rng()),
⋮----
self.stars.push(Star {
pos: Vec2::new(rng(), rng() * 0.85),
phase: rng() * PI * 2.0,
brightness: 0.3 + rng() * 0.7,
size: if rng() > 0.95 { 1.5 + rng() } else { 0.8 + rng() * 0.5 },
⋮----
puffs.push((Vec2::ZERO, 1.0));
let num_puffs = 5 + (rng() * 4.0) as usize;
⋮----
let angle = rng() * PI * 2.0;
let dist = 15.0 + rng() * 25.0;
let r_mult = 0.4 + rng() * 0.5;
puffs.push((
Vec2::new(angle.cos() * dist, angle.sin() * dist * 0.6),
⋮----
self.clouds.push(Cloud {
pos: Vec2::new(rng() * 1200.0 - 600.0, rng() * 400.0 - 200.0),
velocity: 5.0 + rng() * 15.0,
scale: 1.2 + rng() * 1.5,
opacity: 0.4 + rng() * 0.4,
⋮----
let dist = rng().sqrt() * 0.7;
let pos = Vec2::new(angle.cos() * dist, angle.sin() * dist);
self.moon_features.push(MoonFeature {
⋮----
radius: 0.15 + rng() * 0.25,
⋮----
let dist = rng().powf(0.8);
⋮----
radius: 0.02 + rng() * 0.06,
⋮----
pub fn update(&mut self, ctx: &egui::Context) -> SplashStatus {
self.is_dark = ctx.style().visuals.dark_mode;
if !self.init_done { self.init_scene(); }
let now = ctx.input(|i| i.time);
let dt = ctx.input(|i| i.stable_dt);
if self.exit_start_time.is_none() {
⋮----
if ctx.input(|i| i.pointer.any_click()) {
self.exit_start_time = Some(now);
⋮----
let physics_t = t_abs.min(ANIMATION_DURATION);
⋮----
warp_progress = (dt / EXIT_DURATION).clamp(0.0, 1.0);
⋮----
ctx.request_repaint();
let viewport_rect = ctx.input(|i| i.viewport().inner_rect.unwrap_or(Rect::from_min_size(Pos2::ZERO, Vec2::ZERO)));
let size = if viewport_rect.width() < 100.0 || viewport_rect.height() < 100.0 {
⋮----
viewport_rect.size()
⋮----
if cloud.pos.x > rect.width() / 2.0 + 300.0 {
cloud.pos.x = -rect.width() / 2.0 - 300.0;
⋮----
if let Some(pointer) = ctx.input(|i| i.pointer.hover_pos()) {
let center = rect.center();
⋮----
let cam_dist = 600.0 + smoothstep(0.0, ANIMATION_DURATION, physics_t) * 100.0 - cam_z_offset;
⋮----
if t_abs < 0.8 { self.loading_text = "TRANSLATING...".to_string(); }
else if t_abs < 1.6 { self.loading_text = "OCR...".to_string(); }
else if t_abs < 2.4 { self.loading_text = "TRANSCRIBING...".to_string(); }
else { self.loading_text = "nganlinh4".to_string(); }
⋮----
self.loading_text = "READY TO ROCK!".to_string();
⋮----
let progress = smoothstep(my_start, my_end, physics_t);
⋮----
let current_h_y = v.helix_y + (physics_t * 2.0 + v.noise_factor * 10.0).sin() * 5.0;
⋮----
let flare = (physics_t - flare_start).powi(2) * 20.0;
⋮----
v.pos = Vec3::new(current_angle.cos() * current_radius, current_h_y, current_angle.sin() * current_radius);
⋮----
let helix_pos = Vec3::new(current_angle.cos() * current_radius, current_h_y, current_angle.sin() * current_radius);
⋮----
let local_linear = ((warp_progress - start_threshold) / move_duration).clamp(0.0, 1.0);
⋮----
let radial = Vec3::new(v.pos.x, v.pos.y, 0.0).normalize();
⋮----
let swirl_vec = radial.rotate_z(curl_angle);
⋮----
target_base = target_base.add(swirl_vec.mul(local_eased * dist_mult));
⋮----
let pos = helix_pos.lerp(target_base, progress);
⋮----
let to_mouse = pos.sub(self.mouse_world_pos);
⋮----
let dist = dist_sq.sqrt();
⋮----
v.velocity = v.velocity.add(to_mouse.normalize().mul(force * 2.0));
⋮----
let displacement = pos.sub(target_base);
let spring_force = displacement.mul(-0.1);
v.velocity = v.velocity.add(spring_force);
v.velocity = v.velocity.mul(0.90);
v.pos = pos.add(v.velocity);
v.rot = v.rot.lerp(Vec3::ZERO, 0.1);
⋮----
let impact = (physics_t - my_end).max(0.0);
let pulse = (impact * 10.0).sin() * (-3.0 * impact).exp() * 0.5;
⋮----
v.scale = lerp(0.8, 1.0, progress);
⋮----
pub fn paint(&self, ctx: &egui::Context) {
⋮----
warp_prog = (dt / EXIT_DURATION).powi(5);
⋮----
.order(egui::Order::Foreground)
.fixed_pos(Pos2::ZERO)
.show(ctx, |ui| {
ui.allocate_response(size, egui::Sense::click_and_drag().union(egui::Sense::hover()));
⋮----
let painter = ctx.layer_painter(egui::LayerId::new(egui::Order::Foreground, egui::Id::new("splash_overlay")));
⋮----
let master_alpha = alpha.clamp(0.0, 1.0);
⋮----
let t_fade = (t / 0.5).clamp(0.0, 1.0);
⋮----
lerp(start_col.r() as f32, bg_color.r() as f32, t_fade) as u8,
lerp(start_col.g() as f32, bg_color.g() as f32, t_fade) as u8,
lerp(start_col.b() as f32, bg_color.b() as f32, t_fade) as u8,
⋮----
let sky_exit_fade = (1.0 - warp_prog * 4.0).clamp(0.0, 1.0);
⋮----
painter.rect_filled(rect, 0.0, bg_color.linear_multiply(sky_exit_fade));
⋮----
let c_top = C_SKY_DAY_TOP.linear_multiply(sky_exit_fade);
let c_bot = C_SKY_DAY_BOT.linear_multiply(sky_exit_fade);
⋮----
mesh.vertices.push(egui::epaint::Vertex { pos: rect.left_top(), uv: Pos2::ZERO, color: c_top });
mesh.vertices.push(egui::epaint::Vertex { pos: rect.right_top(), uv: Pos2::ZERO, color: c_top });
mesh.vertices.push(egui::epaint::Vertex { pos: rect.right_bottom(), uv: Pos2::ZERO, color: c_bot });
mesh.vertices.push(egui::epaint::Vertex { pos: rect.left_bottom(), uv: Pos2::ZERO, color: c_bot });
mesh.add_triangle(0, 1, 2);
mesh.add_triangle(0, 2, 3);
painter.add(mesh);
⋮----
for (i, star) in self.stars.iter().enumerate() {
let sx = rect.left() + (star.pos.x * rect.width()) + star_offset.x;
let sy = rect.top() + (star.pos.y * rect.height()) + star_offset.y;
let rnd = ((i as f32 * 1.618).fract() + (star.pos.x * 10.0).fract()).fract();
⋮----
let p = ((warp_prog - start) / dur).clamp(0.0, 1.0);
⋮----
let twinkle = (star.phase + star_time).sin() * 0.3 + 0.7;
let star_alpha = (star.brightness * twinkle * master_alpha * local_fade).clamp(0.0, 1.0);
⋮----
painter.circle_filled(
⋮----
C_WHITE.linear_multiply(star_alpha)
⋮----
C_WHITE.linear_multiply(day_star_alpha)
⋮----
mesh.vertices.push(egui::epaint::Vertex { pos: sun_pos, uv: Pos2::ZERO, color: Color32::TRANSPARENT });
⋮----
let p1 = sun_pos + Vec2::new(angle.cos() * ray_len, angle.sin() * ray_len);
let p2 = sun_pos + Vec2::new(next_angle.cos() * ray_len, next_angle.sin() * ray_len);
mesh.vertices.push(egui::epaint::Vertex { pos: p1, uv: Pos2::ZERO, color: c1 });
mesh.vertices.push(egui::epaint::Vertex { pos: p2, uv: Pos2::ZERO, color: c1 });
⋮----
let moon_alpha = master_alpha * (1.0 - warp_prog * 3.0).clamp(0.0, 1.0);
⋮----
let moon_bob = (t * 0.5).sin() * 5.0;
⋮----
painter.circle_filled(final_moon_pos, moon_rad * 1.6, C_MOON_GLOW.linear_multiply(0.03 * moon_alpha));
painter.circle_filled(final_moon_pos, moon_rad * 1.2, C_MOON_GLOW.linear_multiply(0.08 * moon_alpha));
painter.circle_filled(final_moon_pos, moon_rad, C_MOON_BASE.linear_multiply(moon_alpha));
⋮----
let rot_cos = feature_rot.cos();
let rot_sin = feature_rot.sin();
⋮----
let z_depth = (1.0 - dist_sq).sqrt();
⋮----
C_MOON_SHADOW.linear_multiply(f_alpha * 0.8)
⋮----
C_MOON_HIGHLIGHT.linear_multiply(f_alpha * 0.4)
⋮----
C_MOON_SHADOW.linear_multiply(f_alpha * 0.3)
⋮----
painter.circle_stroke(
⋮----
Stroke::new(2.0, C_MOON_HIGHLIGHT.linear_multiply(0.4 * moon_alpha))
⋮----
let sun_bob = (t * 0.5).sin() * 5.0;
⋮----
painter.circle_filled(final_sun_pos, moon_rad * 2.0, C_SUN_GLOW.linear_multiply(0.1 * moon_alpha));
painter.circle_filled(final_sun_pos, moon_rad * 1.4, C_SUN_GLOW.linear_multiply(0.2 * moon_alpha));
painter.circle_filled(final_sun_pos, moon_rad, C_SUN_BODY.linear_multiply(moon_alpha));
⋮----
Color32::from_rgb(160, 60, 0).linear_multiply(f_alpha * 0.8)
⋮----
C_SUN_FLARE.linear_multiply(f_alpha * 0.3)
⋮----
C_WHITE.linear_multiply(f_alpha * 0.5)
⋮----
Stroke::new(3.0, C_SUN_HIGHLIGHT.linear_multiply(0.5 * moon_alpha))
⋮----
painter.with_clip_rect(Rect::from_min_max(rect.min, Pos2::new(rect.max.x, horizon + 30.0)))
⋮----
painter.clone()
⋮----
for (i, cloud) in self.clouds.iter().enumerate() {
⋮----
let rnd = (i as f32 * 0.73).fract();
⋮----
C_CLOUD_CORE.linear_multiply(cloud_alpha * 0.95)
⋮----
C_CLOUD_WHITE.linear_multiply(cloud_alpha * 0.95)
⋮----
cloud_painter.circle_filled(
⋮----
let render_t = t.min(ANIMATION_DURATION + 5.0);
⋮----
let rnd = (i as f32 * 0.9).sin() * 0.5 + 0.5;
⋮----
let perspective = 250.0 / (z_dist - warp_prog * 0.8).max(0.1);
⋮----
if y > rect.bottom() || y < horizon { continue; }
let w = rect.width() * (2.5 / z_dist);
⋮----
let alpha_grid = (1.0 - (y - horizon) / (rect.bottom() - horizon)).powf(0.5) * master_alpha * 0.5 * local_fade;
⋮----
(C_DAY_REP, 4.0 * (1.0 - (y-horizon)/rect.height()))
⋮----
painter.line_segment(
⋮----
Stroke::new(thickness, grid_col.linear_multiply(alpha_grid))
⋮----
let physics_t = t.min(ANIMATION_DURATION);
⋮----
let cam_dist = (600.0 + smoothstep(0.0, 8.0, physics_t) * 100.0) - cam_fly_dist;
⋮----
let mut draw_list: Vec<(f32, Pos2, f32, Color32, bool, bool)> = Vec::with_capacity(self.voxels.len());
⋮----
local_debris_alpha = 1.0 - smoothstep(fade_start, fade_end, physics_t);
⋮----
v_center = v_center.rotate_x(global_rot.x).rotate_y(global_rot.y).rotate_z(global_rot.z);
⋮----
let local_linear = ((warp_prog - start_threshold) / move_duration).clamp(0.0, 1.0);
let fade = (local_linear * 1.5).clamp(0.0, 1.0);
⋮----
let final_col = base_col.linear_multiply(alpha_local);
draw_list.push((z_depth, screen_pos, r, final_col, v.color == C_WHITE || v.color == C_DAY_SEC, v.is_debris));
⋮----
draw_list.sort_by(|a, b| b.0.partial_cmp(&a.0).unwrap_or(Ordering::Equal));
⋮----
Color32::from_black_alpha(200).linear_multiply(col.a() as f32 / 255.0)
⋮----
Color32::from_rgb(100, 120, 150).linear_multiply(col.a() as f32 / 255.0)
⋮----
Color32::from_rgb(0, 40, 100).linear_multiply(col.a() as f32 / 255.0)
⋮----
painter.circle_filled(pos, r, shadow_col);
⋮----
painter.circle_filled(pos + body_offset, r * 0.85, col);
⋮----
Color32::WHITE.linear_multiply(0.5)
⋮----
col.linear_multiply(0.5)
⋮----
painter.circle_filled(pos + gradient_offset, r * 0.5, glow_col);
⋮----
.linear_multiply(col.a() as f32 / 255.0);
painter.circle_filled(highlight_pos, r * 0.25, highlight_col);
painter.circle_filled(highlight_pos, r * 0.15, Color32::WHITE.linear_multiply(col.a() as f32 / 255.0));
⋮----
let ui_alpha = 1.0 - (warp_prog * 10.0).clamp(0.0, 1.0);
⋮----
let ui_color = ui_text_col.linear_multiply(master_alpha * ui_alpha);
⋮----
C_CYAN.linear_multiply(master_alpha * ui_alpha)
⋮----
C_DAY_TEXT.linear_multiply(master_alpha * ui_alpha)
⋮----
C_WHITE.linear_multiply(master_alpha * ui_alpha)
⋮----
let magenta_color = if self.is_dark { C_MAGENTA.linear_multiply(master_alpha * ui_alpha) } else { C_DAY_REP.linear_multiply(master_alpha * ui_alpha) };
let title_text = format!("SCREEN GOATED TOOLBOX {}", env!("CARGO_PKG_VERSION"));
⋮----
C_MAGENTA.linear_multiply(master_alpha * ui_alpha)
⋮----
painter.text(
⋮----
title_font.clone(),
⋮----
painter.rect_filled(bar_rect, 2.0, bar_bg_col);
let prog = (physics_t / (ANIMATION_DURATION - 1.0)).clamp(0.0, 1.0);
⋮----
fill.set_width(bar_rect.width() * prog);
painter.rect_filled(fill, 2.0, magenta_color);
⋮----
let pulse = (t * 5.0).sin().abs() * 0.7 + 0.3;
⋮----
click_col.linear_multiply(pulse)
</file>

<file path="src/gui/utils.rs">
use eframe::egui;
use std::process::Command;
use windows::core::w;
⋮----
use windows_core::BOOL;
struct MonitorEnumContext {
⋮----
unsafe extern "system" fn monitor_enum_proc(
⋮----
if GetMonitorInfoW(hmonitor, &mut mi as *mut _ as *mut _).as_bool() {
⋮----
let trimmed_name = device_name.trim_matches(char::from(0)).to_string();
context.monitors.push(trimmed_name);
⋮----
pub fn get_monitor_names() -> Vec<String> {
⋮----
let _ = EnumDisplayMonitors(
⋮----
Some(monitor_enum_proc),
LPARAM(&mut ctx as *mut _ as isize),
⋮----
pub fn copy_to_clipboard_text(text: &str) {
⋮----
pub fn is_running_as_admin() -> bool {
⋮----
if OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &mut h_token).is_ok() {
⋮----
if GetTokenInformation(
⋮----
Some(&mut elevation as *mut _ as *mut std::ffi::c_void),
⋮----
.is_ok()
⋮----
pub fn is_system_in_dark_mode() -> bool {
⋮----
use winreg::RegKey;
⋮----
hkcu.open_subkey("Software\\Microsoft\\Windows\\CurrentVersion\\Themes\\Personalize")
⋮----
pub fn configure_fonts(ctx: &egui::Context) {
⋮----
let gs_data = include_bytes!(
⋮----
fonts.font_data.insert(
gs_font_name.to_owned(),
⋮----
let windir = std::env::var("WINDIR").unwrap_or_else(|_| "C:\\Windows".to_string());
let font_dir = std::path::Path::new(&windir).join("Fonts");
let viet_font_path = font_dir.join("segoeui.ttf");
let viet_fallback_path = font_dir.join("arial.ttf");
let viet_data = std::fs::read(&viet_font_path).or_else(|_| std::fs::read(&viet_fallback_path));
⋮----
let korean_font_path = font_dir.join("malgun.ttf");
⋮----
viet_font_name.to_owned(),
⋮----
if let Some(vec) = fonts.families.get_mut(&egui::FontFamily::Proportional) {
vec.insert(0, viet_font_name.to_owned());
⋮----
if let Some(vec) = fonts.families.get_mut(&egui::FontFamily::Monospace) {
⋮----
korean_font_name.to_owned(),
⋮----
let idx = if vec.contains(&viet_font_name.to_string()) {
⋮----
vec.insert(idx, korean_font_name.to_owned());
⋮----
vec.insert(0, gs_font_name.to_owned());
⋮----
ctx.set_fonts(fonts);
⋮----
pub fn set_admin_startup(enable: bool) -> bool {
⋮----
let exe_str = match exe_path.to_str() {
⋮----
if exe_str.is_empty() {
⋮----
.args(&[
⋮----
&format!("\"{}\"", exe_str),
⋮----
.output();
⋮----
Ok(o) => o.status.success(),
⋮----
.args(&["/delete", "/tn", TASK_NAME, "/f"])
⋮----
pub fn is_admin_startup_enabled() -> bool {
⋮----
.args(&["/query", "/tn", TASK_NAME])
⋮----
fn rgba_to_bgra(data: &[u8]) -> Vec<u8> {
let mut bgra = data.to_vec();
for chunk in bgra.chunks_exact_mut(4) {
chunk.swap(0, 2);
⋮----
unsafe fn create_hicon_from_bytes(bytes: &[u8], target_w: i32, target_h: i32) -> Option<HANDLE> {
let img = image::load_from_memory(bytes).ok()?;
let resized = img.resize_exact(
⋮----
let rgba = resized.to_rgba8();
let bgra_data = rgba_to_bgra(rgba.as_raw());
⋮----
let mask_bits = vec![0u8; mask_len];
let hicon_result = CreateIcon(
⋮----
mask_bits.as_ptr(),
bgra_data.as_ptr(),
⋮----
if hicon.is_invalid() {
⋮----
Some(std::mem::transmute::<_, HANDLE>(hicon))
⋮----
pub fn update_window_icon_native(is_dark_mode: bool) {
⋮----
include_bytes!("../../assets/app-icon-small.png")
⋮----
include_bytes!("../../assets/app-icon-small-light.png")
⋮----
let class_name = w!("eframe");
let title_name = w!("Screen Goated Toolbox (SGT by nganlinh4)");
let mut hwnd = FindWindowW(class_name, title_name).unwrap_or_default();
if hwnd.is_invalid() {
hwnd = FindWindowW(None, title_name).unwrap_or_default();
⋮----
if !hwnd.is_invalid() {
let small_w = GetSystemMetrics(SM_CXSMICON);
let small_h = GetSystemMetrics(SM_CYSMICON);
let big_w = GetSystemMetrics(SM_CXICON);
let big_h = GetSystemMetrics(SM_CYICON);
if let Some(hicon_small) = create_hicon_from_bytes(icon_bytes, small_w, small_h) {
let _ = SendMessageW(
⋮----
Some(WPARAM(ICON_SMALL as usize)),
Some(LPARAM(hicon_small.0 as isize)),
⋮----
if let Some(hicon_big) = create_hicon_from_bytes(icon_bytes, big_w, big_h) {
⋮----
Some(WPARAM(ICON_BIG as usize)),
Some(LPARAM(hicon_big.0 as isize)),
</file>

<file path="src/history.rs">
use chrono::Local;
⋮----
use std::fs;
use std::path::PathBuf;
⋮----
use std::thread;
⋮----
pub enum HistoryType {
⋮----
pub struct HistoryItem {
⋮----
pub enum HistoryAction {
⋮----
pub struct HistoryManager {
⋮----
impl HistoryManager {
pub fn new(max_items: usize) -> Self {
let (tx, rx) = channel();
let (_, db_path, _) = get_paths();
let initial_items = if db_path.exists() {
let file = fs::File::open(&db_path).ok();
⋮----
serde_json::from_reader(f).unwrap_or_default()
⋮----
let items_clone = items.clone();
⋮----
process_queue(rx, items_clone, max_items);
⋮----
pub fn save_image(&self, img: ImageBuffer<Rgba<u8>, Vec<u8>>, text: String) {
let _ = self.tx.send(HistoryAction::SaveImage { img, text });
⋮----
pub fn save_audio(&self, wav_data: Vec<u8>, text: String) {
let _ = self.tx.send(HistoryAction::SaveAudio { wav_data, text });
⋮----
pub fn save_text(&self, result_text: String, input_text: String) {
if !result_text.trim().is_empty() {
let _ = self.tx.send(HistoryAction::SaveText {
⋮----
pub fn delete(&self, id: i64) {
let _ = self.tx.send(HistoryAction::Delete(id));
let mut guard = self.items.lock().unwrap();
if let Some(pos) = guard.iter().position(|x| x.id == id) {
guard.remove(pos);
⋮----
pub fn clear_all(&self) {
let _ = self.tx.send(HistoryAction::ClearAll);
⋮----
guard.clear();
⋮----
pub fn request_prune(&self, limit: usize) {
let _ = self.tx.send(HistoryAction::Prune(limit));
⋮----
fn get_paths() -> (PathBuf, PathBuf, PathBuf) {
⋮----
.unwrap_or_default()
.join("screen-goated-toolbox");
let media_dir = config_dir.join("history_media");
let db_path = config_dir.join("history.json");
⋮----
fn save_db(items: &Vec<HistoryItem>) {
⋮----
fn process_queue(
⋮----
let (_, _, media_dir) = get_paths();
while let Ok(action) = rx.recv() {
⋮----
let mut items = cache.lock().unwrap();
⋮----
let timestamp = now.format("%Y-%m-%d %H:%M:%S").to_string();
let filename = format!("img_{}.png", now.format("%Y%m%d_%H%M%S_%f"));
let path = media_dir.join(&filename);
let id = now.timestamp_nanos_opt().unwrap_or(0);
if img.save(&path).is_ok() {
items.insert(
⋮----
let filename = format!("audio_{}.wav", now.format("%Y%m%d_%H%M%S_%f"));
⋮----
if fs::write(&path, wav_data).is_ok() {
⋮----
let filename = format!("text_{}.txt", now.format("%Y%m%d_%H%M%S_%f"));
⋮----
if fs::write(&path, &input_text).is_ok() {
⋮----
if let Some(pos) = items.iter().position(|x| x.id == id) {
let item = items.remove(pos);
let _ = fs::remove_file(media_dir.join(item.media_path));
⋮----
for entry in entries.flatten() {
let _ = fs::remove_file(entry.path());
⋮----
items.clear();
⋮----
if items.len() > max_items {
while items.len() > max_items {
if let Some(item) = items.pop() {
⋮----
save_db(&items);
</file>

<file path="src/overlay/favorite_bubble/mod.rs">
pub mod html;
pub mod panel;
pub mod render;
pub mod state;
pub mod utils;
pub mod window;
pub use panel::update_favorites_panel;
</file>

<file path="src/overlay/favorite_bubble/utils.rs">
use windows::Win32::Foundation::HWND;
pub struct HwndWrapper(pub HWND);
unsafe impl Send for HwndWrapper {}
unsafe impl Sync for HwndWrapper {}
⋮----
fn window_handle(
⋮----
std::num::NonZeroIsize::new(self.0 .0 as isize).expect("HWND cannot be null"),
⋮----
unsafe { Ok(raw_window_handle::WindowHandle::borrow_raw(handle)) }
</file>

<file path="src/overlay/html_components/grid_js.rs">
pub fn get_css() -> &'static str {
⋮----
pub fn get_init_script() -> &'static str {
⋮----
pub fn get_lib_urls() -> (&'static str, &'static str) {
</file>

<file path="src/overlay/html_components/icons.rs">
pub fn get_icon_svg(name: &str) -> &'static str {
</file>

<file path="src/overlay/html_components/js_main.rs">
pub fn get(font_size: u32) -> String {
format!(
</file>

<file path="src/overlay/input_history.rs">
use std::fs;
use std::path::PathBuf;
use std::sync::Mutex;
⋮----
pub struct InputHistory {
⋮----
impl Default for InputHistory {
fn default() -> Self {
⋮----
impl InputHistory {
fn history_path() -> PathBuf {
⋮----
.unwrap_or_default()
.join("screen-goated-toolbox");
⋮----
config_dir.join("input_history.json")
⋮----
pub fn load() -> Self {
⋮----
if path.exists() {
⋮----
fn save(&self) {
⋮----
pub fn add_entry(&mut self, text: &str) {
let text = text.trim().to_string();
if text.is_empty() {
⋮----
self.entries.retain(|e| e != &text);
self.entries.push(text);
while self.entries.len() > MAX_HISTORY_SIZE {
self.entries.remove(0);
⋮----
self.reset_navigation();
self.save();
⋮----
pub fn navigate_up(&mut self, current_text: &str) -> Option<String> {
if self.entries.is_empty() {
⋮----
self.current_draft = current_text.to_string();
self.nav_index = self.entries.len() as i32;
⋮----
if (self.nav_index as usize) < self.entries.len() {
self.entries.get(self.nav_index as usize).cloned()
⋮----
pub fn navigate_down(&mut self, _current_text: &str) -> Option<String> {
⋮----
if (self.nav_index as usize) >= self.entries.len() {
let draft = self.current_draft.clone();
⋮----
Some(draft)
⋮----
pub fn reset_navigation(&mut self) {
⋮----
self.current_draft.clear();
⋮----
pub fn add_to_history(text: &str) {
if let Ok(mut history) = INPUT_HISTORY.lock() {
history.add_entry(text);
⋮----
pub fn navigate_history_up(current_text: &str) -> Option<String> {
⋮----
history.navigate_up(current_text)
⋮----
pub fn navigate_history_down(current_text: &str) -> Option<String> {
⋮----
history.navigate_down(current_text)
⋮----
pub fn reset_history_navigation() {
⋮----
history.reset_navigation();
</file>

<file path="src/overlay/process/mod.rs">
pub mod chain;
pub mod pipeline;
pub mod types;
pub mod window;
</file>

<file path="src/overlay/realtime_html.rs">
use crate::gui::locale::LocaleText;
pub fn get_realtime_html(
⋮----
format!("{}", title_text)
⋮----
r#"<canvas id="volume-canvas" width="90" height="24"></canvas>"#.to_string()
⋮----
// Build language options HTML - show full name in dropdown, but store code for display
⋮----
.iter()
.map(|lang| {
⋮----
// Get 2-letter ISO 639-1 code
⋮----
.and_then(|l| l.to_639_1())
.map(|c| c.to_uppercase())
.unwrap_or_else(|| lang.chars().take(2).collect::<String>().to_uppercase());
// Option shows full name, but we store code as data attribute for selected display
format!(
⋮----
.join("\n");
⋮----
// Construct CSS and JS from components
let css = format!(
⋮----
let js = format!(
⋮----
// Get local font CSS (cached fonts, no network loading)
</file>

<file path="src/overlay/realtime_webview/state.rs">
use std::collections::HashMap;
use std::num::NonZeroIsize;
⋮----
pub static mut REALTIME_HWND: HWND = HWND(std::ptr::null_mut());
pub static mut TRANSLATION_HWND: HWND = HWND(std::ptr::null_mut());
⋮----
thread_local! {
⋮----
pub struct HwndWrapper(pub HWND);
impl HasWindowHandle for HwndWrapper {
fn window_handle(&self) -> std::result::Result<WindowHandle<'_>, HandleError> {
⋮----
Ok(unsafe { WindowHandle::borrow_raw(raw) })
⋮----
Err(HandleError::Unavailable)
</file>

<file path="src/overlay/result/paint.rs">
use super::layout::should_show_buttons;
⋮----
use std::mem::size_of;
use windows::core::w;
⋮----
unsafe fn measure_text_bounds(
⋮----
let hfont = CreateFontW(
⋮----
w!("Google Sans Flex"),
⋮----
let old_font = SelectObject(hdc, hfont.into());
⋮----
DrawTextW(
⋮----
SelectObject(hdc, old_font);
let _ = DeleteObject(hfont.into());
⋮----
pub fn create_bitmap_from_pixels(pixels: &[u32], w: i32, h: i32) -> HBITMAP {
⋮----
let hdc = GetDC(None);
⋮----
let hbm = CreateDIBSection(Some(hdc), &bmi, DIB_RGB_COLORS, &mut bits, None, 0).unwrap();
if !bits.is_null() {
⋮----
pixels.as_ptr() as *const u8,
⋮----
pixels.len() * 4,
⋮----
ReleaseDC(None, hdc);
⋮----
fn dist_segment(px: f32, py: f32, ax: f32, ay: f32, bx: f32, by: f32) -> f32 {
⋮----
let h = (pax * bax + pay * bay) / (bax * bax + bay * bay).max(0.001);
let h = h.clamp(0.0, 1.0);
⋮----
(dx * dx + dy * dy).sqrt()
⋮----
fn sd_box(px: f32, py: f32, cx: f32, cy: f32, w: f32, h: f32) -> f32 {
let dx = (px - cx).abs() - w;
let dy = (py - cy).abs() - h;
(dx.max(0.0).powi(2) + dy.max(0.0).powi(2)).sqrt() + dx.max(dy).min(0.0)
⋮----
pub fn paint_window(hwnd: HWND) {
⋮----
let hdc = BeginPaint(hwnd, &mut ps);
⋮----
let _ = GetClientRect(hwnd, &mut rect);
⋮----
let mut states = WINDOW_STATES.lock().unwrap();
if let Some(state) = states.get_mut(&(hwnd.0 as isize)) {
if state.bg_bitmap.is_invalid() || state.bg_w != width || state.bg_h != height {
if !state.bg_bitmap.is_invalid() {
let _ = DeleteObject(state.bg_bitmap.into());
⋮----
CreateDIBSection(Some(hdc), &bmi, DIB_RGB_COLORS, &mut p_bg_bits, None, 0)
.unwrap();
if !p_bg_bits.is_null() {
⋮----
pixels[start..end].fill(col);
⋮----
.iter()
.map(|p| (p.x, p.y, p.life, p.size, p.color))
.collect();
⋮----
Some((
⋮----
&& crate::api::tts::TTS_MANAGER.is_speaking(state.tts_request_id);
⋮----
state.text_history.len(),
state.redo_history.len(),
⋮----
state.graphics_mode.clone(),
state.preset_prompt.clone(),
state.input_text.clone(),
⋮----
"standard".to_string(),
⋮----
let mem_dc = CreateCompatibleDC(Some(hdc));
⋮----
let scratch_bitmap = CreateDIBSection(
Some(hdc),
⋮----
let old_scratch = SelectObject(mem_dc, scratch_bitmap.into());
if !cached_bg_bm.is_invalid() {
let cache_dc = CreateCompatibleDC(Some(hdc));
let old_cbm = SelectObject(cache_dc, cached_bg_bm.into());
let _ = BitBlt(mem_dc, 0, 0, width, height, Some(cache_dc), 0, 0, SRCCOPY).ok();
SelectObject(cache_dc, old_cbm);
let _ = DeleteDC(cache_dc);
⋮----
if cache_dirty || cached_text_bm.is_invalid() {
if !cached_text_bm.is_invalid() {
let _ = DeleteObject(cached_text_bm.into());
⋮----
cached_text_bm = CreateCompatibleBitmap(hdc, width, height);
⋮----
let old_cache_bm = SelectObject(cache_dc, cached_text_bm.into());
let dark_brush = CreateSolidBrush(COLORREF(bg_color_u32));
⋮----
FillRect(cache_dc, &fill_rect, dark_brush);
let _ = DeleteObject(dark_brush.into());
SetBkMode(cache_dc, TRANSPARENT);
SetTextColor(cache_dc, COLORREF(0x00FFFFFF));
⋮----
vec![0u16; 1]
⋮----
let combined = if input_text.is_empty() {
preset_prompt.clone()
⋮----
format!("{}\n\n{}", preset_prompt, input_text)
⋮----
.encode_utf16()
.chain(std::iter::once(0))
⋮----
let text_len = GetWindowTextLengthW(hwnd) + 1;
let mut b = vec![0u16; text_len as usize];
GetWindowTextW(hwnd, &mut b);
⋮----
let available_w = (width - (h_padding * 2)).max(1);
⋮----
let available_h = (height - v_safety_margin).max(1);
⋮----
18.min(available_h)
⋮----
available_h.min(100)
⋮----
let (h, w) = measure_text_bounds(cache_dc, &mut buf, mid, available_w);
⋮----
let old_font = SelectObject(cache_dc, hfont.into());
⋮----
let offset_y = ((height - text_h) / 2).max(0);
⋮----
DrawTextW(cache_dc, &mut buf, &mut draw_rect as *mut _, draw_flags);
SelectObject(cache_dc, old_font);
⋮----
SelectObject(cache_dc, old_cache_bm);
⋮----
let old_cbm = SelectObject(cache_dc, cached_text_bm.into());
⋮----
if !scratch_bits.is_null() {
⋮----
let cycle = (anim_offset.abs() % 360.0) / 180.0;
⋮----
margin + ((t * scan_range as f32) as i32).clamp(0, scan_range - 1);
⋮----
if idx < raw_pixels.len() {
⋮----
let time_rad = anim_offset.to_radians();
⋮----
let d = sd_rounded_box(px, py, bx, by, 12.0);
⋮----
let dist = d.abs();
⋮----
let angle = py.atan2(px);
let noise = (angle * 12.0 - time_rad * 2.0).sin() * 0.5;
⋮----
let t = (dist / glow_width).clamp(0.0, 1.0);
let base_intensity = (1.0 - t).powi(3);
⋮----
let noise_mod = (1.0 + noise * 0.3).clamp(0.0, 2.0);
⋮----
(base_intensity * noise_mod).clamp(0.0, 1.0);
⋮----
let deg = angle.to_degrees() + (anim_offset * 2.0);
⋮----
let rgb = hsv_to_rgb(hue, 0.85, 1.0);
⋮----
let min_x = (d_x - radius - 1.0).floor() as i32;
let max_x = (d_x + radius + 1.0).ceil() as i32;
let min_y = (d_y - radius - 1.0).floor() as i32;
let max_y = (d_y + radius + 1.0).ceil() as i32;
let start_x = min_x.max(0);
let end_x = max_x.min(width - 1);
let start_y = min_y.max(0);
let end_y = max_y.min(height - 1);
⋮----
let dist = (dx * dx + dy * dy).sqrt();
let aa_edge = (radius + 0.5 - dist).clamp(0.0, 1.0);
⋮----
&& should_show_buttons(width, height)
⋮----
for y in b_start_y.max(0)..b_end_y.min(height) {
⋮----
let dy = (fy - cy).abs();
⋮----
let dx = (fx - cx_back).abs();
⋮----
let aa = (radius + 0.5 - dist).clamp(0.0, 1.0);
⋮----
border_alpha = ((radius + 0.5 - dist).clamp(0.0, 1.0)
* ((dist - (border_inner_radius - 0.5)).clamp(0.0, 1.0)))
⋮----
let d_shaft = dist_segment(fx, fy, tip_x, cy, tail_x, cy);
⋮----
dist_segment(fx, fy, tip_x, cy, tip_x + 3.0, cy - 3.0);
⋮----
dist_segment(fx, fy, tip_x, cy, tip_x + 3.0, cy + 3.0);
let d_arrow = d_shaft.min(d_wing1).min(d_wing2);
icon_alpha = (1.3 - d_arrow).clamp(0.0, 1.0);
⋮----
let dx = (fx - cx_forward).abs();
⋮----
let d_shaft = dist_segment(fx, fy, tail_x, cy, tip_x, cy);
⋮----
dist_segment(fx, fy, tip_x, cy, tip_x - 3.0, cy - 3.0);
⋮----
dist_segment(fx, fy, tip_x, cy, tip_x - 3.0, cy + 3.0);
⋮----
let dx_c = (fx - cx_copy).abs();
let dist_c = (dx_c * dx_c + dy * dy).sqrt();
let aa_c = (radius + 0.5 - dist_c).clamp(0.0, 1.0);
⋮----
border_alpha = ((radius + 0.5 - dist_c).clamp(0.0, 1.0)
* ((dist_c - (border_inner_radius - 0.5)).clamp(0.0, 1.0)))
⋮----
let d1 = dist_segment(
⋮----
let d2 = dist_segment(
⋮----
icon_alpha = (1.8 - d1.min(d2)).clamp(0.0, 1.0);
⋮----
let back_d = sd_box(fx, fy, cx_copy - 2.0, cy - 2.0, 3.0, 4.0);
let back_outline = (1.25 - back_d.abs()).clamp(0.0, 1.0);
let front_d = sd_box(fx, fy, cx_copy + 2.0, cy + 2.0, 3.0, 4.0);
let front_fill = (0.8 - front_d).clamp(0.0, 1.0);
let mask_d = sd_box(fx, fy, cx_copy + 2.0, cy + 2.0, 4.5, 5.5);
⋮----
+ back_outline * mask_d.clamp(0.0, 1.0))
.clamp(0.0, 1.0);
⋮----
let dx_e = (fx - cx_edit).abs();
let dist_e = (dx_e * dx_e + dy * dy).sqrt();
let aa_e = (radius + 0.5 - dist_e).clamp(0.0, 1.0);
⋮----
border_alpha = ((radius + 0.5 - dist_e).clamp(0.0, 1.0)
* ((dist_e - (border_inner_radius - 0.5)).clamp(0.0, 1.0)))
⋮----
let sx = (fx - cx_edit).abs();
let sy = (fy - cy).abs();
⋮----
(sx.powf(0.6) + sy.powf(0.6)).powf(1.0 / 0.6) - 4.5;
let mut ia = (1.2 - star_dist).clamp(0.0, 1.0);
let sx2 = (fx - (cx_edit + 4.5)).abs();
let sy2 = (fy - (cy - 3.5)).abs();
⋮----
(sx2.powf(0.6) + sy2.powf(0.6)).powf(1.0 / 0.6) - 2.2;
ia = ia.max((1.2 - star2_dist).clamp(0.0, 1.0));
⋮----
let dx_m = (fx - cx_md).abs();
let dist_m = (dx_m * dx_m + dy * dy).sqrt();
let aa_m = (radius + 0.5 - dist_m).clamp(0.0, 1.0);
⋮----
border_alpha = ((radius + 0.5 - dist_m).clamp(0.0, 1.0)
* ((dist_m - (border_inner_radius - 0.5)).clamp(0.0, 1.0)))
⋮----
let d_m1 = dist_segment(
⋮----
let d_m2 = dist_segment(
⋮----
let d_m3 = dist_segment(
⋮----
let d_m4 = dist_segment(
⋮----
let d_m = d_m1.min(d_m2).min(d_m3).min(d_m4);
icon_alpha = (1.5 - d_m).clamp(0.0, 1.0);
⋮----
let dx_dl = (fx - cx_dl).abs();
let dist_dl = (dx_dl * dx_dl + dy * dy).sqrt();
let aa_dl = (radius + 0.5 - dist_dl).clamp(0.0, 1.0);
⋮----
border_alpha = ((radius + 0.5 - dist_dl).clamp(0.0, 1.0)
⋮----
.clamp(0.0, 1.0)))
⋮----
dist_segment(fx, fy, cx_dl, cy - 4.0, cx_dl, cy + 2.0);
let d_arrow1 = dist_segment(
⋮----
let d_arrow2 = dist_segment(
⋮----
let d_tray = dist_segment(
⋮----
let d_icon = d_line.min(d_arrow1).min(d_arrow2).min(d_tray);
icon_alpha = (1.5 - d_icon).clamp(0.0, 1.0);
⋮----
let dx_u = (fx - cx_undo).abs();
let dist_u = (dx_u * dx_u + dy * dy).sqrt();
let aa_u = (radius + 0.5 - dist_u).clamp(0.0, 1.0);
⋮----
border_alpha = ((radius + 0.5 - dist_u).clamp(0.0, 1.0)
* ((dist_u - (border_inner_radius - 0.5)).clamp(0.0, 1.0)))
⋮----
let dx_rd = (fx - cx_redo).abs();
let dist_rd = (dx_rd * dx_rd + dy * dy).sqrt();
let aa_rd = (radius + 0.5 - dist_rd).clamp(0.0, 1.0);
⋮----
border_alpha = ((radius + 0.5 - dist_rd).clamp(0.0, 1.0)
⋮----
let dx_sp = (fx - cx_speaker).abs();
let dist_sp = (dx_sp * dx_sp + dy * dy).sqrt();
let aa_sp = (radius + 0.5 - dist_sp).clamp(0.0, 1.0);
⋮----
border_alpha = ((radius + 0.5 - dist_sp).clamp(0.0, 1.0)
⋮----
let d_cone = sd_box(
⋮----
let d_bell1 = dist_segment(
⋮----
let d_bell2 = dist_segment(
⋮----
let d_bell3 = dist_segment(
⋮----
let d_bell = d_bell1.min(d_bell2).min(d_bell3);
⋮----
let angle = py_wave.atan2(px);
⋮----
if px > 0.0 && angle.abs() < std::f32::consts::FRAC_PI_3 {
let dist_from_center = (px * px + py_wave * py_wave).sqrt();
let d_wave1 = (dist_from_center - 3.5).abs() - 0.8;
let d_wave2 = (dist_from_center - 6.0).abs() - 0.8;
d_wave = d_wave1.min(d_wave2);
⋮----
let d_speaker = d_cone.min(d_bell).min(d_wave);
icon_alpha = (1.5 - d_speaker).clamp(0.0, 1.0);
⋮----
| ((final_r.min(255.0) as u32) << 16)
| ((final_g.min(255.0) as u32) << 8)
| (final_b.min(255.0) as u32);
⋮----
let pixels = render_procedural_broom(params);
let hbm = create_bitmap_from_pixels(&pixels, BROOM_W, BROOM_H);
Some((bx, by, hbm))
⋮----
if !hbm.is_invalid() {
let broom_dc = CreateCompatibleDC(Some(hdc));
let old_hbm_broom = SelectObject(broom_dc, hbm.into());
⋮----
let _ = GdiAlphaBlend(
⋮----
SelectObject(broom_dc, old_hbm_broom);
let _ = DeleteDC(broom_dc);
let _ = DeleteObject(hbm.into());
⋮----
let _ = BitBlt(hdc, 0, 0, width, height, Some(mem_dc), 0, 0, SRCCOPY).ok();
SelectObject(mem_dc, old_scratch);
let _ = DeleteObject(scratch_bitmap.into());
let _ = DeleteDC(mem_dc);
let _ = EndPaint(hwnd, &mut ps);
</file>

<file path="src/overlay/result/state.rs">
use std::collections::HashMap;
⋮----
pub struct DustParticle {
⋮----
pub enum AnimationMode {
⋮----
pub enum ResizeEdge {
⋮----
pub enum InteractionMode {
⋮----
pub struct CursorPhysics {
⋮----
impl Default for CursorPhysics {
fn default() -> Self {
⋮----
pub enum RefineContext {
⋮----
pub struct WindowState {
⋮----
unsafe impl Send for WindowState {}
unsafe impl Sync for WindowState {}
⋮----
pub enum WindowType {
⋮----
pub fn link_windows(hwnd1: HWND, hwnd2: HWND) {
let mut states = WINDOW_STATES.lock().unwrap();
if let Some(s1) = states.get_mut(&(hwnd1.0 as isize)) {
s1.linked_window = Some(hwnd2);
⋮----
if let Some(s2) = states.get_mut(&(hwnd2.0 as isize)) {
s2.linked_window = Some(hwnd1);
⋮----
pub fn close_windows_with_token(token: &Arc<AtomicBool>) {
token.store(true, Ordering::SeqCst);
⋮----
let states = WINDOW_STATES.lock().unwrap();
for (&h_val, state) in states.iter() {
⋮----
to_close.push(HWND(h_val as *mut std::ffi::c_void));
⋮----
if IsWindow(Some(hwnd)).as_bool() {
let _ = PostMessageW(
Some(hwnd),
</file>

<file path="src/overlay/result/window.rs">
use std::mem::size_of;
use std::sync::Once;
⋮----
use windows::Win32::UI::Input::KeyboardAndMouse::SetFocus;
⋮----
use super::event_handler::result_wnd_proc;
⋮----
pub fn get_chain_color(visible_index: usize) -> u32 {
⋮----
let cycle_idx = (visible_index - 1) % (CHAIN_PALETTE.len() - 1);
⋮----
unsafe fn set_rounded_edit_region(h_edit: HWND, w: i32, h: i32) {
let rgn = CreateRoundRectRgn(0, 0, w, h, 12, 12);
let _ = SetWindowRgn(h_edit, Some(rgn), true);
⋮----
pub fn create_result_window(
⋮----
let instance = GetModuleHandleW(None).unwrap();
let class_name = w!("TranslationResult");
REGISTER_RESULT_CLASS.call_once(|| {
⋮----
wc.lpfnWndProc = Some(result_wnd_proc);
wc.hInstance = instance.into();
wc.hCursor = LoadCursorW(None, IDC_ARROW).unwrap();
⋮----
let _ = RegisterClassW(&wc);
⋮----
let width = (target_rect.right - target_rect.left).abs();
let height = (target_rect.bottom - target_rect.top).abs();
⋮----
let hwnd = CreateWindowExW(
⋮----
w!(""),
⋮----
Some(instance.into()),
⋮----
.unwrap_or_default();
// FOR MARKDOWN MODE: Create WebView IMMEDIATELY after window creation
// See docs/WEBVIEW2_INITIALIZATION.md for why this is necessary
⋮----
let _ = SetLayeredWindowAttributes(hwnd, COLORREF(0), 0, LWA_ALPHA);
⋮----
let _ = SetLayeredWindowAttributes(hwnd, COLORREF(0), 220, LWA_ALPHA);
⋮----
let edit_style = WINDOW_STYLE(
⋮----
let h_edit = CreateWindowExW(
⋮----
w!("EDIT"),
⋮----
0, // Sized dynamically
Some(hwnd),
Some(HMENU(101 as *mut core::ffi::c_void)),
⋮----
let hfont = CreateFontW(
⋮----
w!("Segoe UI"),
⋮----
SendMessageW(
⋮----
Some(WPARAM(hfont.0 as usize)),
Some(LPARAM(1)),
⋮----
let app = crate::APP.lock().unwrap();
app.config.graphics_mode.clone()
⋮----
let mut states = WINDOW_STATES.lock().unwrap();
states.insert(
⋮----
full_text: initial_text.clone(),
⋮----
pending_text: Some(initial_text),
⋮----
let _ = DwmSetWindowAttribute(
⋮----
DWMWINDOWATTRIBUTE(33),
⋮----
let _ = SetWindowPos(
⋮----
Some(HWND_TOP),
⋮----
set_rounded_edit_region(h_edit, edit_w, edit_h);
let _ = SetForegroundWindow(hwnd);
let _ = SetFocus(Some(h_edit));
⋮----
SetTimer(Some(hwnd), 3, 16, None);
⋮----
SetTimer(Some(hwnd), 2, 30, None);
⋮----
let _ = InvalidateRect(Some(hwnd), None, false);
let _ = UpdateWindow(hwnd);
⋮----
pub fn update_window_text(hwnd: HWND, text: &str) {
if !unsafe { IsWindow(Some(hwnd)).as_bool() } {
⋮----
if let Some(state) = states.get_mut(&(hwnd.0 as isize)) {
state.pending_text = Some(text.to_string());
state.full_text = text.to_string();
</file>

<file path="src/repo_consolidator.rs">
use ignore::WalkBuilder;
use std::fs;
use std::collections::BTreeMap;
pub fn consolidate_repo(path: &str) -> Vec<(String, String)> {
⋮----
.standard_filters(true)
.build();
⋮----
let path = entry.path();
if path.is_file() {
⋮----
.strip_prefix(".")
.unwrap_or(path)
.to_string_lossy()
.replace("\\", "/");
files.push((rel_path, content));
⋮----
eprintln!("Skipped {} binary/unreadable files", skipped);
⋮----
files.sort_by(|a, b| a.0.cmp(&b.0));
⋮----
pub fn generate_repomix_format(files: &[(String, String)]) -> String {
⋮----
output.push_str("This file is a merged representation of the entire codebase, combined into a single document by code-packer (compatible format).\n\n");
output.push_str("<file_summary>\n");
output.push_str("This section contains a summary of this file.\n\n");
output.push_str("<purpose>\n");
output.push_str("This file contains a packed representation of the entire repository's contents.\n");
output.push_str("It is designed to be easily consumable by AI systems for analysis, code review,\n");
output.push_str("or other automated processes.\n");
output.push_str("</purpose>\n\n");
output.push_str("<file_format>\n");
output.push_str("The content is organized as follows:\n");
output.push_str("1. This summary section\n");
output.push_str("2. Repository information\n");
output.push_str("3. Directory structure\n");
output.push_str("4. Repository files (if enabled)\n");
output.push_str("5. Multiple file entries, each consisting of:\n");
output.push_str("   - File path as an attribute\n");
output.push_str("   - Full contents of the file\n");
output.push_str("</file_format>\n\n");
output.push_str("<usage_guidelines>\n");
output.push_str("- This file should be treated as read-only. Any changes should be made to the\n");
output.push_str("  original repository files, not this packed version.\n");
output.push_str("- When processing this file, use the file path to distinguish\n");
output.push_str("  between different files in the repository.\n");
output.push_str("- Be aware that this file may contain sensitive information. Handle it with\n");
output.push_str("  the same level of security as you would the original repository.\n");
output.push_str("</usage_guidelines>\n\n");
output.push_str("<notes>\n");
output.push_str("- Some files may have been excluded based on .gitignore rules\n");
output.push_str("- Binary files are not included in this packed representation\n");
output.push_str("- Files matching patterns in .gitignore are excluded\n");
output.push_str("</notes>\n\n");
output.push_str("</file_summary>\n\n");
output.push_str("<directory_structure>\n");
⋮----
let clean_path = if path.starts_with("src/") {
path.strip_prefix("src/").unwrap_or(&path).to_string()
} else if path.starts_with("src\\") {
path.strip_prefix("src\\").unwrap_or(&path).to_string()
⋮----
path.clone()
⋮----
dir_tree.insert(clean_path, true);
⋮----
for path in dir_tree.keys() {
output.push_str(path);
output.push('\n');
⋮----
output.push_str("</directory_structure>\n\n");
output.push_str("<files>\n");
output.push_str("This section contains the contents of the repository's files.\n\n");
⋮----
output.push_str(&format!("<file path=\"{}\">", clean_path));
⋮----
output.push_str(content);
output.push_str("</file>\n\n");
⋮----
output.push_str("</files>\n");
</file>

<file path="src/updater.rs">
use std::sync::mpsc::Sender;
use std::thread;
⋮----
pub enum UpdateStatus {
⋮----
pub struct Updater {
⋮----
impl Updater {
pub fn new(tx: Sender<UpdateStatus>) -> Self {
⋮----
pub fn check_for_updates(&self) {
let tx = self.tx.clone();
⋮----
let _ = tx.send(UpdateStatus::Checking);
⋮----
.timeout(std::time::Duration::from_secs(10))
.build();
⋮----
.get(url)
.set("User-Agent", "screen-goated-toolbox-checker")
.call();
⋮----
let release_json: String = match resp.into_string() {
⋮----
let _ = tx.send(UpdateStatus::Error(format!(
⋮----
Ok(mut releases) if !releases.is_empty() => {
let rel = releases.remove(0);
⋮----
rel.get("tag_name").and_then(|v| v.as_str()).unwrap_or("");
let version = tag_name.trim_start_matches('v').to_string();
⋮----
.get("body")
.and_then(|v| v.as_str())
.unwrap_or("")
.to_string();
let current = env!("CARGO_PKG_VERSION");
⋮----
.unwrap_or(false);
⋮----
let _ = tx.send(UpdateStatus::UpdateAvailable { version, body });
⋮----
let _ = tx.send(UpdateStatus::UpToDate(current.to_string()));
⋮----
let _ = tx.send(UpdateStatus::Error(
"No releases found on GitHub".to_string(),
⋮----
tx.send(UpdateStatus::Error(format!("JSON parse error: {}", e)));
⋮----
"Status 403: GitHub API rate limit reached or access forbidden. Please try again later or check your network/VPN.".to_string()
⋮----
_ => format!("Network error: {}", e)
⋮----
pub fn perform_update(&self) {
⋮----
let _ = tx.send(UpdateStatus::Downloading);
⋮----
Ok(exe_path) => match exe_path.parent() {
Some(dir) => dir.to_path_buf(),
⋮----
"Could not find exe directory".to_string(),
⋮----
let _ = tx.send(UpdateStatus::Error("Could not get exe path".to_string()));
⋮----
let temp_path = exe_dir.join("temp_download");
let mut staging_path = exe_dir.join("update_pending.exe");
⋮----
.set("User-Agent", "screen-goated-toolbox-updater")
.call()
⋮----
match response.into_string() {
⋮----
let _ = tx.send(UpdateStatus::Error(format!("Failed to parse response: {}", e)));
⋮----
"Status 403: GitHub API rate limit reached or access forbidden. Please try again later.".to_string()
⋮----
_ => format!("Failed to fetch release list: {}", e)
⋮----
let _ = tx.send(UpdateStatus::Error(error_msg));
⋮----
.get("name")
⋮----
.to_string(),
⋮----
.get("tag_name")
⋮----
.trim_start_matches('v')
⋮----
.get("published_at")
⋮----
.map(|s| s.to_string()),
⋮----
.get("assets")
.and_then(|a| a.as_array())
.unwrap_or(&vec![])
.iter()
.filter_map(|asset| {
let name = asset.get("name")?.as_str()?.to_string();
⋮----
asset.get("browser_download_url")?.as_str()?.to_string();
Some(self_update::update::ReleaseAsset { name, download_url })
⋮----
.collect(),
⋮----
let _ = tx.send(UpdateStatus::Error("No releases found".to_string()));
⋮----
let is_nopack = cfg!(nopack);
⋮----
.find(|a| {
let is_exe_zip = a.name.ends_with(".exe") || a.name.ends_with(".zip");
⋮----
a.name.contains("nopack")
⋮----
!a.name.contains("nopack")
⋮----
.or_else(|| {
⋮----
let _ = tx.send(UpdateStatus::Error(msg.to_string()));
⋮----
if asset.name.ends_with(".exe") {
staging_path = exe_dir.join(&asset.name);
⋮----
match ureq::get(&asset.download_url).call() {
⋮----
if let Err(e) = std::io::copy(&mut response.into_reader(), &mut file) {
let _ = tx.send(UpdateStatus::Error(format!("Download failed: {}", e)));
⋮----
drop(file);
if asset.name.ends_with(".zip") {
⋮----
Ok(mut archive) => match archive.by_index(0) {
⋮----
.is_ok()
⋮----
let _ = tx.send(
⋮----
"Failed to extract zip".to_string(),
⋮----
let _ = tx.send(UpdateStatus::UpdatedAndRestartRequired);
</file>

<file path="src/api/realtime_audio/state.rs">
pub struct RealtimeState {
⋮----
impl RealtimeState {
pub fn new() -> Self {
⋮----
fn update_display_transcript(&mut self) {
self.display_transcript = self.full_transcript.clone();
⋮----
fn update_display_translation(&mut self) {
let full = if self.committed_translation.is_empty() {
self.uncommitted_translation.clone()
} else if self.uncommitted_translation.is_empty() {
self.committed_translation.clone()
⋮----
format!(
⋮----
pub fn append_transcript(&mut self, new_text: &str) {
self.full_transcript.push_str(new_text);
⋮----
self.update_display_transcript();
⋮----
pub fn source_ends_with_sentence(&self) -> bool {
⋮----
if self.last_committed_pos >= self.full_transcript.len() {
⋮----
.trim()
.chars()
.last()
.map(|c| sentence_delimiters.contains(&c))
.unwrap_or(false)
⋮----
pub fn should_force_commit_on_timeout(&self) -> bool {
if self.uncommitted_translation.is_empty() {
⋮----
let user_silent = now.duration_since(self.last_transcript_append_time)
⋮----
let ai_silent = now.duration_since(self.last_translation_update_time)
⋮----
let source_ready = self.source_ends_with_sentence()
|| self.last_committed_pos < self.full_transcript.len();
⋮----
pub fn force_commit_all(&mut self) {
⋮----
let trans_segment = self.uncommitted_translation.trim().to_string();
if !trans_segment.is_empty() {
let source_segment = if self.last_committed_pos < self.full_transcript.len() {
⋮----
.to_string()
⋮----
"[continued]".to_string()
⋮----
self.add_to_history(source_segment, trans_segment.clone());
if self.committed_translation.is_empty() {
⋮----
self.committed_translation.push(' ');
self.committed_translation.push_str(&trans_segment);
⋮----
self.last_committed_pos = self.full_transcript.len();
self.uncommitted_translation.clear();
⋮----
self.update_display_translation();
⋮----
pub fn get_translation_chunk(&self) -> Option<(String, bool)> {
⋮----
.is_char_boundary(self.last_committed_pos)
⋮----
if text.trim().is_empty() {
⋮----
let has_finished_sentence = text.chars().any(|c| sentence_delimiters.contains(&c));
Some((text.trim().to_string(), has_finished_sentence))
⋮----
pub fn is_transcript_unchanged(&self) -> bool {
self.full_transcript.len() == self.last_processed_len
⋮----
pub fn update_last_processed_len(&mut self) {
self.last_processed_len = self.full_transcript.len();
⋮----
pub fn commit_finished_sentences(&mut self) -> bool {
⋮----
let uncommitted_len = self.uncommitted_translation.len();
⋮----
if temp_src_pos >= self.full_transcript.len() {
⋮----
if temp_trans_pos >= self.uncommitted_translation.len() {
⋮----
.char_indices()
.find(|(_, c)| sentence_delimiters.contains(c))
.map(|(i, c)| i + c.len_utf8());
⋮----
.find(|(i, c)| *i >= MIN_CLAUSE_LENGTH && clause_delimiters.contains(c))
.map(|(i, c)| i + c.len_utf8())
⋮----
matches.push((s_abs, t_abs, is_clause));
⋮----
if let Some(&(final_src_pos, final_trans_pos, _)) = matches.last() {
⋮----
.to_string();
⋮----
if !source_segment.is_empty() && !trans_segment.is_empty() {
⋮----
.trim_start()
⋮----
pub fn start_new_translation(&mut self) {
⋮----
pub fn append_translation(&mut self, new_text: &str) {
self.uncommitted_translation.push_str(new_text);
⋮----
pub fn add_to_history(&mut self, source: String, translation: String) {
self.translation_history.push((source, translation));
while self.translation_history.len() > 3 {
self.translation_history.remove(0);
⋮----
pub fn get_history_messages(&self, target_language: &str) -> Vec<serde_json::Value> {
⋮----
messages.push(serde_json::json!({
⋮----
pub type SharedRealtimeState = Arc<Mutex<RealtimeState>>;
</file>

<file path="src/api/realtime_audio/transcription.rs">
use anyhow::Result;
⋮----
use crate::config::Preset;
use crate::overlay::realtime_webview::SELECTED_APP_PID;
use crate::APP;
⋮----
use super::state::SharedRealtimeState;
use super::translation::run_translation_loop;
use super::utils::update_overlay_text;
⋮----
use super::WM_VOLUME_UPDATE;
⋮----
enum AudioMode {
⋮----
pub fn start_realtime_transcription(
⋮----
let translation_send = translation_hwnd.map(crate::win_types::SendHwnd);
⋮----
transcription_thread_entry(preset, stop_signal, overlay_send, translation_send, state);
⋮----
fn transcription_thread_entry(
⋮----
let hwnd_translation = translation_send.map(|h| h.0);
⋮----
AUDIO_SOURCE_CHANGE.store(false, Ordering::SeqCst);
let result = run_realtime_transcription(
current_preset.clone(),
stop_signal.clone(),
⋮----
state.clone(),
⋮----
if !AUDIO_SOURCE_CHANGE.load(Ordering::SeqCst) {
let err_msg = format!(" [Error: {}]", e);
eprintln!("Realtime transcription error: {}", e);
if let Ok(mut s) = state.lock() {
s.append_transcript(&err_msg);
⋮----
let display_text = if let Ok(s) = state.lock() {
s.display_transcript.clone()
⋮----
update_overlay_text(hwnd_overlay, &display_text);
⋮----
if AUDIO_SOURCE_CHANGE.load(Ordering::SeqCst) {
if let Ok(new_source) = NEW_AUDIO_SOURCE.lock() {
if !new_source.is_empty() {
current_preset.audio_source = new_source.clone();
stop_signal.store(true, Ordering::SeqCst);
⋮----
stop_signal.store(false, Ordering::SeqCst);
⋮----
fn run_realtime_transcription(
⋮----
let app = APP.lock().unwrap();
app.config.gemini_api_key.clone()
⋮----
if gemini_api_key.trim().is_empty() {
return Err(anyhow::anyhow!("NO_API_KEY:google"));
⋮----
let mut socket = connect_websocket(&gemini_api_key)?;
send_setup_message(&mut socket)?;
⋮----
match socket.read() {
⋮----
if msg.contains("setupComplete") {
⋮----
if msg.contains("error") || msg.contains("Error") {
return Err(anyhow::anyhow!("Server returned error: {}", msg));
⋮----
.map(|f| format!("code={}, reason={}", f.code, f.reason))
.unwrap_or("no frame".to_string());
return Err(anyhow::anyhow!(
⋮----
if let Ok(text) = String::from_utf8(data.clone()) {
if text.contains("setupComplete") {
⋮----
} else if data.len() < 100 {
⋮----
if e.kind() == std::io::ErrorKind::WouldBlock
|| e.kind() == std::io::ErrorKind::TimedOut =>
⋮----
if setup_start.elapsed() > Duration::from_secs(30) {
return Err(anyhow::anyhow!("Setup timeout - no response from server"));
⋮----
return Err(e.into());
⋮----
if stop_signal.load(Ordering::Relaxed) {
return Ok(());
⋮----
set_socket_nonblocking(&mut socket)?;
⋮----
use crate::overlay::realtime_webview::REALTIME_TTS_ENABLED;
let tts_enabled = REALTIME_TTS_ENABLED.load(Ordering::SeqCst);
let selected_pid = SELECTED_APP_PID.load(Ordering::SeqCst);
⋮----
start_per_app_capture(selected_pid, audio_buffer.clone(), stop_signal.clone())?;
⋮----
_stream = Some(start_device_loopback_capture(
audio_buffer.clone(),
⋮----
_stream = Some(start_mic_capture(
⋮----
let has_translation = translation_hwnd.is_some() && preset.blocks.len() > 1;
⋮----
let translation_send = crate::win_types::SendHwnd(translation_hwnd.unwrap());
let translation_state = state.clone();
let translation_stop = stop_signal.clone();
let translation_preset = preset.clone();
⋮----
run_translation_loop(
⋮----
run_main_loop(
⋮----
drop(_stream);
Ok(())
⋮----
fn run_main_loop(
⋮----
while !stop_signal.load(Ordering::Relaxed) {
if overlay_hwnd.0 != 0 as _ && !unsafe { IsWindow(Some(overlay_hwnd)).as_bool() } {
⋮----
use crate::overlay::realtime_webview::AUDIO_SOURCE_CHANGE;
⋮----
if mode_start.elapsed() >= NORMAL_DURATION {
⋮----
silence_buffer.clear();
⋮----
if mode_start.elapsed() >= SILENCE_DURATION {
⋮----
if silence_buffer.is_empty() {
⋮----
if last_send.elapsed() >= send_interval {
⋮----
let mut buf = audio_buffer.lock().unwrap();
⋮----
if !real_audio.is_empty() {
if send_audio_chunk(&mut socket, &real_audio).is_err() {
⋮----
silence_buffer.extend(real_audio);
let silence: Vec<i16> = vec![0i16; SAMPLES_PER_100MS];
if send_audio_chunk(&mut socket, &silence).is_err() {
⋮----
let to_send: Vec<i16> = if silence_buffer.len() >= chunk_size {
silence_buffer.drain(..chunk_size).collect()
} else if !silence_buffer.is_empty() {
silence_buffer.drain(..).collect()
⋮----
if !to_send.is_empty() {
if send_audio_chunk(&mut socket, &to_send).is_err() {
⋮----
let _ = PostMessageW(Some(overlay_hwnd), WM_VOLUME_UPDATE, WPARAM(0), LPARAM(0));
⋮----
if let Some(transcript) = parse_input_transcription(&msg) {
if !transcript.is_empty() {
⋮----
let display_text = if let Ok(mut s) = state.lock() {
s.append_transcript(&transcript);
⋮----
if !display_text.is_empty() {
update_overlay_text(overlay_hwnd, &display_text);
⋮----
if let Some(transcript) = parse_input_transcription(&text) {
⋮----
if !try_reconnect(
⋮----
&& last_transcription_time.elapsed()
⋮----
let error_str = e.to_string();
if error_str.contains("reset")
|| error_str.contains("closed")
|| error_str.contains("broken")
⋮----
let _ = socket.close(None);
⋮----
fn try_reconnect(
⋮----
reconnect_buffer.extend(std::mem::take(&mut *buf));
⋮----
match connect_websocket(api_key) {
⋮----
if send_setup_message(&mut new_socket).is_err() {
⋮----
if set_socket_nonblocking(&mut new_socket).is_err() {
⋮----
silence_buffer.extend(reconnect_buffer);
</file>

<file path="src/api/text.rs">
use super::client::UREQ_AGENT;
⋮----
use crate::gui::locale::LocaleText;
use crate::overlay::result::RefineContext;
use crate::overlay::utils::get_context_quote;
use crate::APP;
use anyhow::Result;
⋮----
pub fn translate_text_streaming<F>(
⋮----
.lock()
.ok()
.and_then(|app| {
let config = app.config.clone();
if config.openrouter_api_key.is_empty() {
⋮----
Some(config.openrouter_api_key.clone())
⋮----
.unwrap_or_default();
⋮----
let prompt = format!("{}\n\n{}", instruction, text);
⋮----
.map(|app| {
⋮----
config.ollama_base_url.clone(),
config.ollama_text_model.clone(),
⋮----
.unwrap_or_else(|| ("http://localhost:11434".to_string(), model.clone()));
let actual_model = if ollama_text_model.is_empty() {
model.clone()
⋮----
.to_lowercase()
.split("translate to ")
.nth(1)
.and_then(|s| s.split('.').next())
.and_then(|s| s.split(',').next())
.map(|s| s.trim().to_string())
.unwrap_or_else(|| "English".to_string());
⋮----
.chars()
.enumerate()
.map(|(i, c)| {
⋮----
c.to_uppercase().next().unwrap_or(c)
⋮----
on_chunk(&translated);
return Ok(translated);
⋮----
return Err(anyhow::anyhow!("GTX translation failed"));
⋮----
if gemini_api_key.trim().is_empty() {
return Err(anyhow::anyhow!("NO_API_KEY:gemini"));
⋮----
format!(
⋮----
model.contains("gemini-flash-latest") || model.contains("gemini-robotics");
⋮----
if !model.contains("gemma-3-27b-it") {
⋮----
.post(&url)
.set("x-goog-api-key", gemini_api_key)
.send_json(payload)
.map_err(|e| {
let err_str = e.to_string();
if err_str.contains("401") || err_str.contains("403") {
⋮----
let reader = BufReader::new(resp.into_reader());
⋮----
for line in reader.lines() {
let line = line.map_err(|e| anyhow::anyhow!("Failed to read line: {}", e))?;
if line.starts_with("data: ") {
let json_str = &line["data: ".len()..];
if json_str.trim() == "[DONE]" {
⋮----
chunk_resp.get("candidates").and_then(|c| c.as_array())
⋮----
if let Some(first_candidate) = candidates.first() {
⋮----
.get("content")
.and_then(|c| c.get("parts"))
.and_then(|p| p.as_array())
⋮----
.get("thought")
.and_then(|t| t.as_bool())
.unwrap_or(false);
⋮----
part.get("text").and_then(|t| t.as_str())
⋮----
on_chunk(locale.model_thinking);
⋮----
full_content.push_str(text);
let wipe_content = format!(
⋮----
on_chunk(&wipe_content);
⋮----
on_chunk(text);
⋮----
.into_json()
.map_err(|e| anyhow::anyhow!("Failed to parse non-streaming response: {}", e))?;
if let Some(candidates) = chat_resp.get("candidates").and_then(|c| c.as_array()) {
if let Some(first_choice) = candidates.first() {
⋮----
.iter()
.filter(|p| {
!p.get("thought").and_then(|t| t.as_bool()).unwrap_or(false)
⋮----
.filter_map(|p| p.get("text").and_then(|t| t.as_str()))
⋮----
on_chunk(&full_content);
⋮----
if openrouter_api_key.trim().is_empty() {
return Err(anyhow::anyhow!("NO_API_KEY:openrouter"));
⋮----
.post("https://openrouter.ai/api/v1/chat/completions")
.set("Authorization", &format!("Bearer {}", openrouter_api_key))
.set("Content-Type", "application/json")
⋮----
.get(0)
.and_then(|c| c.delta.reasoning.as_ref())
.filter(|s| !s.is_empty())
⋮----
.and_then(|c| c.delta.content.as_ref())
⋮----
full_content.push_str(content);
⋮----
format!("{}{}", crate::api::WIPE_SIGNAL, full_content);
⋮----
on_chunk(content);
⋮----
if let Some(choice) = chat_resp.choices.first() {
full_content = choice.message.content.clone();
⋮----
if groq_api_key.trim().is_empty() {
return Err(anyhow::anyhow!("NO_API_KEY:groq"));
⋮----
let is_compound = model.starts_with("groq/compound");
⋮----
let context_quote = get_context_quote(&prompt);
⋮----
Some(label) => format!(
⋮----
None => format!(
⋮----
on_chunk(&search_msg);
⋮----
.post("https://api.groq.com/openai/v1/chat/completions")
.set("Authorization", &format!("Bearer {}", groq_api_key))
.timeout(std::time::Duration::from_secs(60))
⋮----
if err_str.contains("401") {
⋮----
if let Some(remaining) = resp.header("x-ratelimit-remaining-requests") {
let limit = resp.header("x-ratelimit-limit-requests").unwrap_or("?");
let usage_str = format!("{} / {}", remaining, limit);
if let Ok(mut app) = APP.lock() {
app.model_usage_stats.insert(model.clone(), usage_str);
⋮----
.map_err(|e| anyhow::anyhow!("Failed to parse compound response: {}", e))?;
if let Some(choices) = json.get("choices").and_then(|c| c.as_array()) {
if let Some(first_choice) = choices.first() {
if let Some(message) = first_choice.get("message") {
⋮----
message.get("executed_tools").and_then(|t| t.as_array())
⋮----
if let Some(tool_type) = tool.get("type").and_then(|t| t.as_str()) {
⋮----
tool.get("arguments").and_then(|a| a.as_str())
⋮----
args_json.get("query").and_then(|q| q.as_str())
⋮----
search_queries.push(query.to_string());
⋮----
if !search_queries.is_empty() {
⋮----
phase1.push_str(&format!("{}\n", locale.search_query_label));
for (i, query) in search_queries.iter().enumerate() {
phase1.push_str(&format!("  {}. \"{}\"\n", i + 1, query));
⋮----
on_chunk(&phase1);
⋮----
.get("search_results")
.and_then(|s| s.get("results"))
.and_then(|r| r.as_array())
⋮----
.get("title")
.and_then(|t| t.as_str())
.unwrap_or(locale.search_no_title);
⋮----
.get("url")
.and_then(|u| u.as_str())
.unwrap_or("");
⋮----
.get("score")
.and_then(|s| s.as_f64())
.unwrap_or(0.0);
⋮----
.and_then(|c| c.as_str())
⋮----
all_sources.push((
title.to_string(),
url.to_string(),
⋮----
content.to_string(),
⋮----
if !all_sources.is_empty() {
all_sources.sort_by(|a, b| {
b.2.partial_cmp(&a.2).unwrap_or(std::cmp::Ordering::Equal)
⋮----
let mut phase2 = format!(
⋮----
phase2.push_str(&format!("{}\n\n", locale.search_sources_label));
⋮----
all_sources.iter().take(6).enumerate()
⋮----
let title_display = if title.chars().count() > 60 {
format!("{}...", title.chars().take(57).collect::<String>())
⋮----
title.clone()
⋮----
let domain = url.split('/').nth(2).unwrap_or(url);
⋮----
phase2.push_str(&format!(
⋮----
phase2.push_str(&format!("   🔗 {}\n", domain));
if !content.is_empty() {
let preview = if content.len() > 100 {
⋮----
content.replace('\n', " ")
⋮----
phase2.push_str(&format!("   📄 {}\n", preview));
⋮----
phase2.push('\n');
⋮----
on_chunk(&phase2);
⋮----
let phase3 = format!(
⋮----
on_chunk(&phase3);
⋮----
if let Some(content) = message.get("content").and_then(|c| c.as_str()) {
full_content = content.to_string();
⋮----
chunk.choices.get(0).and_then(|c| c.delta.content.as_ref())
⋮----
let chat_resp: ChatCompletionResponse = resp.into_json().map_err(|e| {
⋮----
json_obj.get("translation").and_then(|v| v.as_str())
⋮----
full_content = translation.to_string();
⋮----
full_content = content_str.clone();
⋮----
Ok(full_content)
⋮----
pub fn refine_text_streaming<F>(
⋮----
let final_prompt = format!(
⋮----
RefineContext::Image(_) => (original_model_id.to_string(), original_provider.to_string()),
⋮----
if !original_model_id.trim().is_empty() && original_model_id != "scout" {
(original_model_id.to_string(), original_provider.to_string())
⋮----
if !gemini_api_key.trim().is_empty() {
("gemini-flash-lite".to_string(), "google".to_string())
} else if !groq_api_key.trim().is_empty() {
("text_accurate_kimi".to_string(), "groq".to_string())
⋮----
p_model.contains("gemini-flash-latest") || p_model.contains("gemini-robotics");
⋮----
if !p_model.contains("gemma-3-27b-it") {
⋮----
.map_err(|e| anyhow::anyhow!("Gemini Refine Error: {}", e))?;
⋮----
if let Some(first) = candidates.first() {
⋮----
part.get("text").and_then(|v| v.as_str())
⋮----
full_content.push_str(t);
⋮----
on_chunk(t);
⋮----
let json: serde_json::Value = resp.into_json()?;
if let Some(candidates) = json.get("candidates").and_then(|c| c.as_array()) {
⋮----
.map_err(|e| anyhow::anyhow!("OpenRouter Refine Error: {}", e))?;
⋮----
let json: ChatCompletionResponse = resp.into_json()?;
if let Some(choice) = json.choices.first() {
⋮----
let is_compound = p_model.starts_with("groq/compound");
⋮----
let context_quote = get_context_quote(&final_prompt);
on_chunk(&format!(
⋮----
.map_err(|e| anyhow::anyhow!("Groq Compound Refine Error: {}", e))?;
⋮----
app.model_usage_stats.insert(p_model.clone(), usage_str);
⋮----
if tool.get("type").and_then(|t| t.as_str()) == Some("search") {
⋮----
let mut phase1 = format!(
⋮----
for (i, q) in search_queries.iter().enumerate() {
phase1.push_str(&format!("  {}. \"{}\"\n", i + 1, q));
⋮----
r.get("url").and_then(|u| u.as_str()).unwrap_or("");
⋮----
all_sources.iter().take(5).enumerate()
⋮----
let t = if title.chars().count() > 50 {
⋮----
let domain = url.split('/').nth(2).unwrap_or("");
⋮----
phase2.push_str(&format!("\n{}", locale.search_synthesizing));
⋮----
.map_err(|e| anyhow::anyhow!("Groq Refine Error: {}", e))?;
⋮----
let img = image::load_from_memory(&img_bytes)?.to_rgba8();
vision_translate_image_streaming(
⋮----
exec_text_only(target_id_or_name, target_provider)
⋮----
RefineContext::None => exec_text_only(target_id_or_name, target_provider),
</file>

<file path="src/api/tts/edge_voices.rs">
use lazy_static::lazy_static;
⋮----
use std::collections::HashMap;
use std::sync::Mutex;
⋮----
pub struct EdgeVoice {
⋮----
pub struct EdgeVoiceCache {
⋮----
impl Default for EdgeVoiceCache {
fn default() -> Self {
⋮----
lazy_static! {
⋮----
pub fn load_edge_voices_async() {
⋮----
let cache = EDGE_VOICE_CACHE.lock().unwrap();
⋮----
let mut cache = EDGE_VOICE_CACHE.lock().unwrap();
⋮----
.set(
⋮----
.call()
⋮----
match response.into_string() {
⋮----
.entry(voice.locale.clone())
.or_insert_with(Vec::new)
.push(voice.clone());
⋮----
.split('-')
.next()
.unwrap_or(&voice.locale)
.to_lowercase();
⋮----
.entry(lang_code)
⋮----
cache.error = Some(format!("Parse error: {}", e));
⋮----
cache.error = Some(format!("Read error: {}", e));
⋮----
cache.error = Some(format!("Network error: {}", e));
⋮----
pub fn get_available_languages() -> Vec<(String, String)> {
⋮----
if lang_map.contains_key(&lang_code) {
⋮----
if let Some(dash_pos) = voice.friendly_name.rfind(" - ") {
⋮----
if let Some(paren_pos) = lang_region.find(" (") {
⋮----
lang_map.insert(lang_code, lang_only.to_string());
⋮----
lang_map.insert(lang_code, lang_region.to_string());
⋮----
let mut languages: Vec<(String, String)> = lang_map.into_iter().collect();
languages.sort_by(|a, b| a.1.cmp(&b.1));
⋮----
pub fn get_voices_for_language(lang_code: &str) -> Vec<EdgeVoice> {
⋮----
.get(&lang_code.to_lowercase())
.cloned()
.unwrap_or_default()
</file>

<file path="src/api/tts/mod.rs">
pub mod edge_voices;
pub mod instance;
pub mod manager;
pub mod player;
pub mod types;
pub mod utils;
pub mod websocket;
pub mod worker;
pub mod wsola;
pub use instance::TTS_MANAGER;
pub use manager::TtsManager;
pub fn init_tts() {
let manager = TTS_MANAGER.clone();
</file>

<file path="src/api/tts/player.rs">
use std::collections::VecDeque;
⋮----
use std::time::Duration;
⋮----
use super::manager::TtsManager;
⋮----
use super::wsola::WsolaStretcher;
pub fn run_player_thread(manager: Arc<TtsManager>) {
let audio_player = AudioPlayer::new(PLAYBACK_SAMPLE_RATE, manager.clone());
⋮----
if manager.shutdown.load(Ordering::SeqCst) {
⋮----
let mut pq = manager.playback_queue.lock().unwrap();
while pq.is_empty() && !manager.shutdown.load(Ordering::SeqCst) {
let result = manager.playback_signal.wait(pq).unwrap();
⋮----
pq.pop_front()
⋮----
manager.is_playing.store(true, Ordering::SeqCst);
⋮----
match rx.recv() {
⋮----
if generation < manager.interrupt_generation.load(Ordering::SeqCst) {
audio_player.stop();
clear_tts_state(hwnd);
⋮----
clear_tts_loading_state(hwnd);
⋮----
audio_player.play(&data, is_realtime);
⋮----
audio_player.drain();
⋮----
manager.is_playing.store(false, Ordering::SeqCst);
⋮----
struct AudioPlayer {
⋮----
impl AudioPlayer {
fn new(sample_rate: u32, manager: Arc<TtsManager>) -> Self {
⋮----
let buffer_clone = shared_buffer.clone();
⋮----
let shutdown_clone = shutdown.clone();
⋮----
if let Ok(app) = crate::APP.lock() {
let id = app.config.tts_output_device.clone();
if id.is_empty() {
⋮----
Some(id)
⋮----
if wasapi::initialize_mta().is_err() {
eprintln!("TTS: Failed to initialize COM");
⋮----
buffer_clone.clone(),
shutdown_clone.clone(),
⋮----
eprintln!(
⋮----
_thread: Some(thread),
⋮----
fn create_excluded_stream(
⋮----
Ok(())
⋮----
unsafe fn run_wasapi_excluded(
⋮----
let _ = CoInitializeEx(None, COINIT_APARTMENTTHREADED).ok();
⋮----
CoCreateInstance(&MMDeviceEnumerator, None, CLSCTX_ALL)?;
⋮----
enumerator.GetDevice(&id_hstring)?
⋮----
enumerator.GetDefaultAudioEndpoint(eRender, eConsole)?
⋮----
let client: IAudioClient = device.Activate(CLSCTX_ALL, None)?;
let mix_format_ptr = client.GetMixFormat()?;
⋮----
client.Initialize(
⋮----
let buffer_size = client.GetBufferSize()?;
let render_client: IAudioRenderClient = client.GetService()?;
client.Start()?;
⋮----
let mut last_gen = manager.interrupt_generation.load(Ordering::SeqCst);
while !shutdown.load(Ordering::Relaxed) {
let current_gen = manager.interrupt_generation.load(Ordering::SeqCst);
⋮----
if let Ok(mut deck) = shared_buffer.lock() {
deck.clear();
⋮----
let padding = client.GetCurrentPadding()?;
let available = buffer_size.saturating_sub(padding);
⋮----
let buffer_ptr = render_client.GetBuffer(available)?;
let mut deck = shared_buffer.lock().unwrap();
⋮----
if let Some(sample) = deck.pop_front() {
⋮----
render_client.ReleaseBuffer(available, 0)?;
⋮----
client.Stop()?;
⋮----
fn play(&self, audio_data: &[u8], is_realtime: bool) {
⋮----
let base_speed = REALTIME_TTS_SPEED.load(Ordering::Relaxed);
let auto_enabled = REALTIME_TTS_AUTO_SPEED.load(Ordering::Relaxed);
⋮----
.lock()
.map(|q| q.len())
.unwrap_or(0);
⋮----
let boost = (queue_len as u32 * 15).min(60);
(base_speed + boost).min(200)
⋮----
let old_speed = CURRENT_TTS_SPEED.swap(speed, Ordering::Relaxed);
⋮----
use crate::overlay::realtime_webview::state::TRANSLATION_HWND;
⋮----
use windows::Win32::UI::WindowsAndMessaging::PostMessageW;
if !std::ptr::addr_of!(REALTIME_HWND).read().is_invalid() {
let _ = PostMessageW(
Some(REALTIME_HWND),
⋮----
WPARAM(speed as usize),
LPARAM(0),
⋮----
if !std::ptr::addr_of!(TRANSLATION_HWND).read().is_invalid() {
⋮----
Some(TRANSLATION_HWND),
⋮----
.chunks_exact(2)
.map(|chunk| i16::from_le_bytes([chunk[0], chunk[1]]))
.collect();
if input_samples.is_empty() {
⋮----
let stretched_samples = if (speed_ratio - 1.0).abs() < 0.05 {
⋮----
if let Ok(mut wsola) = self.wsola.lock() {
let result = wsola.stretch(&input_samples, speed_ratio);
if result.is_empty() {
⋮----
let output_samples: Vec<i16> = stretched_samples.iter().flat_map(|&s| [s, s]).collect();
if let Ok(mut buf) = self.shared_buffer.lock() {
buf.extend(output_samples);
⋮----
fn drain(&self) {
⋮----
let len = self.shared_buffer.lock().map(|b| b.len()).unwrap_or(0);
⋮----
fn stop(&self) {
⋮----
buf.clear();
⋮----
impl Drop for AudioPlayer {
fn drop(&mut self) {
self.shutdown.store(true, Ordering::SeqCst);
</file>

<file path="src/config/preset/preset.rs">
use super::block::ProcessingBlock;
use crate::config::types::Hotkey;
⋮----
pub struct Preset {
⋮----
fn default_prompt_mode() -> String {
"fixed".to_string()
⋮----
fn default_preset_type() -> String {
"image".to_string()
⋮----
fn default_text_input_mode() -> String {
"select".to_string()
⋮----
fn default_audio_source() -> String {
"mic".to_string()
⋮----
fn default_audio_processing_mode() -> String {
"record_then_process".to_string()
⋮----
fn default_realtime_window_mode() -> String {
"standard".to_string()
⋮----
fn default_true() -> bool {
⋮----
impl Default for Preset {
fn default() -> Self {
⋮----
id: generate_preset_id(),
name: "New Preset".to_string(),
blocks: vec![ProcessingBlock::default()],
block_connections: vec![],
prompt_mode: "fixed".to_string(),
preset_type: "image".to_string(),
text_input_mode: "select".to_string(),
audio_source: "mic".to_string(),
audio_processing_mode: "record_then_process".to_string(),
realtime_window_mode: "standard".to_string(),
video_capture_method: "region".to_string(),
⋮----
hotkeys: vec![],
⋮----
fn generate_preset_id() -> String {
format!(
⋮----
pub struct PresetBuilder {
⋮----
impl PresetBuilder {
pub fn new(id: &str, name: &str) -> Self {
⋮----
id: id.to_string(),
name: name.to_string(),
blocks: vec![],
⋮----
pub fn image(mut self) -> Self {
self.preset.preset_type = "image".to_string();
⋮----
pub fn text_select(mut self) -> Self {
self.preset.preset_type = "text".to_string();
self.preset.text_input_mode = "select".to_string();
⋮----
pub fn text_type(mut self) -> Self {
⋮----
self.preset.text_input_mode = "type".to_string();
⋮----
pub fn audio_mic(mut self) -> Self {
self.preset.preset_type = "audio".to_string();
self.preset.audio_source = "mic".to_string();
⋮----
pub fn audio_device(mut self) -> Self {
⋮----
self.preset.audio_source = "device".to_string();
⋮----
pub fn blocks(mut self, blocks: Vec<ProcessingBlock>) -> Self {
⋮----
pub fn connections(mut self, connections: Vec<(usize, usize)>) -> Self {
⋮----
pub fn auto_paste(mut self) -> Self {
⋮----
pub fn auto_stop(mut self) -> Self {
⋮----
pub fn realtime(mut self) -> Self {
self.preset.audio_processing_mode = "realtime".to_string();
⋮----
pub fn minimal_mode(mut self) -> Self {
self.preset.realtime_window_mode = "minimal".to_string();
⋮----
pub fn continuous(mut self) -> Self {
⋮----
pub fn dynamic_prompt(mut self) -> Self {
self.preset.prompt_mode = "dynamic".to_string();
⋮----
pub fn master(mut self) -> Self {
⋮----
self.preset.blocks = vec![];
⋮----
pub fn build(self) -> Preset {
⋮----
impl Preset {
pub fn is_builtin(&self) -> bool {
self.id.starts_with("preset_")
⋮----
pub fn is_master_preset(&self) -> bool {
⋮----
pub fn input_block(&self) -> Option<&ProcessingBlock> {
self.blocks.first()
⋮----
pub fn input_block_mut(&mut self) -> Option<&mut ProcessingBlock> {
self.blocks.first_mut()
</file>

<file path="src/gui/app/init.rs">
use crate::gui::settings_ui::ViewMode;
use crate::gui::utils::get_monitor_names;
⋮----
use auto_launch::AutoLaunch;
use eframe::egui;
use std::sync::atomic::Ordering;
use std::sync::mpsc::channel;
⋮----
impl SettingsApp {
pub fn new(
⋮----
let app_path = std::env::current_exe().unwrap();
⋮----
let auto = AutoLaunch::new(app_name, app_path.to_str().unwrap(), args);
⋮----
use winreg::RegKey;
⋮----
if let Ok(key) = hkcu.open_subkey_with_flags(
⋮----
if key.get_value::<String, &str>(app_name).is_ok() {
⋮----
run_at_startup = auto.is_enabled().unwrap_or(false);
⋮----
let _ = auto.enable();
⋮----
let (tx, rx) = channel();
let tx_tray = tx.clone();
let ctx_tray = ctx.clone();
⋮----
while let Ok(event) = TrayIconEvent::receiver().recv() {
⋮----
let _ = tx_tray.send(UserEvent::Tray(event));
ctx_tray.request_repaint();
⋮----
let ctx_restore = ctx.clone();
⋮----
match OpenEventW(
⋮----
w!("Global\\ScreenGoatedToolboxRestoreEvent"),
⋮----
let result = WaitForSingleObject(event_handle, INFINITE);
⋮----
let class_name = w!("eframe");
let mut hwnd = FindWindowW(class_name, None).unwrap_or_default();
if hwnd.is_invalid() {
let title = w!("Screen Goated Toolbox (SGT by nganlinh4)");
hwnd = FindWindowW(None, title).unwrap_or_default();
⋮----
if !hwnd.is_invalid() {
let _ = ShowWindow(hwnd, SW_RESTORE);
let _ = ShowWindow(hwnd, SW_SHOW);
let _ = SetForegroundWindow(hwnd);
let _ = SetFocus(Some(hwnd));
⋮----
RESTORE_SIGNAL.store(true, Ordering::SeqCst);
ctx_restore.request_repaint();
let _ = ResetEvent(event_handle);
⋮----
let _ = CloseHandle(event_handle);
⋮----
let tx_menu = tx.clone();
let ctx_menu = ctx.clone();
⋮----
while let Ok(event) = MenuEvent::receiver().recv() {
match event.id.0.as_str() {
⋮----
let hwnd = FindWindowW(class_name, None).unwrap_or_default();
let hwnd = if hwnd.is_invalid() {
⋮----
FindWindowW(None, title).unwrap_or_default()
⋮----
let _ = tx_menu.send(UserEvent::Menu(event.clone()));
ctx_menu.request_repaint();
⋮----
let _ = tx_menu.send(UserEvent::Menu(event));
⋮----
let view_mode = if config.presets.is_empty() {
⋮----
ViewMode::Preset(if config.active_preset_idx < config.presets.len() {
⋮----
let cached_monitors = get_monitor_names();
let (up_tx, up_rx) = channel();
⋮----
let devices_clone = cached_audio_devices.clone();
⋮----
if let Ok(mut lock) = devices_clone.lock() {
⋮----
let current_admin_state = if cfg!(target_os = "windows") {
⋮----
let initial_ui_language = config.ui_language.clone();
⋮----
.duration_since(std::time::UNIX_EPOCH)
.unwrap()
.as_millis() as u32;
tray_favorite_bubble_item.set_checked(config.show_favorite_bubble);
⋮----
let initial_has_favorites = config.presets.iter().any(|p| p.is_favorite);
⋮----
auto_launcher: Some(auto),
⋮----
Some(crate::gui::splash::SplashScreen::new(&ctx))
⋮----
updater: Some(Updater::new(up_tx)),
</file>

<file path="src/gui/app/types.rs">
use crate::config::Config;
use crate::gui::settings_ui::node_graph::ChainNode;
use crate::gui::settings_ui::ViewMode;
⋮----
use auto_launch::AutoLaunch;
use egui_snarl::Snarl;
use std::sync::atomic::AtomicBool;
use std::sync::mpsc::Receiver;
⋮----
pub enum UserEvent {
⋮----
pub struct SettingsApp {
</file>

<file path="src/gui/app/utils.rs">
use crate::config::save_config;
use eframe::egui;
use std::sync::atomic::Ordering;
⋮----
use windows::Win32::Foundation::CloseHandle;
⋮----
pub fn simple_rand(seed: u32) -> u32 {
seed.wrapping_mul(1103515245).wrapping_add(12345)
⋮----
pub fn signal_restore_window() {
RESTORE_SIGNAL.store(true, Ordering::SeqCst);
⋮----
if let Ok(event) = OpenEventW(
⋮----
w!("Global\\ScreenGoatedToolboxRestoreEvent"),
⋮----
let _ = SetEvent(event);
let _ = CloseHandle(event);
⋮----
impl SettingsApp {
pub(crate) fn save_and_sync(&mut self) {
⋮----
let mut state = self.app_state_ref.lock().unwrap();
⋮----
state.config = self.config.clone();
drop(state);
save_config(&self.config);
⋮----
let class = w!("HotkeyListenerClass");
let title = w!("Listener");
⋮----
.unwrap_or_default();
if !hwnd.is_invalid() {
⋮----
Some(hwnd),
⋮----
pub(crate) fn restore_window(&self, ctx: &egui::Context) {
ctx.send_viewport_cmd(egui::ViewportCommand::Visible(true));
ctx.send_viewport_cmd(egui::ViewportCommand::Minimized(false));
ctx.send_viewport_cmd(egui::ViewportCommand::Focus);
ctx.send_viewport_cmd(egui::ViewportCommand::WindowLevel(
⋮----
ctx.request_repaint();
⋮----
pub(crate) fn check_hotkey_conflict(
⋮----
for (idx, preset) in self.config.presets.iter().enumerate() {
⋮----
return Some(format!(
</file>

<file path="src/gui/mod.rs">
mod app;
pub mod icons;
mod key_mapping;
pub mod locale;
pub mod settings_ui;
pub mod splash;
pub mod utils;
pub use app::signal_restore_window;
pub use app::SettingsApp;
pub use utils::configure_fonts;
</file>

<file path="src/gui/settings_ui/node_graph/conversion.rs">
use super::node::ChainNode;
use crate::config::ProcessingBlock;
use eframe::egui;
⋮----
pub fn blocks_to_snarl(
⋮----
let positions: Vec<egui::Pos2> = if !connections.is_empty() {
⋮----
adj.entry(from).or_default().push(to);
⋮----
let mut depths = vec![0; blocks.len()];
⋮----
queue.push_back((0, 0));
let mut visited = vec![false; blocks.len()];
⋮----
while let Some((u, d)) = queue.pop_front() {
⋮----
layer_nodes.entry(d).or_default().push(u);
if let Some(children) = adj.get(&u) {
⋮----
if v < blocks.len() && !visited[v] {
⋮----
queue.push_back((v, d + 1));
⋮----
let mut pos_map = vec![egui::pos2(0.0, 0.0); blocks.len()];
for (depth, nodes) in layer_nodes.iter() {
let count = nodes.len();
⋮----
for (i, &node_idx) in nodes.iter().enumerate() {
⋮----
for i in 0..blocks.len() {
⋮----
.iter()
.enumerate()
.map(|(i, _)| egui::pos2(start_x + i as f32 * spacing_x, start_y))
.collect()
⋮----
let has_input_adapter = blocks.iter().any(|b| b.block_type == "input_adapter");
⋮----
block_type: preset_type.to_string(),
⋮----
virtual_input_id = Some(snarl.insert_node(pos, node));
⋮----
for (i, block) in blocks.iter().enumerate() {
⋮----
.any(|(from, to)| *to == i && blocks[*from].block_type == "input_adapter");
⋮----
if virtual_input_id.is_some() {
⋮----
let node_id = snarl.insert_node(pos, node);
node_ids.push(node_id);
⋮----
if !node_ids.is_empty() {
⋮----
snarl.connect(from, to);
⋮----
if !connections.is_empty() {
⋮----
if from_idx < node_ids.len() && to_idx < node_ids.len() {
⋮----
} else if blocks.len() > 1 {
for i in 0..node_ids.len() - 1 {
⋮----
pub fn snarl_to_graph(snarl: &Snarl<ChainNode>) -> (Vec<ProcessingBlock>, Vec<(usize, usize)>) {
⋮----
for (node_id, node) in snarl.node_ids() {
if node.is_input() {
input_node_id = Some(node_id);
⋮----
queue.push_back((start_id, true));
while let Some((node_id, _is_first)) = queue.pop_front() {
if node_to_idx.contains_key(&node_id) {
⋮----
if let Some(node) = snarl.get_node(node_id) {
let block = node.to_block();
let idx = blocks.len();
node_to_idx.insert(node_id, idx);
blocks.push(block);
⋮----
for (from, to) in snarl.wires() {
⋮----
queue.push_back((to.node, false));
⋮----
(node_to_idx.get(&from.node), node_to_idx.get(&to.node))
⋮----
connections.push((from_idx, to_idx));
</file>

<file path="src/gui/settings_ui/node_graph/node.rs">
use crate::config::ProcessingBlock;
use std::collections::HashMap;
⋮----
pub enum ChainNode {
⋮----
impl Default for ChainNode {
fn default() -> Self {
⋮----
id: format!(
⋮----
block_type: "text".to_string(),
model: "text_accurate_kimi".to_string(),
prompt: "Translate to {language1}. Output ONLY the translation.".to_string(),
⋮----
render_mode: "stream".to_string(),
⋮----
impl ChainNode {
pub fn is_input(&self) -> bool {
matches!(self, ChainNode::Input { .. })
⋮----
pub fn is_special(&self) -> bool {
matches!(self, ChainNode::Special { .. })
⋮----
pub fn to_block(&self) -> ProcessingBlock {
⋮----
id: id.clone(),
block_type: "input_adapter".to_string(),
⋮----
render_mode: render_mode.clone(),
⋮----
block_type: block_type.clone(),
model: model.clone(),
prompt: prompt.clone(),
selected_language: language_vars.get("language1").cloned().unwrap_or_default(),
language_vars: language_vars.clone(),
⋮----
pub fn from_block(block: &ProcessingBlock, role: &str) -> Self {
let mut language_vars = block.language_vars.clone();
if !language_vars.contains_key("language1") && !block.selected_language.is_empty() {
language_vars.insert("language1".to_string(), block.selected_language.clone());
⋮----
id: block.id.clone(),
block_type: block.block_type.clone(),
⋮----
render_mode: block.render_mode.clone(),
⋮----
model: block.model.clone(),
prompt: block.prompt.clone(),
⋮----
pub fn id(&self) -> &str {
⋮----
pub fn set_auto_copy(&mut self, val: bool) {
</file>

<file path="src/model_config.rs">
pub enum ModelType {
⋮----
pub struct ModelConfig {
⋮----
impl ModelConfig {
pub fn new(
⋮----
id: id.to_string(),
provider: provider.to_string(),
name_vi: name_vi.to_string(),
name_ko: name_ko.to_string(),
name_en: name_en.to_string(),
full_name: full_name.to_string(),
⋮----
quota_limit_vi: quota_limit_vi.to_string(),
quota_limit_ko: quota_limit_ko.to_string(),
quota_limit_en: quota_limit_en.to_string(),
⋮----
pub fn model_is_non_llm(model_id: &str) -> bool {
⋮----
pub fn get_all_models() -> &'static [ModelConfig] {
⋮----
pub fn get_model_by_id(id: &str) -> Option<ModelConfig> {
get_all_models().iter().find(|m| m.id == id).cloned()
⋮----
/// Get all models including dynamically fetched Ollama models
/// This combines static models with Ollama models (if Ollama is enabled)
⋮----
/// This combines static models with Ollama models (if Ollama is enabled)
pub fn get_all_models_with_ollama() -> Vec<ModelConfig> {
⋮----
pub fn get_all_models_with_ollama() -> Vec<ModelConfig> {
let mut models: Vec<ModelConfig> = ALL_MODELS.iter().cloned().collect();
// Add cached Ollama models
let cached = OLLAMA_MODEL_CACHE.lock().unwrap();
for ollama_model in cached.iter() {
models.push(ollama_model.clone());
⋮----
// === OLLAMA MODEL CACHE ===
⋮----
/// Cached Ollama models (populated by background scan)
    static ref OLLAMA_MODEL_CACHE: Mutex<Vec<ModelConfig>> = Mutex::new(Vec::new());
/// Whether a scan is currently in progress
    static ref OLLAMA_SCAN_IN_PROGRESS: AtomicBool = AtomicBool::new(false);
/// Last scan time (for debouncing) - initialized to 10s ago so first scan works immediately
    static ref OLLAMA_LAST_SCAN: Mutex<std::time::Instant> = Mutex::new(
⋮----
/// Check if Ollama model scan is in progress
pub fn is_ollama_scan_in_progress() -> bool {
⋮----
pub fn is_ollama_scan_in_progress() -> bool {
OLLAMA_SCAN_IN_PROGRESS.load(Ordering::SeqCst)
⋮----
/// Trigger background scan for Ollama models (non-blocking)
/// Returns immediately, models will be populated in cache when ready
⋮----
/// Returns immediately, models will be populated in cache when ready
pub fn trigger_ollama_model_scan() {
⋮----
pub fn trigger_ollama_model_scan() {
// Check if Ollama is enabled
let (use_ollama, base_url) = if let Ok(app) = crate::APP.lock() {
(app.config.use_ollama, app.config.ollama_base_url.clone())
⋮----
// Debounce: don't scan more than once per 5 seconds
⋮----
let last_scan = OLLAMA_LAST_SCAN.lock().unwrap();
if last_scan.elapsed().as_secs() < 5 {
⋮----
if OLLAMA_SCAN_IN_PROGRESS.swap(true, Ordering::SeqCst) {
⋮----
let mut last_scan = OLLAMA_LAST_SCAN.lock().unwrap();
⋮----
let model_id = format!(
⋮----
let display_name = format!("{} (Local)", ollama_model.name);
⋮----
new_models.push(ModelConfig {
id: format!("{}-vision", model_id),
provider: "ollama".to_string(),
name_vi: display_name.clone(),
name_ko: display_name.clone(),
name_en: display_name.clone(),
full_name: ollama_model.name.clone(),
⋮----
quota_limit_vi: "Không giới hạn".to_string(),
quota_limit_ko: "무제한".to_string(),
quota_limit_en: "Unlimited".to_string(),
⋮----
let mut cache = OLLAMA_MODEL_CACHE.lock().unwrap();
⋮----
OLLAMA_SCAN_IN_PROGRESS.store(false, Ordering::SeqCst);
</file>

<file path="src/overlay/favorite_bubble/render.rs">
use std::sync::atomic::Ordering;
⋮----
pub fn update_bubble_visual(hwnd: HWND) {
⋮----
let hdc_screen = GetDC(None);
let hdc_mem = CreateCompatibleDC(Some(hdc_screen));
⋮----
CreateDIBSection(Some(hdc_mem), &bmi, DIB_RGB_COLORS, &mut bits, None, 0).unwrap();
let old_bm = SelectObject(hdc_mem, hbm.into());
if !bits.is_null() {
⋮----
let is_hovered = IS_HOVERED.load(Ordering::SeqCst);
let is_expanded = IS_EXPANDED.load(Ordering::SeqCst);
draw_bubble_pixels(pixels, BUBBLE_SIZE, is_hovered || is_expanded);
⋮----
let _ = GetWindowRect(hwnd, &mut rect);
⋮----
let _ = UpdateLayeredWindow(
⋮----
Some(hdc_screen),
Some(&pt_dst),
Some(&size),
Some(hdc_mem),
Some(&pt_src),
COLORREF(0),
Some(&blend),
⋮----
let _ = SelectObject(hdc_mem, old_bm);
let _ = DeleteObject(hbm.into());
let _ = DeleteDC(hdc_mem);
let _ = ReleaseDC(None, hdc_screen);
⋮----
fn draw_bubble_pixels(pixels: &mut [u32], size: i32, _is_active: bool) {
let opacity = CURRENT_OPACITY.load(Ordering::SeqCst);
let icon_data = if LAST_THEME_IS_DARK.load(Ordering::SeqCst) {
⋮----
if !icon_data.is_empty() {
⋮----
if src_idx + 3 < icon_data.len() {
⋮----
let dist = (dx * dx + dy * dy).sqrt();
</file>

<file path="src/overlay/html_components/css_main.rs">
pub fn get(glow_color: &str, font_size: u32) -> String {
format!(
</file>

<file path="src/overlay/html_components/mod.rs">
pub mod css_main;
pub mod css_modals;
pub mod font_manager;
pub mod grid_js;
pub mod icons;
pub mod js_logic;
pub mod js_main;
</file>

<file path="src/overlay/preset_wheel/mod.rs">
mod html;
mod window;
</file>

<file path="src/overlay/realtime_egui.rs">
use crate::APP;
use eframe::egui;
⋮----
use std::sync::Mutex;
⋮----
struct RealtimeUiState {
⋮----
impl Default for RealtimeUiState {
fn default() -> Self {
⋮----
pub fn show_realtime_egui_overlay(preset_idx: usize) {
if MINIMAL_ACTIVE.load(Ordering::SeqCst) || unsafe { IS_ACTIVE } {
⋮----
REALTIME_STOP_SIGNAL.store(false, Ordering::SeqCst);
MIC_VISIBLE.store(true, Ordering::SeqCst);
TRANS_VISIBLE.store(true, Ordering::SeqCst);
AUDIO_SOURCE_CHANGE.store(false, Ordering::SeqCst);
LANGUAGE_CHANGE.store(false, Ordering::SeqCst);
TRANSLATION_MODEL_CHANGE.store(false, Ordering::SeqCst);
⋮----
let mut state = REALTIME_STATE.lock().unwrap();
⋮----
LAST_SPOKEN_LENGTH.store(0, Ordering::SeqCst);
REALTIME_TTS_ENABLED.store(false, Ordering::SeqCst);
SELECTED_APP_PID.store(0, Ordering::SeqCst);
if let Ok(mut name) = SELECTED_APP_NAME.lock() { name.clear(); }
if let Ok(mut queue) = COMMITTED_TRANSLATION_QUEUE.lock() { queue.clear(); }
USER_REQUESTED_CLOSE.store(false, Ordering::SeqCst);
MINIMAL_ACTIVE.store(true, Ordering::SeqCst);
MINIMAL_PRESET_IDX.store(preset_idx, Ordering::SeqCst);
let app = APP.lock().unwrap();
let preset = app.config.presets[preset_idx].clone();
⋮----
let config_language = app.config.realtime_target_language.clone();
let config_audio_source = app.config.realtime_audio_source.clone();
drop(app);
⋮----
if let Ok(mut ui_state) = UI_STATE.lock() {
⋮----
ui_state.apps_list.clear();
⋮----
ui_state.committed_segments.clear();
⋮----
let effective_source = if config_audio_source.is_empty() { "mic".to_string() } else { config_audio_source };
if let Ok(mut new_source) = NEW_AUDIO_SOURCE.lock() {
*new_source = effective_source.clone();
⋮----
if !config_language.is_empty() {
if let Ok(mut new_lang) = NEW_TARGET_LANGUAGE.lock() {
*new_lang = config_language.clone();
⋮----
LANGUAGE_CHANGE.store(true, Ordering::SeqCst);
⋮----
let mut final_preset = preset.clone();
⋮----
start_realtime_transcription(
⋮----
REALTIME_STOP_SIGNAL.clone(),
⋮----
Some(windows::Win32::Foundation::HWND::default()),
REALTIME_STATE.clone(),
⋮----
if let Ok(guard) = crate::gui::GUI_CONTEXT.lock() {
if let Some(ctx) = guard.as_ref() {
ctx.request_repaint();
⋮----
pub fn render_minimal_overlay(ctx: &egui::Context) {
if !MINIMAL_ACTIVE.load(Ordering::SeqCst) {
⋮----
if USER_REQUESTED_CLOSE.load(Ordering::SeqCst) {
MINIMAL_ACTIVE.store(false, Ordering::SeqCst);
⋮----
REALTIME_STOP_SIGNAL.store(true, Ordering::SeqCst);
crate::api::tts::TTS_MANAGER.stop();
⋮----
let mut ui_state = UI_STATE.lock().unwrap();
let ui_language = APP.lock().map(|a| a.config.ui_language.clone()).unwrap_or_else(|_| "en".to_string());
⋮----
ctx.show_viewport_immediate(
⋮----
.with_inner_size([700.0, 200.0])
.with_title(title)
.with_always_on_top(),
⋮----
if ctx.input(|i| i.viewport().close_requested()) {
USER_REQUESTED_CLOSE.store(true, Ordering::SeqCst);
⋮----
egui::CentralPanel::default().show(ctx, |ui| {
render_main_ui(ui, &mut ui_state);
⋮----
fn render_main_ui(ui: &mut egui::Ui, state: &mut RealtimeUiState) {
let current_source = NEW_AUDIO_SOURCE.lock().map(|s| s.clone()).unwrap_or_else(|_| "mic".to_string());
⋮----
let app_pid = SELECTED_APP_PID.load(Ordering::SeqCst);
let tts_enabled = REALTIME_TTS_ENABLED.load(Ordering::SeqCst);
⋮----
ui.horizontal(|ui| {
⋮----
ui.label(egui::RichText::new(locale.device_mode_warning)
.color(egui::Color32::from_rgb(255, 180, 100)).size(11.0));
if ui.small_button(locale.select_app_btn).clicked() {
⋮----
if state.apps_list.is_empty() {
⋮----
ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
if ui.selectable_label(state.show_translation, "🌐").on_hover_text(locale.toggle_translation_tooltip).clicked() {
⋮----
TRANS_VISIBLE.store(state.show_translation, Ordering::SeqCst);
⋮----
if ui.selectable_label(state.show_transcription, "📝").on_hover_text(locale.toggle_transcription_tooltip).clicked() {
⋮----
MIC_VISIBLE.store(state.show_transcription, Ordering::SeqCst);
⋮----
ui.separator();
if ui.small_button("➖").on_hover_text(locale.font_minus_tooltip).clicked() {
state.font_size = (state.font_size - 2.0).max(10.0);
if let Ok(mut app) = APP.lock() {
⋮----
if ui.small_button("➕").on_hover_text(locale.font_plus_tooltip).clicked() {
state.font_size = (state.font_size + 2.0).min(40.0);
⋮----
if ui.small_button(tts_label).on_hover_text(locale.tts_settings_title).clicked() {
⋮----
let current_model = APP.lock().map(|a| a.config.realtime_translation_model.clone()).unwrap_or_default();
let model_label = match current_model.as_str() {
⋮----
ui.menu_button(model_label, |ui| {
if ui.selectable_label(current_model == "groq-llama", "⚡ Groq").clicked() {
if let Ok(mut m) = NEW_TRANSLATION_MODEL.lock() { *m = "groq-llama".to_string(); }
TRANSLATION_MODEL_CHANGE.store(true, Ordering::SeqCst);
if let Ok(mut app) = APP.lock() { app.config.realtime_translation_model = "groq-llama".to_string(); }
ui.close();
⋮----
if ui.selectable_label(current_model == "google-gemma", "✨ Gemma").clicked() {
if let Ok(mut m) = NEW_TRANSLATION_MODEL.lock() { *m = "google-gemma".to_string(); }
⋮----
if let Ok(mut app) = APP.lock() { app.config.realtime_translation_model = "google-gemma".to_string(); }
⋮----
if ui.selectable_label(current_model == "google-gtx", format!("🌍 {}", locale.google_gtx_label)).clicked() {
if let Ok(mut m) = NEW_TRANSLATION_MODEL.lock() { *m = "google-gtx".to_string(); }
⋮----
if let Ok(mut app) = APP.lock() { app.config.realtime_translation_model = "google-gtx".to_string(); }
⋮----
let current_lang = NEW_TARGET_LANGUAGE.lock().map(|l| if l.is_empty() { "English".to_string() } else { l.clone() }).unwrap_or_else(|_| "English".to_string());
⋮----
.and_then(|l| l.to_639_1())
.map(|c| c.to_uppercase())
.unwrap_or_else(|| current_lang.chars().take(2).collect::<String>().to_uppercase());
let btn_resp = ui.button(&lang_code);
if btn_resp.clicked() {
egui::Popup::toggle_id(ui.ctx(), btn_resp.id);
⋮----
.close_behavior(egui::PopupCloseBehavior::CloseOnClickOutside)
.show(|ui| {
ui.set_min_width(120.0);
⋮----
let mut search_text: String = ui.data_mut(|d| d.get_temp(search_id).unwrap_or_default());
let response = ui.add(egui::TextEdit::singleline(&mut search_text).hint_text("Search...").desired_width(120.0));
if response.changed() {
ui.data_mut(|d| d.insert_temp(search_id, search_text.clone()));
⋮----
if response.clicked() {
response.request_focus();
⋮----
egui::ScrollArea::vertical().max_height(250.0).show(ui, |ui| {
⋮----
let matches = search_text.is_empty() || lang.to_lowercase().contains(&search_text.to_lowercase());
⋮----
if ui.selectable_label(current_lang == *lang, lang).clicked() {
if let Ok(mut l) = NEW_TARGET_LANGUAGE.lock() { *l = lang.to_string(); }
⋮----
if let Ok(mut app) = APP.lock() { app.config.realtime_target_language = lang.to_string(); }
ui.data_mut(|d| d.remove_temp::<String>(search_id));
egui::Popup::toggle_id(ui.ctx(), popup_id);
⋮----
if ui.selectable_label(!is_device_mode, "🎤").on_hover_text(locale.audio_src_mic).clicked() {
if let Ok(mut s) = NEW_AUDIO_SOURCE.lock() { *s = "mic".to_string(); }
⋮----
AUDIO_SOURCE_CHANGE.store(true, Ordering::SeqCst);
if let Ok(mut app) = APP.lock() { app.config.realtime_audio_source = "mic".to_string(); }
⋮----
if ui.selectable_label(is_device_mode, "🔊").on_hover_text(locale.audio_src_device).clicked() {
⋮----
ui.add_enabled_ui(can_enable_tts, |ui| {
if ui.checkbox(&mut tts_on, "TTS").changed() {
⋮----
REALTIME_TTS_ENABLED.store(true, Ordering::SeqCst);
⋮----
let current_speed = CURRENT_TTS_SPEED.load(Ordering::Relaxed);
let base_speed = REALTIME_TTS_SPEED.load(Ordering::Relaxed);
let auto_speed = REALTIME_TTS_AUTO_SPEED.load(Ordering::Relaxed);
ui.label(format!("{:.1}x", current_speed as f32 / 100.0));
⋮----
if ui.add(egui::Slider::new(&mut speed_val, 50..=200).show_value(false)).changed() {
REALTIME_TTS_SPEED.store(speed_val as u32, Ordering::SeqCst);
REALTIME_TTS_AUTO_SPEED.store(false, Ordering::SeqCst);
⋮----
if ui.checkbox(&mut auto_on, locale.realtime_tts_auto).changed() {
REALTIME_TTS_AUTO_SPEED.store(auto_on, Ordering::SeqCst);
⋮----
ui.label(egui::RichText::new(locale.app_select_title).strong().size(11.0));
if ui.small_button("🔄").clicked() {
⋮----
if ui.small_button("✖").clicked() {
⋮----
let selected_name = SELECTED_APP_NAME.lock().map(|n| n.clone()).unwrap_or_default();
if !selected_name.is_empty() {
ui.label(egui::RichText::new(format!("✓ {}", selected_name)).color(egui::Color32::GREEN).size(10.0));
⋮----
egui::ScrollArea::vertical().max_height(80.0).id_salt("app_list").show(ui, |ui| {
for (pid, name) in state.apps_list.clone() {
⋮----
let display = if name.chars().count() > 40 {
format!("{}...", name.chars().take(37).collect::<String>())
⋮----
name.clone()
⋮----
if ui.selectable_label(is_selected, &display).clicked() {
SELECTED_APP_PID.store(pid, Ordering::SeqCst);
if let Ok(mut app_name) = SELECTED_APP_NAME.lock() {
*app_name = name.clone();
⋮----
*new_source = "device".to_string();
⋮----
let state_data = REALTIME_STATE.lock().unwrap();
⋮----
if state.show_translation && TRANS_VISIBLE.load(Ordering::SeqCst) {
⋮----
let old_len = committed.len();
let is_mic_mode = current_source.is_empty() || current_source == "mic";
⋮----
let current_tts_enabled = REALTIME_TTS_ENABLED.load(Ordering::SeqCst);
if current_tts_enabled && tts_allowed && !committed.is_empty() {
⋮----
let text = committed.trim_end();
let search_limit = text.len().saturating_sub(1);
⋮----
if let Some(idx) = text[..search_limit].rfind(|c| c == '.' || c == '?' || c == '!' || c == '\n') {
⋮----
let new_committed = committed[state.last_spoken_len..].to_string();
if !new_committed.trim().is_empty() {
if let Ok(mut queue) = COMMITTED_TRANSLATION_QUEUE.lock() {
queue.push_back(new_committed.clone());
⋮----
crate::api::tts::TTS_MANAGER.speak_realtime(&text_to_speak, 0);
⋮----
state_data.full_transcript.clone(),
⋮----
state_data.committed_translation.clone(),
state_data.uncommitted_translation.clone(),
⋮----
drop(state_data);
let available_height = ui.available_height();
let rect = ui.ctx().input(|i| i.viewport().inner_rect);
let current_window_size = rect.map(|r| r.size()).unwrap_or(egui::Vec2::ZERO);
let current_len = committed_translation.len();
⋮----
state.committed_segments.clear();
⋮----
let new_segment = committed_translation[state.last_committed_len..].to_string();
state.committed_segments.push(new_segment);
⋮----
let window_resized = (current_window_size - state.prev_window_size).length() > 1.0;
⋮----
let has_content = !committed_translation.is_empty() || !uncommitted_translation.is_empty();
⋮----
let available_width = ui.available_width();
⋮----
let content_height = available_height.max(50.0);
⋮----
ui.vertical(|ui| {
ui.set_width(col_width);
ui.set_min_height(content_height);
⋮----
.id_salt("trans_scroll")
.auto_shrink([false, false])
.stick_to_bottom(true)
.show(ui, |ui| {
render_transcript(ui, &full_transcript, last_committed_pos, &font);
⋮----
.id_salt("transl_scroll")
⋮----
render_translation(ui, &state.committed_segments, &uncommitted_translation, &font);
⋮----
ui.scroll_to_cursor(Some(egui::Align::BOTTOM));
⋮----
.id_salt("trans_full")
⋮----
.id_salt("transl_full")
⋮----
fn render_transcript(ui: &mut egui::Ui, full: &str, split_pos: usize, font: &egui::FontId) {
let split_idx = split_pos.min(full.len());
let split_idx = if full.is_char_boundary(split_idx) { split_idx } else {
full.char_indices().take_while(|(i, _)| *i < split_idx).last().map(|(i, c)| i + c.len_utf8()).unwrap_or(0)
⋮----
let committed = full[..split_idx].trim_end();
let uncommitted = full[split_idx..].trim_start();
let dark_mode = ui.visuals().dark_mode;
ui.horizontal_wrapped(|ui| {
ui.spacing_mut().item_spacing.x = 0.0;
if !committed.is_empty() {
ui.label(egui::RichText::new(committed).font(font.clone()).color(get_text_color(true, dark_mode)));
⋮----
if !uncommitted.is_empty() {
if !committed.is_empty() { ui.label(" "); }
⋮----
ui.label(egui::RichText::new(uncommitted).font(font.clone()).color(color).italics());
⋮----
fn render_translation(ui: &mut egui::Ui, segments: &[String], uncommitted: &str, font: &egui::FontId) {
let uncommitted = uncommitted.trim_start();
⋮----
for (i, segment) in segments.iter().enumerate() {
let color = get_segment_color(i, dark_mode);
ui.label(egui::RichText::new(segment).font(font.clone()).color(color));
⋮----
fn tr(key: &str, lang: &str) -> String {
⋮----
"device_mode_warning" => "⚠ Đã chọn âm thanh thiết bị nhưng chưa chọn ứng dụng".to_string(),
"select_app" => "Chọn ứng dụng".to_string(),
"toggle_translation" => "Tắt/Mở dịch".to_string(),
"toggle_transcription" => "Tắt/Mở phụ đề".to_string(),
"font_minus" => "Giảm cỡ chữ".to_string(),
"font_plus" => "Tăng cỡ chữ".to_string(),
"tts_settings" => "Cài đặt đọc văn bản (TTS)".to_string(),
"microphone" => "Microphone".to_string(),
"system_audio" => "Âm thanh hệ thống".to_string(),
"select_app_title" => "🎧 Chọn ứng dụng để thu âm".to_string(),
"auto" => "Tự động".to_string(),
_ => key.to_string(),
⋮----
"device_mode_warning" => "⚠ Device audio selected but no app chosen".to_string(),
"select_app" => "Select App".to_string(),
"toggle_translation" => "Toggle Translation".to_string(),
"toggle_transcription" => "Toggle Transcription".to_string(),
"font_minus" => "Font -".to_string(),
"font_plus" => "Font +".to_string(),
"tts_settings" => "TTS Settings".to_string(),
⋮----
"system_audio" => "System Audio".to_string(),
"select_app_title" => "🎧 Select App to Record".to_string(),
"auto" => "Auto".to_string(),
⋮----
fn get_segment_color(index: usize, dark_mode: bool) -> egui::Color32 {
⋮----
fn get_text_color(is_committed: bool, dark_mode: bool) -> egui::Color32 {
</file>

<file path="src/overlay/realtime_webview/manager.rs">
use crate::APP;
use std::sync::atomic::Ordering;
use windows::core::w;
⋮----
use windows::Win32::Graphics::Gdi::HBRUSH;
use windows::Win32::System::LibraryLoader::GetModuleHandleW;
⋮----
pub fn is_realtime_overlay_active() -> bool {
unsafe { IS_ACTIVE && !std::ptr::addr_of!(REALTIME_HWND).read().is_invalid() }
⋮----
pub fn stop_realtime_overlay() {
crate::api::tts::TTS_MANAGER.stop();
crate::overlay::realtime_egui::MINIMAL_ACTIVE.store(false, std::sync::atomic::Ordering::SeqCst);
REALTIME_STOP_SIGNAL.store(true, Ordering::SeqCst);
⋮----
let popup_val = APP_SELECTION_HWND.load(std::sync::atomic::Ordering::SeqCst);
⋮----
let popup_hwnd = HWND(popup_val as *mut std::ffi::c_void);
let _ = PostMessageW(Some(popup_hwnd), WM_CLOSE, WPARAM(0), LPARAM(0));
APP_SELECTION_HWND.store(0, std::sync::atomic::Ordering::SeqCst);
⋮----
if !std::ptr::addr_of!(REALTIME_HWND).read().is_invalid() {
let _ = PostMessageW(Some(REALTIME_HWND), WM_CLOSE, WPARAM(0), LPARAM(0));
⋮----
pub fn show_realtime_overlay(preset_idx: usize) {
⋮----
let mut preset = APP.lock().unwrap().config.presets[preset_idx].clone();
⋮----
REALTIME_STOP_SIGNAL.store(false, Ordering::SeqCst);
MIC_VISIBLE.store(true, Ordering::SeqCst);
TRANS_VISIBLE.store(true, Ordering::SeqCst);
AUDIO_SOURCE_CHANGE.store(false, Ordering::SeqCst);
LANGUAGE_CHANGE.store(false, Ordering::SeqCst);
TRANSLATION_MODEL_CHANGE.store(false, Ordering::SeqCst);
⋮----
let mut state = REALTIME_STATE.lock().unwrap();
⋮----
let instance = GetModuleHandleW(None).unwrap();
let class_name = w!("RealtimeWebViewOverlay");
REGISTER_REALTIME_CLASS.call_once(|| {
⋮----
wc.lpfnWndProc = Some(realtime_wnd_proc);
wc.hInstance = instance.into();
wc.hCursor = LoadCursorW(None, IDC_ARROW).unwrap();
⋮----
wc.hbrBackground = HBRUSH(std::ptr::null_mut());
let _ = RegisterClassW(&wc);
⋮----
let app = APP.lock().unwrap();
⋮----
app.config.realtime_audio_source.clone(),
app.config.realtime_target_language.clone(),
app.config.realtime_translation_model.clone(),
⋮----
if !config_audio_source.is_empty() {
preset.audio_source = config_audio_source.clone();
⋮----
let target_language = if !config_language.is_empty() {
⋮----
} else if preset.blocks.len() > 1 {
⋮----
if !trans_block.selected_language.is_empty() {
trans_block.selected_language.clone()
⋮----
.get("language")
.cloned()
.or_else(|| trans_block.language_vars.get("language1").cloned())
.unwrap_or_else(|| "English".to_string())
⋮----
"English".to_string()
⋮----
if let Ok(mut new_source) = NEW_AUDIO_SOURCE.lock() {
*new_source = config_audio_source.clone();
⋮----
if !target_language.is_empty() {
if let Ok(mut new_lang) = NEW_TARGET_LANGUAGE.lock() {
*new_lang = target_language.clone();
⋮----
LANGUAGE_CHANGE.store(true, Ordering::SeqCst);
⋮----
let screen_w = GetSystemMetrics(SM_CXSCREEN);
let screen_h = GetSystemMetrics(SM_CYSCREEN);
let has_translation = preset.blocks.len() > 1;
⋮----
let main_hwnd = CreateWindowExW(
⋮----
w!("Realtime Transcription"),
⋮----
Some(instance.into()),
⋮----
.unwrap();
⋮----
let _ = DwmSetWindowAttribute(
⋮----
create_realtime_webview(
⋮----
let trans_class = w!("RealtimeTranslationWebViewOverlay");
REGISTER_TRANSLATION_CLASS.call_once(|| {
⋮----
wc.lpfnWndProc = Some(translation_wnd_proc);
⋮----
let trans_hwnd = CreateWindowExW(
⋮----
w!("Translation"),
⋮----
Some(trans_hwnd)
⋮----
start_realtime_transcription(
⋮----
REALTIME_STOP_SIGNAL.clone(),
⋮----
REALTIME_STATE.clone(),
⋮----
while GetMessageW(&mut msg, None, 0, 0).into() {
let _ = TranslateMessage(&msg);
DispatchMessageW(&msg);
⋮----
destroy_realtime_webview(REALTIME_HWND);
if !std::ptr::addr_of!(TRANSLATION_HWND).read().is_invalid() {
destroy_realtime_webview(TRANSLATION_HWND);
</file>

<file path="src/overlay/realtime_webview/webview.rs">
use crate::config::get_all_languages;
use crate::gui::locale::LocaleText;
use crate::overlay::realtime_html::get_realtime_html;
use crate::APP;
use std::sync::atomic::Ordering;
⋮----
use windows::Win32::UI::Input::KeyboardAndMouse::ReleaseCapture;
⋮----
pub fn create_realtime_webview(
⋮----
let _ = GetClientRect(hwnd, &mut rect);
⋮----
let languages = get_all_languages();
⋮----
let app = APP.lock().unwrap();
let lang = app.config.ui_language.clone();
⋮----
let html = get_realtime_html(
⋮----
let wrapper = HwndWrapper(hwnd);
⋮----
REALTIME_WEB_CONTEXT.with(|ctx| {
if ctx.borrow().is_none() {
⋮----
*ctx.borrow_mut() = Some(wry::WebContext::new(Some(shared_data_dir)));
⋮----
let result = REALTIME_WEB_CONTEXT.with(|ctx| {
let mut ctx_ref = ctx.borrow_mut();
let builder = if let Some(web_ctx) = ctx_ref.as_mut() {
⋮----
.with_bounds(Rect {
⋮----
.with_html(&html)
.with_transparent(false)
.with_ipc_handler(move |msg: wry::http::Request<String>| {
let body = msg.body();
⋮----
let _ = ReleaseCapture();
SendMessageW(
⋮----
Some(WPARAM(HTCAPTION as usize)),
Some(LPARAM(0)),
⋮----
} else if body.starts_with("groupDragMove:") {
⋮----
if let Some((dx_str, dy_str)) = coords.split_once(',') {
⋮----
if !std::ptr::addr_of!(REALTIME_HWND).read().is_invalid() {
⋮----
let _ = GetWindowRect(REALTIME_HWND, &mut rect);
let _ = SetWindowPos(
⋮----
if !std::ptr::addr_of!(TRANSLATION_HWND).read().is_invalid() {
⋮----
let _ = GetWindowRect(TRANSLATION_HWND, &mut rect);
⋮----
} else if body.starts_with("copyText:") {
⋮----
let _ = PostMessageW(Some(hwnd_for_ipc), WM_CLOSE, WPARAM(0), LPARAM(0));
⋮----
let _ = GetWindowRect(hwnd_for_ipc, &mut rect);
⋮----
let mut app = APP.lock().unwrap();
⋮----
} else if body.starts_with("fontSize:") {
⋮----
} else if body.starts_with("audioSource:") {
let source = body[12..].to_string();
if let Ok(mut new_source) = NEW_AUDIO_SOURCE.lock() {
*new_source = source.clone();
⋮----
SELECTED_APP_PID.store(0, Ordering::SeqCst);
if let Ok(mut name) = SELECTED_APP_NAME.lock() {
name.clear();
⋮----
let tts_enabled = REALTIME_TTS_ENABLED.load(Ordering::SeqCst);
⋮----
show_app_selection_popup();
⋮----
AUDIO_SOURCE_CHANGE.store(true, Ordering::SeqCst);
} else if body.starts_with("language:") {
let lang = body[9..].to_string();
if let Ok(mut new_lang) = NEW_TARGET_LANGUAGE.lock() {
*new_lang = lang.clone();
⋮----
LANGUAGE_CHANGE.store(true, Ordering::SeqCst);
} else if body.starts_with("translationModel:") {
let model = body[17..].to_string();
if let Ok(mut new_model) = NEW_TRANSLATION_MODEL.lock() {
*new_model = model.clone();
⋮----
TRANSLATION_MODEL_CHANGE.store(true, Ordering::SeqCst);
} else if body.starts_with("resize:") {
⋮----
let new_width = (rect.right - rect.left + dx).max(200);
let new_height = (rect.bottom - rect.top + dy).max(100);
⋮----
} else if body.starts_with("toggleMic:") {
⋮----
MIC_VISIBLE.store(visible, Ordering::SeqCst);
⋮----
ShowWindow(REALTIME_HWND, if visible { SW_SHOW } else { SW_HIDE });
⋮----
sync_visibility_to_webviews();
if !MIC_VISIBLE.load(Ordering::SeqCst)
&& !TRANS_VISIBLE.load(Ordering::SeqCst)
⋮----
REALTIME_STOP_SIGNAL.store(true, Ordering::SeqCst);
PostQuitMessage(0);
⋮----
let _ = PostMessageW(
Some(REALTIME_HWND),
⋮----
WPARAM(0),
LPARAM(0),
⋮----
} else if body.starts_with("toggleTrans:") {
⋮----
TRANS_VISIBLE.store(visible, Ordering::SeqCst);
⋮----
crate::api::tts::TTS_MANAGER.stop();
⋮----
let _ = ShowWindow(
⋮----
Some(TRANSLATION_HWND),
⋮----
} else if body.starts_with("ttsEnabled:") {
⋮----
REALTIME_TTS_ENABLED.store(enabled, Ordering::SeqCst);
⋮----
let popup_hwnd_val = APP_SELECTION_HWND.load(Ordering::SeqCst);
⋮----
Some(popup_hwnd),
⋮----
APP_SELECTION_HWND.store(0, Ordering::SeqCst);
⋮----
LAST_SPOKEN_LENGTH.store(0, Ordering::SeqCst);
if let Ok(mut queue) = COMMITTED_TRANSLATION_QUEUE.lock() {
queue.clear();
⋮----
app.config.realtime_audio_source.clone()
⋮----
} else if body.starts_with("ttsSpeed:") {
⋮----
REALTIME_TTS_SPEED.store(speed, Ordering::SeqCst);
REALTIME_TTS_AUTO_SPEED.store(false, Ordering::SeqCst);
⋮----
} else if body.starts_with("ttsAutoSpeed:") {
⋮----
REALTIME_TTS_AUTO_SPEED.store(enabled, Ordering::SeqCst);
⋮----
.build_as_child(&wrapper)
⋮----
REALTIME_WEBVIEWS.with(|wvs| {
wvs.borrow_mut().insert(hwnd_key, webview);
⋮----
pub fn destroy_realtime_webview(hwnd: HWND) {
⋮----
wvs.borrow_mut().remove(&hwnd_key);
⋮----
fn sync_visibility_to_webviews() {
let mic_vis = MIC_VISIBLE.load(Ordering::SeqCst);
let trans_vis = TRANS_VISIBLE.load(Ordering::SeqCst);
let script = format!(
⋮----
for webview in wvs.borrow().values() {
let _ = webview.evaluate_script(&script);
⋮----
pub fn update_webview_text(hwnd: HWND, old_text: &str, new_text: &str) {
⋮----
fn escape_js(text: &str) -> String {
text.replace('\\', "\\\\")
.replace('\'', "\\'")
.replace('\n', "\\n")
.replace('\r', "")
⋮----
let escaped_old = escape_js(old_text);
let escaped_new = escape_js(new_text);
let script = format!("window.updateText('{}', '{}');", escaped_old, escaped_new);
⋮----
if let Some(webview) = wvs.borrow().get(&hwnd_key) {
⋮----
use super::app_selection::show_app_selection_popup;
</file>

<file path="src/api/tts/manager.rs">
use super::utils;
use std::collections::VecDeque;
use std::sync::mpsc;
⋮----
pub struct TtsManager {
⋮----
impl TtsManager {
pub fn new() -> Self {
⋮----
pub fn _is_ready(&self) -> bool {
self._is_ready.load(Ordering::SeqCst)
⋮----
pub fn speak(&self, text: &str, hwnd: isize) -> u64 {
self.speak_internal(text, hwnd, false)
⋮----
pub fn speak_realtime(&self, text: &str, hwnd: isize) -> u64 {
self.speak_internal(text, hwnd, true)
⋮----
fn speak_internal(&self, text: &str, hwnd: isize, is_realtime: bool) -> u64 {
let id = REQUEST_ID_COUNTER.fetch_add(1, Ordering::SeqCst);
let current_gen = self.interrupt_generation.load(Ordering::SeqCst);
⋮----
let mut wq = self.work_queue.lock().unwrap();
wq.push_back((
⋮----
text: text.to_string(),
⋮----
self.work_signal.notify_one();
⋮----
let mut pq = self.playback_queue.lock().unwrap();
pq.push_back((rx, hwnd, id, current_gen, is_realtime));
⋮----
self.playback_signal.notify_one();
⋮----
pub fn speak_interrupt(&self, text: &str, hwnd: isize) -> u64 {
let new_gen = self.interrupt_generation.fetch_add(1, Ordering::SeqCst) + 1;
⋮----
wq.clear();
⋮----
pq.clear();
⋮----
pq.push_back((rx, hwnd, id, new_gen, false));
⋮----
pub fn stop(&self) {
self.interrupt_generation.fetch_add(1, Ordering::SeqCst);
⋮----
self.playback_signal.notify_all();
⋮----
pub fn stop_if_active(&self, _request_id: u64) {
self.stop();
⋮----
pub fn is_speaking(&self, _request_id: u64) -> bool {
⋮----
pub fn has_pending_audio(&self) -> bool {
if self.is_playing.load(Ordering::SeqCst) {
⋮----
.lock()
.map(|q| !q.is_empty())
.unwrap_or(false);
⋮----
pub fn _shutdown(&self) {
self.shutdown.store(true, Ordering::SeqCst);
⋮----
self.work_signal.notify_all();
⋮----
pub fn get_output_devices() -> Vec<(String, String)> {
</file>

<file path="src/config/mod.rs">
mod config;
mod io;
pub mod preset;
pub mod types;
pub use config::Config;
⋮----
pub use types::ThemeMode;
pub use types::Hotkey;
</file>

<file path="src/config/preset/defaults/audio.rs">
use crate::config::preset::Preset;
⋮----
pub fn create_audio_presets() -> Vec<Preset> {
vec![
</file>

<file path="src/config/preset/defaults/text.rs">
use crate::config::preset::Preset;
⋮----
pub fn create_text_presets() -> Vec<Preset> {
vec![
</file>

<file path="src/gui/app/input_handler.rs">
use crate::overlay::preset_wheel::show_preset_wheel;
⋮----
use crate::overlay::utils::get_clipboard_image_bytes;
use crate::APP;
use eframe::egui;
⋮----
use std::path::Path;
⋮----
use windows::Win32::UI::WindowsAndMessaging::GetCursorPos;
pub enum DroppedContent {
⋮----
fn is_image_extension(ext: &str) -> bool {
IMAGE_EXTENSIONS.contains(&ext.to_lowercase().as_str())
⋮----
fn is_text_extension(ext: &str) -> bool {
TEXT_EXTENSIONS.contains(&ext.to_lowercase().as_str())
⋮----
fn load_image_file(path: &Path) -> Option<ImageBuffer<Rgba<u8>, Vec<u8>>> {
let img = image::open(path).ok()?;
Some(img.to_rgba8())
⋮----
fn load_text_file(path: &Path) -> Option<String> {
std::fs::read_to_string(path).ok()
⋮----
fn load_file_content(path: &Path) -> Option<DroppedContent> {
let ext = path.extension()?.to_str()?;
if is_image_extension(ext) {
load_image_file(path).map(DroppedContent::Image)
} else if is_text_extension(ext) {
load_text_file(path).map(DroppedContent::Text)
⋮----
fn get_cursor_pos() -> POINT {
⋮----
let _ = GetCursorPos(&mut pos);
⋮----
fn get_screen_rect_at_cursor() -> RECT {
let pos = get_cursor_pos();
⋮----
fn process_image_content(img: ImageBuffer<Rgba<u8>, Vec<u8>>) {
let cursor_pos = get_cursor_pos();
let selected = show_preset_wheel("image", None, cursor_pos);
⋮----
let mut app = APP.lock().unwrap();
⋮----
(app.config.clone(), app.config.presets[preset_idx].clone())
⋮----
let rect = get_screen_rect_at_cursor();
⋮----
start_processing_pipeline(img, rect, config, preset);
⋮----
fn process_text_content(text: String) {
⋮----
let selected = show_preset_wheel("text", None, cursor_pos);
⋮----
let ui_lang = config.ui_language.clone();
⋮----
.first()
.map(|h| h.name.clone())
.unwrap_or_default();
⋮----
start_text_processing(text, rect, config, preset, localized_name, cancel_hotkey);
⋮----
pub fn handle_dropped_files(ctx: &egui::Context) -> bool {
let dropped_files = ctx.input(|i| i.raw.dropped_files.clone());
if dropped_files.is_empty() {
⋮----
if let Some(file) = dropped_files.first() {
⋮----
if let Some(content) = load_file_content(path) {
⋮----
process_image_content(img);
⋮----
process_text_content(text);
⋮----
let rgba = img.to_rgba8();
⋮----
process_image_content(rgba);
⋮----
if let Ok(text) = String::from_utf8(bytes.to_vec()) {
⋮----
pub fn is_files_hovered(ctx: &egui::Context) -> bool {
ctx.input(|i| !i.raw.hovered_files.is_empty())
⋮----
fn get_clipboard_text() -> Option<String> {
use windows::Win32::Foundation::HGLOBAL;
⋮----
if OpenClipboard(None).is_ok() {
if let Ok(h_data) = GetClipboardData(13) {
let ptr = GlobalLock(HGLOBAL(h_data.0));
if !ptr.is_null() {
⋮----
while *wide_ptr.add(len) != 0 {
⋮----
let _ = GlobalUnlock(HGLOBAL(h_data.0));
let _ = CloseClipboard();
if !text.is_empty() {
return Some(text);
⋮----
pub fn handle_paste(ctx: &egui::Context) -> bool {
⋮----
let has_focus = ctx.input(|i| i.focused);
⋮----
let ctrl_down = unsafe { (GetAsyncKeyState(VK_CONTROL.0 as i32) as u16 & 0x8000) != 0 };
let v_down = unsafe { (GetAsyncKeyState(VK_V.0 as i32) as u16 & 0x8000) != 0 };
let v_was_down = LAST_V_STATE.swap(v_down, Ordering::SeqCst);
⋮----
let paste_event = ctx.input(|i| {
⋮----
.iter()
.any(|e| matches!(e, egui::Event::Paste(_)))
⋮----
if let Some(img_bytes) = get_clipboard_image_bytes() {
⋮----
if let Some(text) = get_clipboard_text() {
</file>

<file path="src/gui/app/rendering.rs">
use super::types::SettingsApp;
use crate::gui::locale::LocaleText;
⋮----
use eframe::egui;
⋮----
impl SettingsApp {
pub(crate) fn render_footer_and_tips_modal(&mut self, ctx: &egui::Context) {
⋮----
let visuals = ctx.style().visuals.clone();
⋮----
.get(self.current_tip_idx)
.unwrap_or(&"")
.to_string();
⋮----
.resizable(false)
.show_separator_line(false)
.frame(
⋮----
.inner_margin(egui::Margin::symmetric(10, 4))
.fill(footer_bg),
⋮----
.show(ctx, |ui| {
render_footer(
⋮----
current_tip.clone(),
⋮----
let tips_list_copy = text.tips_list.clone();
⋮----
let screen_rect = ctx.input(|i| {
i.viewport().inner_rect.unwrap_or(egui::Rect::from_min_size(
⋮----
.order(egui::Order::Tooltip)
.anchor(egui::Align2::CENTER_CENTER, egui::vec2(0.0, 0.0))
⋮----
egui::Frame::popup(ui.style())
.inner_margin(egui::Margin::same(16))
.show(ui, |ui| {
ui.set_max_width(1000.0);
ui.set_max_height(550.0);
ui.horizontal(|ui| {
ui.heading(tips_title);
ui.with_layout(
⋮----
.clicked()
⋮----
ui.separator();
ui.add_space(8.0);
⋮----
.max_height(400.0)
.auto_shrink([false; 2])
⋮----
for (i, tip) in tips_list_copy.iter().enumerate() {
let is_dark_mode = ctx.style().visuals.dark_mode;
let layout_job = format_tip_with_bold(i + 1, tip, is_dark_mode);
ui.label(layout_job);
if i < tips_list_copy.len() - 1 {
⋮----
if ctx.input(|i| i.pointer.any_click()) {
if let Some(pos) = ctx.input(|i| i.pointer.interact_pos()) {
if let Some(layer) = ctx.layer_id_at(pos) {
⋮----
if ctx.input(|i| i.key_pressed(egui::Key::Escape)) {
⋮----
pub(crate) fn render_main_layout(&mut self, ctx: &egui::Context) {
⋮----
egui::CentralPanel::default().show(ctx, |ui| {
let available_width = ui.available_width();
⋮----
ui.allocate_ui_with_layout(
egui::vec2(left_width, ui.available_height()),
⋮----
if render_sidebar(ui, &mut self.config, &mut self.view_mode, &text) {
self.save_and_sync();
⋮----
ui.add_space(10.0);
⋮----
egui::vec2(right_width - 20.0, ui.available_height()),
⋮----
let app = self.app_state_ref.lock().unwrap();
app.model_usage_stats.clone()
⋮----
if render_global_settings(
⋮----
app.history.clone()
⋮----
if render_history_panel(
⋮----
if self.last_edited_preset_idx != Some(idx) {
if idx < self.config.presets.len() {
self.snarl = Some(blocks_to_snarl(
⋮----
self.last_edited_preset_idx = Some(idx);
⋮----
if render_preset_editor(
⋮----
let (blocks, connections) = snarl_to_graph(snarl);
⋮----
pub(crate) fn render_fade_overlay(&mut self, ctx: &egui::Context) {
⋮----
let elapsed = ctx.input(|i| i.time) - start_time;
⋮----
let rect = ctx.input(|i| {
⋮----
let painter = ctx.layer_painter(egui::LayerId::new(
⋮----
painter.rect_filled(
⋮----
ctx.request_repaint();
⋮----
pub(crate) fn render_drop_overlay(&mut self, ctx: &egui::Context) {
use super::input_handler::is_files_hovered;
⋮----
let delta = ctx.input(|i| i.stable_dt).min(0.1);
let is_hovered = is_files_hovered(ctx);
⋮----
self.drop_overlay_fade = self.drop_overlay_fade.clamp(0.0, 1.0);
⋮----
let screen_rect = ctx.available_rect();
⋮----
let painter = ctx.layer_painter(overlay_layer);
⋮----
painter.rect_filled(screen_rect, 0.0, backdrop_color);
⋮----
let inner_rect = screen_rect.shrink(inset);
let time = ctx.input(|i| i.time);
let pulse = (time * 2.5).sin() as f32 * 0.2_f32 + 0.8_f32;
⋮----
let len = vec.length();
⋮----
let count = (len / (dash_length + gap_length)).ceil() as i32;
⋮----
let end = if (end - p1).length() > len { p2 } else { end };
painter.line_segment([start, end], stroke);
⋮----
draw_dashed_line(inner_rect.left_top(), inner_rect.right_top());
draw_dashed_line(inner_rect.right_top(), inner_rect.right_bottom());
draw_dashed_line(inner_rect.right_bottom(), inner_rect.left_bottom());
draw_dashed_line(inner_rect.left_bottom(), inner_rect.left_top());
let center = screen_rect.center();
⋮----
let bob_offset = (time * 5.0).sin() as f32 * 4.0_f32;
⋮----
painter.rect_stroke(
⋮----
painter.line_segment([arrow_start, arrow_end], arrow_stroke);
⋮----
painter.line_segment(
⋮----
let galley = painter.layout_no_wrap(
text.drop_overlay_text.to_string(),
⋮----
painter.galley(
text_pos - egui::vec2(text_rect.width() * 0.5, 0.0),
⋮----
fn format_tip_with_bold(tip_number: usize, text: &str, is_dark_mode: bool) -> LayoutJob {
⋮----
let number_text = format!("{}. ", tip_number);
⋮----
job.append(&number_text, 0.0, text_format.clone());
⋮----
let mut chars = text.chars().peekable();
⋮----
while let Some(ch) = chars.next() {
if ch == '*' && chars.peek() == Some(&'*') {
chars.next();
if !current_text.is_empty() {
let mut fmt = text_format.clone();
⋮----
job.append(&current_text, 0.0, fmt);
current_text.clear();
⋮----
current_text.push(ch);
</file>

<file path="src/gui/settings_ui/global/update_section.rs">
use crate::gui::locale::LocaleText;
⋮----
use eframe::egui;
⋮----
pub fn render_update_section_content(
⋮----
ui.horizontal(|ui| {
let mut ver_string = format!(
⋮----
if cfg!(feature = "nopack") || cfg!(nopack) {
ver_string.push_str(" (NoPack)");
⋮----
ui.label(ver_string);
if ui.button(text.check_for_updates_btn).clicked() {
⋮----
u.check_for_updates();
⋮----
ui.spinner();
ui.label(text.checking_github);
⋮----
ui.label(
egui::RichText::new(format!("{} (v{})", text.up_to_date, ver))
.color(egui::Color32::from_rgb(34, 139, 34)),
⋮----
if ui.button(text.check_again_btn).clicked() {
⋮----
ui.colored_label(
⋮----
format!("{} {}", text.new_version_available, version),
⋮----
ui.collapsing(text.release_notes_label, |ui| {
ui.label(body);
⋮----
ui.add_space(5.0);
⋮----
.button(egui::RichText::new(text.download_update_btn).strong())
.clicked()
⋮----
u.perform_update();
⋮----
ui.label(text.downloading_update);
⋮----
ui.colored_label(egui::Color32::RED, format!("{} {}", text.update_failed, e));
ui.label(egui::RichText::new(text.app_folder_writable_hint).size(11.0));
if ui.button(text.retry_btn).clicked() {
⋮----
.color(egui::Color32::GREEN)
.heading(),
⋮----
ui.label(text.restart_to_use_new_version);
if ui.button(text.restart_app_btn).clicked() {
⋮----
if let Some(exe_dir) = exe_path.parent() {
⋮----
.filter_map(|e| e.ok())
.filter(|e| {
let name = e.file_name();
let name_str = name.to_string_lossy();
name_str.starts_with("ScreenGoatedToolbox_v")
&& name_str.ends_with(".exe")
⋮----
.max_by_key(|e| e.metadata().ok().and_then(|m| m.modified().ok()))
⋮----
let path = newest_exe.path();
println!("Attempting to spawn with delay: {:?}", path);
let kill_mutex_cmd = format!("timeout /t 2 /nobreak > NUL");
⋮----
format!("start \"\" \"{}\"", path.to_string_lossy());
⋮----
let batch_content = format!(
⋮----
.join(format!("sgt_restart_{}.bat", std::process::id()));
println!("Writing batch file to: {:?}", bat_path);
⋮----
.args(["/C", &bat_path.to_string_lossy()])
.spawn();
⋮----
eprintln!("Failed to spawn batch file: {}", e);
⋮----
eprintln!("Failed to write batch file");
</file>

<file path="src/overlay/auto_copy_badge.rs">
use crate::APP;
use std::cell::RefCell;
⋮----
use windows::Win32::Graphics::Dwm::DwmExtendFrameIntoClientArea;
⋮----
use windows::Win32::UI::Controls::MARGINS;
⋮----
use crate::win_types::SendHwnd;
⋮----
static mut BADGE_HWND: SendHwnd = SendHwnd(HWND(std::ptr::null_mut()));
⋮----
thread_local! {
⋮----
struct HwndWrapper(HWND);
unsafe impl Send for HwndWrapper {}
unsafe impl Sync for HwndWrapper {}
⋮----
fn window_handle(
⋮----
std::num::NonZeroIsize::new(self.0 .0 as isize).expect("HWND cannot be null"),
⋮----
unsafe { Ok(raw_window_handle::WindowHandle::borrow_raw(handle)) }
⋮----
pub fn is_active() -> bool {
⋮----
!std::ptr::addr_of!(BADGE_HWND).read().is_invalid()
&& IsWindowVisible(BADGE_HWND.0).as_bool()
⋮----
pub fn show_auto_copy_badge_text(text: &str) {
*PENDING_CONTENT.lock().unwrap() = text.to_string();
ensure_window_and_post(WM_APP_SHOW_TEXT);
⋮----
pub fn show_auto_copy_badge_image() {
ensure_window_and_post(WM_APP_SHOW_IMAGE);
⋮----
fn ensure_window_and_post(msg: u32) {
⋮----
if std::ptr::addr_of!(BADGE_HWND).read().is_invalid() {
warmup();
⋮----
let hwnd = std::ptr::addr_of!(BADGE_HWND).read().0;
if !hwnd.is_invalid() {
let _ = PostMessageW(Some(hwnd), msg, WPARAM(0), LPARAM(0));
⋮----
pub fn warmup() {
⋮----
internal_create_window_loop();
⋮----
fn get_badge_html() -> String {
⋮----
format!(
⋮----
fn internal_create_window_loop() {
⋮----
let instance = GetModuleHandleW(None).unwrap();
let class_name = w!("SGT_AutoCopyBadgeWebView");
REGISTER_BADGE_CLASS.call_once(|| {
⋮----
wc.lpfnWndProc = Some(badge_wnd_proc);
wc.hInstance = instance.into();
wc.hCursor = LoadCursorW(None, IDC_ARROW).unwrap();
⋮----
wc.hbrBackground = HBRUSH(std::ptr::null_mut());
let _ = RegisterClassW(&wc);
⋮----
let hwnd = CreateWindowExW(
⋮----
w!("SGT AutoCopy Badge"),
⋮----
Some(instance.into()),
⋮----
.unwrap_or_default();
BADGE_HWND = SendHwnd(hwnd);
⋮----
let _ = DwmExtendFrameIntoClientArea(hwnd, &margins);
let wrapper = HwndWrapper(hwnd);
BADGE_WEB_CONTEXT.with(|ctx| {
if ctx.borrow().is_none() {
⋮----
*ctx.borrow_mut() = Some(WebContext::new(Some(shared_data_dir)));
⋮----
let webview = BADGE_WEB_CONTEXT.with(|ctx| {
let mut ctx_ref = ctx.borrow_mut();
let builder = if let Some(web_ctx) = ctx_ref.as_mut() {
⋮----
.with_transparent(true)
.with_bounds(Rect {
⋮----
.with_html(&get_badge_html())
.with_ipc_handler(move |msg: wry::http::Request<String>| {
let body = msg.body();
⋮----
let _ = ShowWindow(hwnd, SW_HIDE);
⋮----
.build(&wrapper)
⋮----
BADGE_WEBVIEW.with(|cell| {
*cell.borrow_mut() = Some(wv);
⋮----
while GetMessageW(&mut msg, None, 0, 0).into() {
let _ = TranslateMessage(&msg);
DispatchMessageW(&msg);
⋮----
BADGE_HWND = SendHwnd(HWND(std::ptr::null_mut()));
⋮----
unsafe extern "system" fn badge_wnd_proc(
⋮----
let app = APP.lock().unwrap();
let ui_lang = app.config.ui_language.clone();
⋮----
let text = PENDING_CONTENT.lock().unwrap().clone();
let clean_text = text.replace('\n', " ").replace('\r', "");
format!("\"{}\"", clean_text)
⋮----
locale.auto_copied_image_badge.to_string()
⋮----
drop(app);
let screen_w = GetSystemMetrics(SM_CXSCREEN);
let screen_h = GetSystemMetrics(SM_CYSCREEN);
⋮----
let _ = SetWindowPos(
⋮----
Some(HWND_TOPMOST),
⋮----
BADGE_WEBVIEW.with(|wv| {
if let Some(webview) = wv.borrow().as_ref() {
// 1. Update theme
let theme_script = format!("window.setTheme({});", is_dark);
let _ = webview.evaluate_script(&theme_script);
// 2. Show content
⋮----
.replace('\\', "\\\\")
.replace('"', "\\\"")
.replace('\'', "\\'");
⋮----
let script = format!("window.show('{}', '{}');", safe_title, safe_snippet);
let _ = webview.evaluate_script(&script);
⋮----
LRESULT(0)
⋮----
PostQuitMessage(0);
⋮----
WM_ERASEBKGND => LRESULT(1),
_ => DefWindowProcW(hwnd, msg, wparam, lparam),
</file>

<file path="src/overlay/html_components/font_manager.rs">
use std::net::TcpListener;
⋮----
use windows::Win32::Graphics::Gdi::AddFontMemResourceEx;
use wry::WebViewBuilder;
⋮----
include_bytes!("../../../assets/GoogleSansFlex-VariableFont_GRAD,ROND,opsz,slnt,wdth,wght.ttf");
⋮----
pub fn warmup_fonts() {
start_font_server();
load_gdi_font();
⋮----
fn load_gdi_font() {
⋮----
let len = GOOGLE_SANS_FLEX_TTF.len() as u32;
let handle = AddFontMemResourceEx(
GOOGLE_SANS_FLEX_TTF.as_ptr() as *mut _,
⋮----
if handle.is_invalid() {
eprintln!("Failed to load Google Sans Flex into GDI");
⋮----
pub fn configure_webview(builder: WebViewBuilder) -> WebViewBuilder {
⋮----
fn start_font_server() {
INIT_FONTS.call_once(|| {
⋮----
eprintln!("Failed to bind font server: {}", e);
⋮----
let addr = listener.local_addr().unwrap();
let url = format!("http://{}:{}/GoogleSansFlex.ttf", addr.ip(), addr.port());
⋮----
let mut url_guard = FONT_SERVER_URL.lock().unwrap();
*url_guard = Some(url);
⋮----
for stream in listener.incoming() {
⋮----
let _ = stream.read(&mut buffer);
let response_header = format!(
⋮----
if let Err(e) = stream.write_all(response_header.as_bytes()) {
eprintln!("Font server write error: {}", e);
⋮----
if let Err(e) = stream.write_all(GOOGLE_SANS_FLEX_TTF) {
eprintln!("Font server body error: {}", e);
⋮----
let _ = stream.flush();
⋮----
Err(e) => eprintln!("Font server request error: {}", e),
⋮----
pub fn get_font_css() -> String {
⋮----
if let Ok(guard) = FONT_SERVER_URL.lock() {
if let Some(url) = guard.as_ref() {
font_url = url.clone();
⋮----
if font_url.is_empty() {
eprintln!("ERROR: Could not get font server URL");
⋮----
format!(
</file>

<file path="src/overlay/process/pipeline.rs">
use crate::win_types::SendHwnd;
⋮----
use crate::overlay::preset_wheel;
⋮----
use crate::overlay::text_input;
⋮----
use super::types::reset_window_position_queue;
use super::window::create_processing_window;
pub fn start_text_processing(
⋮----
.first()
.map(|b| b.prompt.as_str())
.unwrap_or("");
let guide_text = if first_block_prompt.is_empty() {
⋮----
format!("{}...", localized_preset_name)
⋮----
let config_shared = Arc::new(config.clone());
let preset_shared = Arc::new(preset.clone());
let ui_lang = config.ui_language.clone();
// For MASTER presets: always keep window open initially (continuous_mode=true)
// We'll decide whether to close based on the SELECTED preset after wheel selection
⋮----
// For continuous mode: store the previous chain's cancellation token so we can close old windows
⋮----
let last_cancel_token_clone = last_cancel_token.clone();
// Check if this is a MASTER preset
⋮----
// CRITICAL: For MASTER presets, store the selected preset index after first wheel selection.
// Subsequent Enter presses will use this stored preset directly (no wheel).
// The text input window "transfers" to the selected preset.
⋮----
let selected_preset_idx_clone = selected_preset_idx.clone();
⋮----
let already_selected = selected_preset_idx_clone.lock().unwrap().clone();
⋮----
let app = crate::APP.lock().unwrap();
let p = app.config.presets[preset_idx].clone();
let c = app.config.clone();
⋮----
let _ = GetCursorPos(&mut cursor_pos);
⋮----
preset_wheel::show_preset_wheel("text", Some("type"), cursor_pos);
⋮----
*selected_preset_idx_clone.lock().unwrap() = Some(idx);
⋮----
let mut app = crate::APP.lock().unwrap();
⋮----
let p = app.config.presets[idx].clone();
⋮----
.map(|h| h.name.clone())
.unwrap_or_default();
let new_guide_text = if !hk_name.is_empty() {
format!("{} [{}]", localized_name, hk_name)
⋮----
(*preset_shared).clone(),
(*config_shared).clone(),
⋮----
let _ = PostMessageW(Some(input_hwnd), WM_CLOSE, WPARAM(0), LPARAM(0));
⋮----
if let Ok(token_guard) = last_cancel_token_clone.lock() {
⋮----
let last_token_update = last_cancel_token_clone.clone();
⋮----
if let Ok(mut token_guard) = last_token_update.lock() {
*token_guard = Some(new_token.clone());
⋮----
execute_chain_pipeline_with_token(
⋮----
let guide_text = localized_preset_name.clone();
⋮----
let mut modified_preset = (*preset).clone();
if let Some(block0) = modified_preset.blocks.get_mut(0) {
if block0.prompt.is_empty() {
block0.prompt = user_prompt.clone();
⋮----
format!("{}\n\nUser request: {}", block0.prompt, user_prompt);
⋮----
let config_clone = (*config).clone();
let initial_text_clone = (*initial_text).clone();
⋮----
execute_chain_pipeline(
⋮----
pub fn show_audio_result(
⋮----
app.config.clone()
⋮----
windows::Win32::UI::WindowsAndMessaging::IsWindow(Some(recording_hwnd)).as_bool()
⋮----
Some(recording_hwnd)
⋮----
reset_window_position_queue();
run_chain_step(
⋮----
preset.blocks.clone(),
preset.block_connections.clone(),
⋮----
processing_hwnd.map(SendHwnd),
⋮----
preset.id.clone(),
⋮----
pub fn start_processing_pipeline(
⋮----
if preset.prompt_mode == "dynamic" && !preset.blocks.is_empty() {
⋮----
let _ = cropped_img.write_to(
⋮----
let guide_text = format!("{}...", localized_name);
⋮----
.iter_mut()
.find(|b| b.block_type != "input_adapter")
⋮----
if target_block.prompt.is_empty() {
target_block.prompt = user_prompt.clone();
⋮----
format!("{}\n\nUser request: {}", target_block.prompt, user_prompt);
⋮----
let context = RefineContext::Image((*png_data).clone());
⋮----
let graphics_mode = config_clone.graphics_mode.clone();
⋮----
unsafe { create_processing_window(screen_rect, graphics_mode) };
⋮----
SendMessageW(processing_hwnd, WM_TIMER, Some(WPARAM(1)), Some(LPARAM(0)));
⋮----
let blocks = modified_preset.blocks.clone();
let connections = modified_preset.block_connections.clone();
let preset_id = modified_preset.id.clone();
let processing_hwnd_send = SendHwnd(processing_hwnd);
⋮----
Some(processing_hwnd_send),
⋮----
while GetMessageW(&mut msg, None, 0, 0).into() {
let _ = TranslateMessage(&msg);
DispatchMessageW(&msg);
if !IsWindow(Some(processing_hwnd)).as_bool() {
⋮----
let graphics_mode = config.graphics_mode.clone();
let processing_hwnd = unsafe { create_processing_window(screen_rect, graphics_mode) };
⋮----
let _ = SendMessageW(processing_hwnd, WM_TIMER, Some(WPARAM(1)), Some(LPARAM(0)));
⋮----
let conf_clone = config.clone();
let blocks = preset.blocks.clone();
let connections = preset.block_connections.clone();
let preset_id = preset.id.clone();
⋮----
let processing_hwnd = HWND(processing_hwnd_val as *mut std::ffi::c_void);
⋮----
Some(SendHwnd(processing_hwnd)),
</file>

<file path="src/overlay/realtime_webview/app_selection.rs">
use std::collections::HashMap;
use std::sync::Mutex;
⋮----
use windows::Win32::System::LibraryLoader::GetModuleHandleW;
⋮----
use windows::Win32::UI::Shell::ExtractIconExW;
⋮----
fn get_process_exe_path(pid: u32) -> Option<String> {
⋮----
let handle = OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, false, pid).ok()?;
⋮----
let mut size = buffer.len() as u32;
let result = QueryFullProcessImageNameW(
⋮----
windows::core::PWSTR(buffer.as_mut_ptr()),
⋮----
if result.is_ok() && size > 0 {
Some(String::from_utf16_lossy(&buffer[..size as usize]))
⋮----
fn extract_icon_as_base64(exe_path: &str) -> Option<String> {
⋮----
let wide_path: Vec<u16> = exe_path.encode_utf16().chain(std::iter::once(0)).collect();
⋮----
let count = ExtractIconExW(
windows::core::PCWSTR(wide_path.as_ptr()),
⋮----
Some(&mut large_icon),
⋮----
if count == 0 || large_icon.is_invalid() {
⋮----
if GetIconInfo(large_icon, &mut icon_info).is_err() {
let _ = DestroyIcon(large_icon);
⋮----
if GetObjectW(
icon_info.hbmColor.into(),
⋮----
Some(&mut bmp as *mut _ as *mut std::ffi::c_void),
⋮----
let _ = DeleteObject(icon_info.hbmMask.into());
let _ = DeleteObject(icon_info.hbmColor.into());
⋮----
let hdc_screen = GetDC(None);
let hdc_mem = CreateCompatibleDC(Some(hdc_screen));
⋮----
let mut pixels = vec![0u8; (width * height * 4) as usize];
let lines = GetDIBits(
⋮----
Some(pixels.as_mut_ptr() as *mut std::ffi::c_void),
⋮----
let _ = DeleteDC(hdc_mem);
let _ = ReleaseDC(None, hdc_screen);
⋮----
for i in (0..pixels.len()).step_by(4) {
pixels.swap(i, i + 2);
⋮----
for i in (3..pixels.len()).step_by(4) {
⋮----
.write_to(
⋮----
.is_err()
⋮----
use base64::Engine;
Some(base64::engine::general_purpose::STANDARD.encode(&png_data))
⋮----
fn get_app_icon(pid: u32) -> Option<String> {
⋮----
let cache = ICON_CACHE.lock().ok()?;
if let Some(cached) = cache.get(&pid) {
return cached.clone();
⋮----
let icon = get_process_exe_path(pid).and_then(|path| extract_icon_as_base64(&path));
if let Ok(mut cache) = ICON_CACHE.lock() {
cache.insert(pid, icon.clone());
⋮----
pub fn enumerate_audio_apps() -> Vec<(u32, String)> {
⋮----
extern "system" fn enum_callback(hwnd: HWND, lparam: LPARAM) -> windows_core::BOOL {
⋮----
if !IsWindowVisible(hwnd).as_bool() {
⋮----
let len = GetWindowTextW(hwnd, &mut title_buf);
⋮----
if title.is_empty() || title == "Program Manager" || title == "Settings" {
⋮----
GetWindowThreadProcessId(hwnd, Some(&mut pid));
⋮----
if seen_pids.contains(&pid) {
⋮----
seen_pids.insert(pid);
⋮----
apps.push((pid, title));
⋮----
let _ = EnumWindows(
Some(enum_callback),
LPARAM(&mut callback_data as *mut _ as isize),
⋮----
apps.sort_by(|a, b| a.1.to_lowercase().cmp(&b.1.to_lowercase()));
⋮----
pub fn show_app_selection_popup() {
use crate::gui::locale::LocaleText;
use crate::APP;
use std::sync::atomic::Ordering;
⋮----
let app = APP.lock().unwrap();
let lang = app.config.ui_language.clone();
⋮----
let apps = enumerate_audio_apps();
if apps.is_empty() {
eprintln!("No audio apps found for selection");
⋮----
.iter()
.map(|(pid, name)| {
⋮----
.replace('\\', "\\\\")
.replace('"', "\\\"")
.replace('<', "&lt;")
.replace('>', "&gt;");
let short_name = if escaped_name.chars().count() > 50 {
let truncated: String = escaped_name.chars().take(47).collect();
format!("{}...", truncated)
⋮----
escaped_name.clone()
⋮----
let icon_html = if let Some(base64_icon) = get_app_icon(*pid) {
format!(
⋮----
.collect();
// Get local font CSS (cached fonts, no network loading)
⋮----
let html = format!(
⋮----
let class_name = w!("AppSelectPopup");
let h_instance = GetModuleHandleW(None).unwrap_or_default();
⋮----
lpfnWndProc: Some(app_select_wndproc),
hInstance: h_instance.into(),
hCursor: LoadCursorW(None, IDC_ARROW).unwrap_or_default(),
hbrBackground: HBRUSH(GetStockObject(BLACK_BRUSH).0),
⋮----
RegisterClassExW(&wc);
let screen_width = GetSystemMetrics(SM_CXSCREEN);
let screen_height = GetSystemMetrics(SM_CYSCREEN);
⋮----
let hwnd = CreateWindowExW(
⋮----
w!("Select App"),
⋮----
Some(h_instance.into()),
⋮----
.unwrap();
APP_SELECTION_HWND.store(hwnd.0 as isize, Ordering::SeqCst);
⋮----
let _ = DwmSetWindowAttribute(
⋮----
let html_clone = html.clone();
⋮----
let mut web_context = wry::WebContext::new(Some(shared_data_dir));
⋮----
.with_bounds(wry::Rect {
⋮----
.with_html(&html_clone)
.with_transparent(true)
.with_ipc_handler(move |req| {
let body = req.body();
if body.starts_with("selectApp:") {
⋮----
if let Some((pid_str, name)) = rest.split_once(':') {
⋮----
SELECTED_APP_PID.store(pid, Ordering::SeqCst);
if let Ok(mut app_name) = SELECTED_APP_NAME.lock() {
*app_name = name.to_string();
⋮----
if let Ok(mut new_source) = NEW_AUDIO_SOURCE.lock() {
*new_source = "device".to_string();
⋮----
AUDIO_SOURCE_CHANGE.store(true, Ordering::SeqCst);
let hwnd = HWND(hwnd_val as *mut std::ffi::c_void);
let _ = ShowWindow(hwnd, SW_HIDE);
let _ = PostMessageW(Some(hwnd), WM_CLOSE, WPARAM(0), LPARAM(0));
if !std::ptr::addr_of!(TRANSLATION_HWND).read().is_invalid() {
let _ = PostMessageW(
Some(TRANSLATION_HWND),
⋮----
WPARAM(0),
LPARAM(0),
⋮----
.build_as_child(&HwndWrapper(hwnd));
if result.is_err() {
eprintln!("Failed to create WebView for app selection");
let _ = DestroyWindow(hwnd);
⋮----
let _webview = result.unwrap();
⋮----
while GetMessageW(&mut msg, None, 0, 0).as_bool() {
let _ = TranslateMessage(&msg);
DispatchMessageW(&msg);
⋮----
pub unsafe extern "system" fn app_select_wndproc(
⋮----
LRESULT(0)
⋮----
APP_SELECTION_HWND.store(0, std::sync::atomic::Ordering::SeqCst);
PostQuitMessage(0);
⋮----
if let Ok(child) = GetWindow(hwnd, GW_CHILD) {
⋮----
let _ = MoveWindow(child, 0, 0, width, height, true);
⋮----
_ => DefWindowProcW(hwnd, msg, wparam, lparam),
</file>

<file path="src/overlay/recording.rs">
use crate::win_types::SendHwnd;
use crate::APP;
⋮----
static mut RECORDING_HWND: SendHwnd = SendHwnd(HWND(std::ptr::null_mut()));
static mut RECORDING_HOOK: HHOOK = HHOOK(std::ptr::null_mut());
⋮----
pub fn update_audio_viz(rms: f32) {
let bits = rms.to_bits();
CURRENT_RMS.store(bits, Ordering::Relaxed);
⋮----
pub fn is_recording_overlay_active() -> bool {
unsafe { IS_RECORDING && !std::ptr::addr_of!(RECORDING_HWND).read().is_invalid() }
⋮----
pub fn stop_recording_and_submit() {
⋮----
if IS_RECORDING && !std::ptr::addr_of!(RECORDING_HWND).read().is_invalid() {
AUDIO_STOP_SIGNAL.store(true, Ordering::SeqCst);
let _ = PostMessageW(Some(RECORDING_HWND.0), WM_TIMER, WPARAM(0), LPARAM(0));
⋮----
pub fn show_recording_overlay(preset_idx: usize) {
⋮----
let preset = APP.lock().unwrap().config.presets[preset_idx].clone();
⋮----
AUDIO_STOP_SIGNAL.store(false, Ordering::SeqCst);
AUDIO_PAUSE_SIGNAL.store(false, Ordering::SeqCst);
AUDIO_ABORT_SIGNAL.store(false, Ordering::SeqCst);
AUDIO_WARMUP_COMPLETE.store(false, Ordering::SeqCst);
⋮----
if let Ok(mut buffer) = VISUALIZATION_BUFFER.lock() {
buffer.fill(0.0);
⋮----
let instance = GetModuleHandleW(None).unwrap();
let class_name = w!("RecordingOverlay");
REGISTER_RECORDING_CLASS.call_once(|| {
⋮----
wc.lpfnWndProc = Some(recording_wnd_proc);
wc.hInstance = instance.into();
wc.hCursor = LoadCursorW(None, IDC_ARROW).unwrap();
⋮----
let _ = RegisterClassW(&wc);
⋮----
let screen_x = GetSystemMetrics(SM_CXSCREEN);
let screen_y = GetSystemMetrics(SM_CYSCREEN);
⋮----
let hwnd = CreateWindowExW(
⋮----
w!("SGT Recording"),
⋮----
Some(instance.into()),
⋮----
.unwrap_or_default();
RECORDING_HWND = SendHwnd(hwnd);
let hook = SetWindowsHookExW(
⋮----
Some(recording_hook_proc),
Some(GetModuleHandleW(None).unwrap().into()),
⋮----
SetTimer(Some(hwnd), 1, 16, None);
⋮----
paint_layered_window(hwnd, UI_WIDTH, UI_HEIGHT, 0);
let _ = ShowWindow(hwnd, SW_SHOWNOACTIVATE);
⋮----
let hwnd = HWND(hwnd_val as *mut std::ffi::c_void);
⋮----
AUDIO_STOP_SIGNAL.clone(),
AUDIO_PAUSE_SIGNAL.clone(),
AUDIO_ABORT_SIGNAL.clone(),
⋮----
while GetMessageW(&mut msg, None, 0, 0).as_bool() {
let _ = TranslateMessage(&msg);
let _ = DispatchMessageW(&msg);
⋮----
let hook = std::ptr::addr_of!(RECORDING_HOOK).read();
if !hook.is_invalid() {
let _ = UnhookWindowsHookEx(hook);
RECORDING_HOOK = HHOOK(std::ptr::null_mut());
⋮----
unsafe extern "system" fn recording_hook_proc(
⋮----
let is_rec = std::ptr::addr_of!(IS_RECORDING).read();
let hwnd = std::ptr::addr_of!(RECORDING_HWND).read();
if is_rec && !hwnd.0.is_invalid() {
stop_recording_and_submit();
return LRESULT(1);
⋮----
CallNextHookEx(None, code, wparam, lparam)
⋮----
unsafe fn paint_layered_window(hwnd: HWND, width: i32, height: i32, alpha: u8) {
let screen_dc = GetDC(None);
⋮----
let bitmap = CreateDIBSection(
Some(screen_dc),
⋮----
.unwrap();
let mem_dc = CreateCompatibleDC(Some(screen_dc));
let old_bitmap = SelectObject(mem_dc, bitmap.into());
let is_processing = AUDIO_STOP_SIGNAL.load(Ordering::SeqCst);
let warmup_complete = AUDIO_WARMUP_COMPLETE.load(Ordering::SeqCst);
⋮----
if !p_bits.is_null() {
⋮----
let time_rad = ANIMATION_OFFSET.to_radians();
⋮----
let angle = py.atan2(px);
⋮----
(angle * 10.0 - time_rad * 8.0).sin() * 0.5
⋮----
(angle * 2.0 + time_rad * 3.0).sin() * 0.2
⋮----
let glow_t = (d.max(0.0) / glow_width).clamp(0.0, 1.0);
let glow_intensity = (1.0 - glow_t).powi(2);
⋮----
let hue = (angle.to_degrees() + hue_offset).rem_euclid(360.0);
⋮----
let r = ((fill_r + glow_r) / final_alpha * 0.40).min(255.0) as u32;
let g = ((fill_g + glow_g) / final_alpha * 0.40).min(255.0) as u32;
let b = ((fill_b + glow_b) / final_alpha * 0.40).min(255.0) as u32;
⋮----
let outer_corner_radius = (corner_radius + glow_width * 0.5).min(by - 2.0);
⋮----
let t = (d / glow_width).clamp(0.0, 1.0);
let mut glow_intensity = (1.0 - t).powi(2);
⋮----
let outer_fade = ((-d_outer) / 1.5).clamp(0.0, 1.0);
⋮----
let t = ((d - aa_half) / (2.0 - aa_half)).clamp(0.0, 1.0);
⋮----
let buffer = VISUALIZATION_BUFFER.lock().unwrap();
⋮----
let h = (amp * 400.0).clamp(4.0, 40.0);
⋮----
if (dy as f32).abs() <= max_y + 0.8 {
⋮----
let dist1 = (dx - dy).abs() * 0.7071;
let dist2 = (dx + dy).abs() * 0.7071;
⋮----
SetBkMode(mem_dc, TRANSPARENT);
SetTextColor(mem_dc, COLORREF(0x00FFFFFF));
let hfont_main = CreateFontW(
⋮----
w!("Google Sans Flex"),
⋮----
let old_font = SelectObject(mem_dc, hfont_main.into());
⋮----
let app = crate::APP.lock().unwrap();
let lang = app.config.ui_language.as_str();
⋮----
DrawTextW(
⋮----
let _ = SelectObject(mem_dc, old_font);
let _ = DeleteObject(hfont_main.into());
⋮----
let hfont_sub = CreateFontW(
⋮----
SelectObject(mem_dc, hfont_sub.into());
SetTextColor(mem_dc, COLORREF(0x00DDDDDD));
⋮----
let _ = DeleteObject(hfont_sub.into());
⋮----
let _ = GdiFlush();
⋮----
for px in pixels.iter_mut() {
⋮----
let max_c = r.max(g).max(b);
⋮----
let _ = UpdateLayeredWindow(
⋮----
Some(HDC::default()),
⋮----
Some(&size),
Some(mem_dc),
Some(&pt_src),
COLORREF(0),
Some(&blend),
⋮----
let _ = SelectObject(mem_dc, old_bitmap);
let _ = DeleteObject(bitmap.into());
let _ = DeleteDC(mem_dc);
let _ = ReleaseDC(None, screen_dc);
⋮----
unsafe extern "system" fn recording_wnd_proc(
⋮----
SetCursor(Some(LoadCursorW(None, IDC_APPSTARTING).unwrap()));
⋮----
SetCursor(Some(LoadCursorW(None, IDC_HAND).unwrap()));
⋮----
LRESULT(1)
⋮----
DefWindowProcW(hwnd, msg, wparam, lparam)
⋮----
let _ = GetWindowRect(hwnd, &mut rect);
⋮----
if (local_x - center_right).abs() < HIT_RADIUS {
return LRESULT(HTCLIENT as isize);
⋮----
if (local_x - center_left).abs() < HIT_RADIUS {
⋮----
LRESULT(HTCAPTION as isize)
⋮----
if (x - center_right).abs() < HIT_RADIUS {
AUDIO_ABORT_SIGNAL.store(true, Ordering::SeqCst);
⋮----
let _ = PostMessageW(Some(hwnd), WM_CLOSE, WPARAM(0), LPARAM(0));
⋮----
if (x - center_left).abs() < HIT_RADIUS {
⋮----
AUDIO_PAUSE_SIGNAL.store(IS_PAUSED, Ordering::SeqCst);
paint_layered_window(hwnd, UI_WIDTH, UI_HEIGHT, CURRENT_ALPHA as u8);
⋮----
LRESULT(0)
⋮----
let rms_bits = CURRENT_RMS.load(Ordering::Relaxed);
⋮----
let _ = DestroyWindow(hwnd);
PostQuitMessage(0);
⋮----
_ => DefWindowProcW(hwnd, msg, wparam, lparam),
</file>

<file path="src/overlay/text_selection.rs">
use crate::APP;
⋮----
struct TextSelectionState {
⋮----
unsafe impl Send for TextSelectionState {}
⋮----
hwnd: HWND(std::ptr::null_mut()),
⋮----
cached_bitmap: HBITMAP(std::ptr::null_mut()),
⋮----
cached_font: HFONT(std::ptr::null_mut()),
⋮----
hook_handle: HHOOK(std::ptr::null_mut()),
⋮----
pub fn is_active() -> bool {
!SELECTION_STATE.lock().unwrap().hwnd.is_invalid()
⋮----
pub fn try_instant_process(preset_idx: usize) -> bool {
⋮----
let original_clipboard = get_clipboard_text();
if OpenClipboard(Some(HWND::default())).is_ok() {
let _ = EmptyClipboard();
let _ = CloseClipboard();
⋮----
wVk: VIRTUAL_KEY(vk),
⋮----
SendInput(&[input], std::mem::size_of::<INPUT>() as i32);
⋮----
send_input_event(VK_CONTROL.0, KEYBD_EVENT_FLAGS(0));
⋮----
send_input_event(0x43, KEYBD_EVENT_FLAGS(0));
⋮----
send_input_event(0x43, KEYEVENTF_KEYUP);
⋮----
send_input_event(VK_CONTROL.0, KEYEVENTF_KEYUP);
⋮----
clipboard_text = get_clipboard_text();
if !clipboard_text.is_empty() {
⋮----
if clipboard_text.trim().is_empty() {
if !original_clipboard.is_empty() {
⋮----
process_selected_text(preset_idx, clipboard_text);
⋮----
unsafe fn get_clipboard_text() -> String {
⋮----
if let Ok(h_data) = GetClipboardData(13u32) {
⋮----
let ptr = GlobalLock(h_global);
if !ptr.is_null() {
let size = GlobalSize(h_global);
⋮----
if let Some(end) = wide_slice.iter().position(|&c| c == 0) {
⋮----
let _ = GlobalUnlock(h_global);
⋮----
fn process_selected_text(preset_idx: usize, clipboard_text: String) {
⋮----
let app = APP.lock().unwrap();
⋮----
(p.is_master, p.text_input_mode.clone())
⋮----
let _ = GetCursorPos(&mut cursor_pos);
⋮----
super::preset_wheel::show_preset_wheel("text", Some("select"), cursor_pos);
⋮----
let mut app = APP.lock().unwrap();
⋮----
app.config.clone(),
app.config.presets[final_preset_idx].clone(),
GetSystemMetrics(SM_CXSCREEN),
GetSystemMetrics(SM_CYSCREEN),
⋮----
preset.text_input_mode = "select".to_string();
⋮----
.first()
.map(|h| h.name.clone())
.unwrap_or_default();
⋮----
pub fn cancel_selection() {
TAG_ABORT_SIGNAL.store(true, Ordering::SeqCst);
let hwnd = SELECTION_STATE.lock().unwrap().hwnd;
⋮----
if !hwnd.is_invalid() {
let _ = PostMessageW(Some(hwnd), WM_CLOSE, WPARAM(0), LPARAM(0));
⋮----
unsafe extern "system" fn keyboard_hook_proc(code: i32, wparam: WPARAM, lparam: LPARAM) -> LRESULT {
⋮----
return LRESULT(1);
⋮----
CallNextHookEx(None, code, wparam, lparam)
⋮----
pub fn show_text_selection_tag(preset_idx: usize) {
⋮----
let mut state = SELECTION_STATE.lock().unwrap();
if !state.hwnd.is_invalid() {
⋮----
TAG_ABORT_SIGNAL.store(false, Ordering::SeqCst);
if !state.cached_bitmap.is_invalid() {
let _ = DeleteObject(state.cached_bitmap.into());
⋮----
if !state.cached_font.is_invalid() {
let _ = DeleteObject(state.cached_font.into());
state.cached_font = HFONT(std::ptr::null_mut());
⋮----
let instance = GetModuleHandleW(None).unwrap();
let class_name = w!("SGT_TextTag");
REGISTER_TAG_CLASS.call_once(|| {
⋮----
wc.lpfnWndProc = Some(tag_wnd_proc);
wc.hInstance = instance.into();
wc.hCursor = LoadCursorW(None, IDC_ARROW).unwrap();
⋮----
let _ = RegisterClassW(&wc);
⋮----
let hwnd = CreateWindowExW(
⋮----
w!("SGT Tag"),
⋮----
Some(instance.into()),
⋮----
SELECTION_STATE.lock().unwrap().hwnd = hwnd;
⋮----
let hook = SetWindowsHookExW(
⋮----
Some(keyboard_hook_proc),
Some(GetModuleHandleW(None).unwrap().into()),
⋮----
SELECTION_STATE.lock().unwrap().hook_handle = h;
⋮----
let _ = ShowWindow(hwnd, SW_SHOWNOACTIVATE);
⋮----
while PeekMessageW(&mut msg, None, 0, 0, PM_REMOVE).into() {
⋮----
let _ = TranslateMessage(&msg);
DispatchMessageW(&msg);
⋮----
if TAG_ABORT_SIGNAL.load(Ordering::SeqCst) {
⋮----
if !state.hook_handle.is_invalid() {
let _ = UnhookWindowsHookEx(state.hook_handle);
⋮----
let _ = DestroyWindow(hwnd);
⋮----
let _ = GetCursorPos(&mut pt);
⋮----
let lbutton_down = (GetAsyncKeyState(VK_LBUTTON.0 as i32) as u16 & 0x8000) != 0;
⋮----
let hwnd_copy = HWND(hwnd_val as *mut std::ffi::c_void);
⋮----
if TAG_ABORT_SIGNAL.load(Ordering::Relaxed) {
⋮----
if !clipboard_text.trim().is_empty()
&& !TAG_ABORT_SIGNAL.load(Ordering::Relaxed)
⋮----
process_selected_text(preset_idx_for_thread, clipboard_text);
let _ = PostMessageW(Some(hwnd_copy), WM_CLOSE, WPARAM(0), LPARAM(0));
⋮----
paint_tag_window(
⋮----
let _ = DwmFlush();
⋮----
unsafe extern "system" fn tag_wnd_proc(
⋮----
PostQuitMessage(0);
LRESULT(0)
⋮----
_ => DefWindowProcW(hwnd, msg, wparam, lparam),
⋮----
unsafe fn paint_tag_window(
⋮----
let screen_dc = GetDC(None);
let mem_dc = CreateCompatibleDC(Some(screen_dc));
⋮----
if state.cached_lang.is_none() {
⋮----
state.cached_lang = Some(app.config.ui_language.clone());
⋮----
if state.cached_bitmap.is_invalid() {
⋮----
CreateDIBSection(Some(screen_dc), &bmi, DIB_RGB_COLORS, &mut p_bits, None, 0)
⋮----
if state.cached_font.is_invalid() {
state.cached_font = CreateFontW(
⋮----
FONT_CHARSET(DEFAULT_CHARSET.0 as u8),
FONT_OUTPUT_PRECISION(OUT_DEFAULT_PRECIS.0 as u8),
FONT_CLIP_PRECISION(CLIP_DEFAULT_PRECIS.0 as u8),
FONT_QUALITY(CLEARTYPE_QUALITY.0 as u8),
⋮----
w!("Google Sans Flex"),
⋮----
let old_bitmap = SelectObject(mem_dc, state.cached_bitmap.into());
if !state.cached_bits.is_null() {
⋮----
let time_rad = animation_offset.to_radians();
⋮----
let angle = py.atan2(px);
⋮----
(angle * 10.0 - time_rad * 8.0).sin() * 0.5
⋮----
(angle * 2.0 + time_rad * 3.0).sin() * 0.2
⋮----
let glow_t = (d.max(0.0) / glow_width).clamp(0.0, 1.0);
let glow_intensity = (1.0 - glow_t).powi(2);
let hue = (angle.to_degrees() + animation_offset * 2.0).rem_euclid(360.0);
⋮----
(glow_r / final_alpha + 0x10 as f32 * (1.0 - blend)).min(255.0) as u32;
⋮----
(glow_g / final_alpha + 0x10 as f32 * (1.0 - blend)).min(255.0) as u32;
⋮----
(glow_b / final_alpha + 0x10 as f32 * (1.0 - blend)).min(255.0) as u32;
⋮----
let t = (d / glow_width).clamp(0.0, 1.0);
let glow_intensity = (1.0 - t).powi(2);
⋮----
SetBkMode(mem_dc, TRANSPARENT);
SetTextColor(mem_dc, COLORREF(0x00FFFFFF));
let old_font = SelectObject(mem_dc, state.cached_font.into());
⋮----
match state.cached_lang.as_ref().unwrap().as_str() {
⋮----
DrawTextW(
⋮----
let _ = GdiFlush();
⋮----
for p in pxs.iter_mut() {
⋮----
let max_c = r.max(g).max(b);
⋮----
let _ = UpdateLayeredWindow(
⋮----
Some(&pt_dst),
Some(&size),
Some(mem_dc),
Some(&pt_src),
COLORREF(0),
Some(&bl),
⋮----
let _ = SelectObject(mem_dc, old_font.into());
let _ = SelectObject(mem_dc, old_bitmap.into());
let _ = DeleteDC(mem_dc);
ReleaseDC(None, screen_dc);
</file>

<file path="src/api/audio.rs">
use super::client::UREQ_AGENT;
use crate::config::Preset;
⋮----
use crate::APP;
use anyhow::Result;
⋮----
pub fn transcribe_audio_gemini<F>(
⋮----
if gemini_api_key.trim().is_empty() {
return Err(anyhow::anyhow!("NO_API_KEY:google"));
⋮----
let b64_audio = general_purpose::STANDARD.encode(&wav_data);
let url = format!(
⋮----
if !model.contains("gemma-3-27b-it") {
⋮----
.post(&url)
.set("x-goog-api-key", gemini_api_key)
.send_json(payload)
.map_err(|e| {
let err_str = e.to_string();
if err_str.contains("401") || err_str.contains("403") {
⋮----
let reader = BufReader::new(resp.into_reader());
for line in reader.lines() {
let line = line.map_err(|e| anyhow::anyhow!("Failed to read line: {}", e))?;
if line.starts_with("data: ") {
let json_str = &line["data: ".len()..];
if json_str.trim() == "[DONE]" {
⋮----
if let Some(candidates) = chunk_resp.get("candidates").and_then(|c| c.as_array()) {
if let Some(first_candidate) = candidates.first() {
⋮----
.get("content")
.and_then(|c| c.get("parts"))
.and_then(|p| p.as_array())
⋮----
if let Some(first_part) = parts.first() {
if let Some(text) = first_part.get("text").and_then(|t| t.as_str())
⋮----
full_content.push_str(text);
on_chunk(text);
⋮----
if full_content.is_empty() {
return Err(anyhow::anyhow!("No content received from Gemini Audio API"));
⋮----
Ok(full_content)
⋮----
fn upload_audio_to_whisper(
⋮----
let boundary = format!(
⋮----
body.extend_from_slice(format!("--{}\r\n", boundary).as_bytes());
body.extend_from_slice(b"Content-Disposition: form-data; name=\"model\"\r\n\r\n");
body.extend_from_slice(model.as_bytes());
body.extend_from_slice(b"\r\n");
⋮----
body.extend_from_slice(
⋮----
body.extend_from_slice(b"Content-Type: audio/wav\r\n\r\n");
body.extend_from_slice(&audio_data);
⋮----
body.extend_from_slice(format!("--{}--\r\n", boundary).as_bytes());
⋮----
.post("https://api.groq.com/openai/v1/audio/transcriptions")
.set("Authorization", &format!("Bearer {}", api_key))
.set(
⋮----
&format!("multipart/form-data; boundary={}", boundary),
⋮----
.send_bytes(&body);
⋮----
let body = resp.into_string().unwrap_or_default();
return Err(anyhow::anyhow!("Groq API Error {}: {}", code, body));
⋮----
return Err(anyhow::anyhow!("API request failed: {}", e));
⋮----
if let Some(remaining) = response.header("x-ratelimit-remaining-requests") {
let limit = response.header("x-ratelimit-limit-requests").unwrap_or("?");
let usage_str = format!("{} / {}", remaining, limit);
if let Ok(mut app) = APP.lock() {
app.model_usage_stats.insert(model.to_string(), usage_str);
⋮----
.into_json()
.map_err(|e| anyhow::anyhow!("Failed to parse response: {}", e))?;
⋮----
.get("text")
.and_then(|t| t.as_str())
.ok_or_else(|| anyhow::anyhow!("No text in response"))?;
Ok(text.to_string())
⋮----
pub fn record_audio_and_transcribe(
⋮----
cpal::host_from_id(cpal::HostId::Wasapi).unwrap_or(cpal::default_host())
⋮----
match host.default_output_device() {
⋮----
eprintln!("Error: No default output device found for loopback.");
⋮----
let _ = PostMessageW(Some(overlay_hwnd), WM_CLOSE, WPARAM(0), LPARAM(0));
⋮----
eprintln!("Error: Device capture not supported on this OS or no device found.");
⋮----
match host.default_input_device() {
⋮----
eprintln!("Error: No input device available.");
⋮----
match device.default_output_config() {
⋮----
Err(_) => match device.default_input_config() {
⋮----
eprintln!("Failed to get audio config: {}", e);
⋮----
match device.default_input_config() {
⋮----
let sample_rate = config.sample_rate().0;
let channels = config.channels();
⋮----
let err_fn = |err| eprintln!("Audio stream error: {}", err);
⋮----
let stream_res = match config.sample_format() {
cpal::SampleFormat::F32 => device.build_input_stream(
&config.into(),
⋮----
if !pause_signal.load(Ordering::Relaxed) {
let _ = tx.send(data.to_vec());
⋮----
rms = (rms / data.len() as f32).sqrt();
⋮----
.store(true, Ordering::SeqCst);
⋮----
cpal::SampleFormat::I16 => device.build_input_stream(
⋮----
data.iter().map(|&s| s as f32 / i16::MAX as f32).collect();
let _ = tx.send(f32_data);
⋮----
eprintln!(
⋮----
Err(cpal::BuildStreamError::StreamConfigNotSupported)
⋮----
eprintln!("Failed to build stream: {}", e);
⋮----
let stream = stream_res.unwrap();
if let Err(e) = stream.play() {
eprintln!("Failed to play stream: {}", e);
⋮----
while !stop_signal.load(Ordering::SeqCst) {
while let Ok(chunk) = rx.try_recv() {
collected_samples.extend(chunk);
⋮----
if auto_stop_enabled && !stop_signal.load(Ordering::Relaxed) {
let rms_bits = crate::overlay::recording::CURRENT_RMS.load(Ordering::Relaxed);
⋮----
first_speech_time = Some(std::time::Instant::now());
⋮----
.map(|t| t.elapsed().as_millis())
.unwrap_or(0);
⋮----
let silence_duration = last_active_time.elapsed().as_millis();
⋮----
stop_signal.store(true, Ordering::SeqCst);
⋮----
if !unsafe { IsWindow(Some(overlay_hwnd)).as_bool() } {
⋮----
drop(stream);
if abort_signal.load(Ordering::SeqCst) {
println!("Audio recording aborted by user.");
⋮----
if IsWindow(Some(overlay_hwnd)).as_bool() {
⋮----
.iter()
.map(|&s| (s.clamp(-1.0, 1.0) * i16::MAX as f32) as i16)
.collect();
if samples.is_empty() {
println!("Warning: Recorded audio buffer is empty.");
⋮----
hound::WavWriter::new(&mut wav_cursor, spec).expect("Failed to create memory writer");
⋮----
.write_sample(*sample)
.expect("Failed to write sample");
⋮----
writer.finalize().expect("Failed to finalize WAV");
⋮----
let wav_data = wav_cursor.into_inner();
⋮----
let screen_w = unsafe { GetSystemMetrics(SM_CXSCREEN) };
let screen_h = unsafe { GetSystemMetrics(SM_CYSCREEN) };
⋮----
let audio_mode = Some(preset.audio_source.as_str());
⋮----
let mut app = crate::APP.lock().unwrap();
⋮----
app.config.presets[idx].clone()
⋮----
preset.clone()
⋮----
.find(|b| b.block_type == "audio")
⋮----
Some(b) => (b.clone(), false),
⋮----
.find(|b| b.block_type == "input_adapter")
⋮----
Some(b) => (b.clone(), true),
⋮----
eprintln!("Error: Audio preset has no 'audio' processing blocks configured");
⋮----
let wav_data_for_history = wav_data.clone();
⋮----
Ok(String::new())
⋮----
let model_config = get_model_by_id(&audio_block.model);
⋮----
let model_name = model_config.full_name.clone();
let provider = model_config.provider.clone();
⋮----
let app = crate::APP.lock().unwrap();
⋮----
app.config.api_key.clone(),
app.config.gemini_api_key.clone(),
⋮----
let mut final_prompt = if model_is_non_llm(&audio_block.model) {
⋮----
audio_block.prompt.clone()
⋮----
let pattern = format!("{{{}}}", key);
final_prompt = final_prompt.replace(&pattern, value);
⋮----
if final_prompt.contains("{language1}")
&& !audio_block.language_vars.contains_key("language1")
⋮----
final_prompt = final_prompt.replace("{language1}", &audio_block.selected_language);
⋮----
final_prompt = final_prompt.replace("{language}", &audio_block.selected_language);
⋮----
if groq_api_key.trim().is_empty() {
Err(anyhow::anyhow!("NO_API_KEY:groq"))
⋮----
upload_audio_to_whisper(&groq_api_key, &model_name, wav_data)
⋮----
Err(anyhow::anyhow!("NO_API_KEY:google"))
⋮----
transcribe_audio_gemini(&gemini_api_key, final_prompt, model_name, wav_data, |_| {})
⋮----
Err(anyhow::anyhow!("Unsupported audio provider: {}", provider))
⋮----
let wav_data_for_overlay = wav_data_for_history.clone();
⋮----
.save_audio(wav_data_for_history, transcription_text.clone());
⋮----
let has_multiple_blocks = working_preset.blocks.len() > 1;
⋮----
Some(RECT {
⋮----
eprintln!("Transcription error: {}", e);
</file>

<file path="src/api/tts/worker.rs">
use super::manager::TtsManager;
use super::types::AudioEvent;
⋮----
use crate::api::client::UREQ_AGENT;
use crate::APP;
use isolang::Language;
pub fn run_socket_worker(manager: Arc<TtsManager>) {
⋮----
if manager.shutdown.load(Ordering::SeqCst) {
⋮----
let mut queue = manager.work_queue.lock().unwrap();
while queue.is_empty() && !manager.shutdown.load(Ordering::SeqCst) {
let result = manager.work_signal.wait(queue).unwrap();
⋮----
queue.pop_front().unwrap()
⋮----
if request.generation < manager.interrupt_generation.load(Ordering::SeqCst) {
let _ = tx.send(AudioEvent::End);
⋮----
match APP.lock() {
Ok(app) => app.config.tts_method.clone(),
⋮----
handle_google_tts(manager.clone(), request, tx);
⋮----
handle_edge_tts(manager.clone(), request, tx);
⋮----
Ok(app) => app.config.gemini_api_key.clone(),
⋮----
if api_key.trim().is_empty() {
eprintln!("TTS: No Gemini API key configured");
⋮----
clear_tts_loading_state(request.req.hwnd);
clear_tts_state(request.req.hwnd);
⋮----
let socket_result = connect_tts_websocket(&api_key);
⋮----
eprintln!("TTS: Failed to connect: {}", e);
⋮----
let app = APP.lock().unwrap();
let voice = app.config.tts_voice.clone();
let conditions = app.config.tts_language_conditions.clone();
let instruction = get_language_instruction_for_text(&request.req.text, &conditions);
⋮----
(voice, "Normal".to_string(), instruction)
⋮----
(voice, app.config.tts_speed.clone(), instruction)
⋮----
if let Err(e) = send_tts_setup(
⋮----
language_instruction.as_deref(),
⋮----
eprintln!("TTS: Failed to send setup: {}", e);
let _ = socket.close(None);
⋮----
if request.generation < manager.interrupt_generation.load(Ordering::SeqCst)
|| manager.shutdown.load(Ordering::SeqCst)
⋮----
match socket.read() {
⋮----
if msg.contains("setupComplete") {
⋮----
if msg.contains("error") || msg.contains("Error") {
eprintln!("TTS: Setup error: {}", msg);
⋮----
if text.contains("setupComplete") {
⋮----
if e.kind() == std::io::ErrorKind::WouldBlock =>
⋮----
if setup_start.elapsed() > Duration::from_secs(10) {
⋮----
if let Err(e) = send_tts_text(&mut socket, &request.req.text) {
eprintln!("TTS: Failed to send text: {}", e);
⋮----
if let Some(audio_data) = parse_audio_data(&msg) {
let _ = tx.send(AudioEvent::Data(audio_data));
⋮----
if is_turn_complete(&msg) {
⋮----
if let Some(audio_data) = parse_audio_data(&text) {
⋮----
if is_turn_complete(&text) {
⋮----
eprintln!("TTS: Read error: {}", e);
⋮----
fn handle_google_tts(
⋮----
let text = request.req.text.clone();
let lang_code = whatlang::detect_lang(&text).unwrap_or(whatlang::Lang::Eng);
let tl = Language::from_639_3(lang_code.code())
.and_then(|l| l.to_639_1())
.unwrap_or("en");
let url = format!(
⋮----
let resp = match UREQ_AGENT.get(&url).call() {
⋮----
if resp.into_reader().read_to_end(&mut mp3_data).is_err() {
⋮----
match decoder.next_frame() {
⋮----
for chunk in data.chunks(2) {
⋮----
all_samples.push(sample);
⋮----
all_samples.extend_from_slice(&data);
⋮----
if all_samples.is_empty() {
⋮----
let resampled = resample_audio(&all_samples, source_sample_rate, 24000);
let mut bytes = Vec::with_capacity(resampled.len() * 2);
⋮----
bytes.extend_from_slice(&sample.to_le_bytes());
⋮----
let mut bytes = Vec::with_capacity(all_samples.len() * 2);
⋮----
for chunk in audio_bytes.chunks(chunk_size) {
⋮----
let _ = tx.send(AudioEvent::Data(chunk.to_vec()));
⋮----
fn handle_edge_tts(
⋮----
let manager_clone = manager.clone();
⋮----
let mut voice = "en-US-AriaNeural".to_string();
⋮----
.and_then(|info| Language::from_639_3(info.lang().code()))
⋮----
voice = config.voice_name.clone();
⋮----
let connection_id = format!(
⋮----
let wss_url = format!(
⋮----
let stream = match std::net::TcpStream::connect(format!("{}:443", host)) {
⋮----
let tls_stream = match connector.connect(host, stream) {
⋮----
let (mut socket, _) = match client(&wss_url, tls_stream) {
⋮----
let request_id = format!(
⋮----
let config_msg = format!(
⋮----
if socket.send(Message::Text(config_msg)).is_err() {
⋮----
format!("+{}Hz", pitch)
⋮----
format!("{}Hz", pitch)
⋮----
format!("+{}%", rate)
⋮----
format!("{}%", rate)
⋮----
.replace('&', "&amp;")
.replace('<', "&lt;")
.replace('>', "&gt;")
.replace('"', "&quot;")
.replace('\'', "&apos;");
let ssml = format!(
⋮----
let ssml_msg = format!(
⋮----
if socket.send(Message::Text(ssml_msg)).is_err() {
⋮----
if generation < manager_clone.interrupt_generation.load(Ordering::SeqCst) {
⋮----
if data.len() >= 2 {
⋮----
if data.len() > audio_start {
⋮----
if header.windows(11).any(|w| w == b"Path:audio\r") {
mp3_data.extend_from_slice(&data[audio_start..]);
⋮----
if text.contains("Path:turn.end") {
⋮----
Err(tungstenite::Error::Io(ref e)) if e.kind() == std::io::ErrorKind::WouldBlock => {
⋮----
if mp3_data.is_empty() {
⋮----
fn resample_audio(samples: &[i16], from_rate: u32, to_rate: u32) -> Vec<i16> {
⋮----
return samples.to_vec();
⋮----
let new_len = (samples.len() as f32 * ratio) as usize;
⋮----
if src_idx >= samples.len() - 1 {
result.push(samples[src_idx.min(samples.len() - 1)]);
⋮----
result.push(val as i16);
</file>

<file path="src/config/preset/defaults/image.rs">
use crate::config::preset::Preset;
use crate::config::types::Hotkey;
pub fn create_image_presets() -> Vec<Preset> {
vec![
⋮----
.prompt("") // QR scanner doesn't need a prompt
⋮----
// Node 1: Format the QR content nicely
</file>

<file path="src/config/preset/defaults/mod.rs">
mod audio;
mod image;
mod master;
mod text;
use crate::config::preset::Preset;
pub use audio::create_audio_presets;
pub use image::create_image_presets;
pub use master::create_master_presets;
pub use text::create_text_presets;
pub fn get_default_presets() -> Vec<Preset> {
let image = create_image_presets();
let text = create_text_presets();
let audio = create_audio_presets();
let masters = create_master_presets();
⋮----
presets.iter().find(|p| p.id == id).cloned().unwrap()
⋮----
vec![
</file>

<file path="src/gui/settings_ui/node_graph/utils.rs">
use crate::config::get_all_languages;
use crate::model_config::get_model_by_id;
use eframe::egui;
use std::collections::HashMap;
pub fn model_supports_search(model_id: &str) -> bool {
if let Some(model_config) = get_model_by_id(model_id) {
if model_config.full_name.contains("gemma-3-27b-it") {
⋮----
if model_id.contains("gemini") || model_id.contains("gemma") {
⋮----
if model_id.contains("compound") {
⋮----
pub fn request_node_graph_view_reset(ctx: &egui::Context) {
⋮----
ctx.data_mut(|d| d.insert_temp(reset_id, true));
⋮----
pub fn show_language_vars(
⋮----
let tag = format!("{{language{}}}", k);
if prompt.contains(&tag) {
detected_vars.push(k);
⋮----
let key = format!("language{}", num);
if !language_vars.contains_key(&key) {
language_vars.insert(key.clone(), "Vietnamese".to_string());
⋮----
let label = format!("{{language{}}}:", num);
ui.horizontal(|ui| {
ui.label(label);
let current_val = language_vars.get(&key).cloned().unwrap_or_default();
let search_id = egui::Id::new(format!("lang_search_{}", num));
let is_dark = ui.visuals().dark_mode;
⋮----
let button_response = ui.add(
egui::Button::new(egui::RichText::new(&current_val).color(egui::Color32::WHITE))
.fill(lang_var_bg)
.corner_radius(8.0),
⋮----
if button_response.clicked() {
egui::Popup::toggle_id(ui.ctx(), button_response.id);
⋮----
.close_behavior(egui::PopupCloseBehavior::CloseOnClickOutside)
.show(|ui| {
ui.set_min_width(120.0);
⋮----
ui.data_mut(|d| d.get_temp(search_id).unwrap_or_default());
let _search_response = ui.add(
⋮----
.hint_text("Search...")
.desired_width(110.0),
⋮----
ui.data_mut(|d| d.insert_temp(search_id, search_text.clone()));
ui.separator();
⋮----
.max_height(200.0)
.min_scrolled_height(200.0)
.auto_shrink([true, false])
.show(ui, |ui| {
ui.set_width(120.0);
for lang in get_all_languages() {
let matches_search = search_text.is_empty()
|| lang.to_lowercase().contains(&search_text.to_lowercase());
⋮----
if ui.selectable_label(is_selected, lang).clicked() {
language_vars.insert(key.clone(), lang.clone());
⋮----
ui.data_mut(|d| {
⋮----
egui::Popup::toggle_id(ui.ctx(), popup_layer_id);
⋮----
pub fn insert_next_language_tag(prompt: &mut String, language_vars: &mut HashMap<String, String>) {
⋮----
if prompt.contains(&format!("{{language{}}}", k)) {
⋮----
let tag = format!(" {{language{}}} ", next_num);
prompt.push_str(&tag);
let key = format!("language{}", next_num);
⋮----
language_vars.insert(key, "Vietnamese".to_string());
</file>

<file path="src/overlay/text_input.rs">
use crate::gui::locale::LocaleText;
⋮----
use std::cell::RefCell;
use std::num::NonZeroIsize;
⋮----
use crate::win_types::SendHwnd;
⋮----
static mut INPUT_HWND: SendHwnd = SendHwnd(HWND(std::ptr::null_mut()));
⋮----
thread_local! {
⋮----
struct HwndWrapper(HWND);
impl HasWindowHandle for HwndWrapper {
fn window_handle(&self) -> std::result::Result<WindowHandle<'_>, HandleError> {
⋮----
Ok(unsafe { WindowHandle::borrow_raw(raw) })
⋮----
Err(HandleError::Unavailable)
⋮----
/// CSS for the modern text input editor
fn get_editor_css() -> &'static str {
⋮----
fn get_editor_css() -> &'static str {
⋮----
fn get_editor_html(placeholder: &str) -> String {
let css = get_editor_css();
⋮----
.replace('\\', "\\\\")
.replace('"', "\\\"")
.replace('\n', "\\n");
format!(
⋮----
pub fn is_active() -> bool {
⋮----
!std::ptr::addr_of!(INPUT_HWND).read().is_invalid()
&& IsWindowVisible(INPUT_HWND.0).as_bool()
⋮----
pub fn cancel_input() {
⋮----
if !std::ptr::addr_of!(INPUT_HWND).read().is_invalid() {
// Just hide the window, don't destroy
let _ = ShowWindow(INPUT_HWND.0, SW_HIDE);
⋮----
/// Set text content in the webview editor (for paste operations)
/// This is thread-safe and can be called from any thread
⋮----
/// This is thread-safe and can be called from any thread
pub fn set_editor_text(text: &str) {
⋮----
pub fn set_editor_text(text: &str) {
⋮----
// Store the text in the mutex
*PENDING_TEXT.lock().unwrap() = Some(text.to_string());
// Post message to the text input window to trigger the injection
⋮----
let _ = PostMessageW(Some(INPUT_HWND.0), WM_APP_SET_TEXT, WPARAM(0), LPARAM(0));
⋮----
/// Internal function to apply pending text (called on the window's thread)
/// Inserts text at the current cursor position instead of replacing all content
⋮----
/// Inserts text at the current cursor position instead of replacing all content
fn apply_pending_text() {
⋮----
fn apply_pending_text() {
let text = PENDING_TEXT.lock().unwrap().take();
⋮----
// Check if this is a history replacement (replace all) or insertion
⋮----
if let Some(stripped) = text.strip_prefix("__REPLACE_ALL__") {
(true, stripped.to_string())
⋮----
.replace('`', "\\`")
.replace("${", "\\${")
.replace('\n', "\\n")
.replace('\r', "");
TEXT_INPUT_WEBVIEW.with(|webview| {
if let Some(wv) = webview.borrow().as_ref() {
⋮----
// Replace all text (for history navigation)
⋮----
// Insert at cursor position (for paste/transcription)
⋮----
let _ = wv.evaluate_script(&script);
⋮----
/// Clear the webview editor content and refocus (for continuous input mode)
pub fn clear_editor_text() {
⋮----
pub fn clear_editor_text() {
⋮----
let _ = wv.evaluate_script(script);
⋮----
/// Update the UI text (header) and trigger a repaint
pub fn update_ui_text(header_text: String) {
⋮----
pub fn update_ui_text(header_text: String) {
⋮----
*CFG_TITLE.lock().unwrap() = header_text;
let _ = InvalidateRect(Some(INPUT_HWND.0), None, true);
⋮----
/// Bring the text input window to foreground and focus the editor
/// Call this after closing modal windows like the preset wheel
⋮----
/// Call this after closing modal windows like the preset wheel
pub fn refocus_editor() {
⋮----
pub fn refocus_editor() {
⋮----
use windows::Win32::UI::Input::KeyboardAndMouse::SetFocus;
⋮----
// Aggressive focus: try multiple methods
let _ = BringWindowToTop(INPUT_HWND.0);
let _ = SetForegroundWindow(INPUT_HWND.0);
let _ = SetFocus(Some(INPUT_HWND.0));
// Focus the webview editor immediately
⋮----
// First focus the WebView itself (native focus)
let _ = wv.focus();
// Then focus the textarea inside via JavaScript
let _ = wv.evaluate_script("document.getElementById('editor').focus();");
⋮----
// Schedule another focus attempt after 200ms via timer ID 3
// This will be handled in WM_TIMER in the same thread
let _ = SetTimer(Some(INPUT_HWND.0), 3, 200, None);
⋮----
/// Get the current window rect of the text input window (if active)
pub fn get_window_rect() -> Option<RECT> {
⋮----
pub fn get_window_rect() -> Option<RECT> {
⋮----
if GetWindowRect(INPUT_HWND.0, &mut rect).is_ok() {
return Some(rect);
⋮----
/// Start the persistent hidden window (called from main)
pub fn warmup() {
⋮----
pub fn warmup() {
⋮----
internal_create_window_loop();
⋮----
pub fn show(
⋮----
// Update shared state
*CFG_TITLE.lock().unwrap() = prompt_guide;
*CFG_LANG.lock().unwrap() = ui_language;
*CFG_CANCEL.lock().unwrap() = cancel_hotkey_name;
*CFG_CONTINUOUS.lock().unwrap() = continuous_mode;
*CFG_CALLBACK.lock().unwrap() = Some(Box::new(on_submit));
*SUBMITTED_TEXT.lock().unwrap() = None;
*SHOULD_CLOSE.lock().unwrap() = false;
*SHOULD_CLEAR_ONLY.lock().unwrap() = false;
⋮----
// Window exists, wake it up
let _ = PostMessageW(Some(INPUT_HWND.0), WM_APP_SHOW, WPARAM(0), LPARAM(0));
⋮----
// Fallback (should normally be warmed up)
warmup();
// Sleep a bit and retry (simple handling for race on first cold start)
⋮----
fn internal_create_window_loop() {
⋮----
let instance = GetModuleHandleW(None).unwrap();
let class_name = w!("SGT_TextInputWry");
REGISTER_INPUT_CLASS.call_once(|| {
⋮----
wc.lpfnWndProc = Some(input_wnd_proc);
wc.hInstance = instance.into();
wc.hCursor = LoadCursorW(None, IDC_ARROW).unwrap();
⋮----
let _ = RegisterClassW(&wc);
⋮----
let screen_w = GetSystemMetrics(SM_CXSCREEN);
let screen_h = GetSystemMetrics(SM_CYSCREEN);
⋮----
let hwnd = CreateWindowExW(
⋮----
w!("Text Input"),
⋮----
Some(instance.into()),
⋮----
.unwrap_or_default();
INPUT_HWND = SendHwnd(hwnd);
let _ = SetLayeredWindowAttributes(hwnd, COLORREF(0), 0, LWA_ALPHA);
let rgn = CreateRoundRectRgn(0, 0, win_w, win_h, 16, 16);
let _ = SetWindowRgn(hwnd, Some(rgn), true);
init_webview(hwnd, win_w, win_h);
⋮----
while GetMessageW(&mut msg, None, 0, 0).as_bool() {
let _ = TranslateMessage(&msg);
let _ = DispatchMessageW(&msg);
⋮----
TEXT_INPUT_WEBVIEW.with(|wv| {
*wv.borrow_mut() = None;
⋮----
unsafe fn init_webview(hwnd: HWND, w: i32, h: i32) {
⋮----
let html = get_editor_html(placeholder);
let wrapper = HwndWrapper(hwnd);
TEXT_INPUT_WEB_CONTEXT.with(|ctx| {
if ctx.borrow().is_none() {
⋮----
*ctx.borrow_mut() = Some(WebContext::new(Some(shared_data_dir)));
⋮----
let result = TEXT_INPUT_WEB_CONTEXT.with(|ctx| {
let mut ctx_ref = ctx.borrow_mut();
let builder = if let Some(web_ctx) = ctx_ref.as_mut() {
⋮----
.with_bounds(Rect {
⋮----
.with_html(&html)
.with_transparent(false)
.with_ipc_handler(move |msg: wry::http::Request<String>| {
let body = msg.body();
if body.starts_with("submit:") {
let text = body.strip_prefix("submit:").unwrap_or("").to_string();
if !text.trim().is_empty() {
// Save to history before submitting
⋮----
*SUBMITTED_TEXT.lock().unwrap() = Some(text);
*SHOULD_CLOSE.lock().unwrap() = true;
⋮----
} else if body.starts_with("history_up:") {
let current = body.strip_prefix("history_up:").unwrap_or("");
⋮----
*PENDING_TEXT.lock().unwrap() = Some(format!("__REPLACE_ALL__{}", text));
⋮----
let _ = PostMessageW(
Some(INPUT_HWND.0),
⋮----
WPARAM(0),
LPARAM(0),
⋮----
} else if body.starts_with("history_down:") {
let current = body.strip_prefix("history_down:").unwrap_or("");
⋮----
let app = crate::APP.lock().unwrap();
⋮----
.iter()
.position(|p| p.id == "preset_transcribe")
⋮----
.build_as_child(&wrapper)
⋮----
*wv.borrow_mut() = Some(webview);
⋮----
unsafe extern "system" fn input_wnd_proc(
⋮----
let prompt_guide = CFG_TITLE.lock().unwrap().clone();
let ui_language = CFG_LANG.lock().unwrap().clone();
let _ = SetWindowTextW(hwnd, &HSTRING::from(prompt_guide));
⋮----
let placeholder = locale.text_input_placeholder.to_string();
⋮----
if let Some(webview) = wv.borrow().as_ref() {
let script = format!(
⋮----
let _ = webview.evaluate_script(&script);
⋮----
let _ = GetWindowRect(hwnd, &mut rect);
⋮----
let _ = SetWindowPos(
⋮----
Some(HWND::default()),
⋮----
let _ = ShowWindow(hwnd, SW_SHOW);
let _ = SetForegroundWindow(hwnd);
let _ = SetFocus(Some(hwnd));
let _ = UpdateWindow(hwnd);
SetTimer(Some(hwnd), 1, 16, None);
SetTimer(Some(hwnd), 2, 50, None);
LRESULT(0)
⋮----
apply_pending_text();
⋮----
let _ = ShowWindow(hwnd, SW_HIDE);
let _ = KillTimer(Some(hwnd), 1);
let _ = KillTimer(Some(hwnd), 2);
let _ = KillTimer(Some(hwnd), 3);
⋮----
PostQuitMessage(0);
⋮----
WM_ERASEBKGND => LRESULT(1),
⋮----
SetLayeredWindowAttributes(hwnd, COLORREF(0), FADE_ALPHA as u8, LWA_ALPHA);
⋮----
wv.evaluate_script("document.getElementById('editor').focus();");
⋮----
let should_close = *SHOULD_CLOSE.lock().unwrap();
⋮----
let submitted = SUBMITTED_TEXT.lock().unwrap().take();
⋮----
let continuous = *CFG_CONTINUOUS.lock().unwrap();
⋮----
let cb_lock = CFG_CALLBACK.lock().unwrap();
if let Some(cb) = cb_lock.as_ref() {
cb(text, hwnd);
⋮----
clear_editor_text();
⋮----
let _ = GetClientRect(hwnd, &mut rect);
⋮----
if (x - close_x).abs() < 15 && (y - close_y).abs() < 15 {
let _ = PostMessageW(Some(hwnd), WM_CLOSE, WPARAM(0), LPARAM(0));
return LRESULT(0);
⋮----
let _ = ReleaseCapture();
SendMessageW(hwnd, WM_SYSCOMMAND, Some(WPARAM(0xF012)), Some(LPARAM(0)));
⋮----
let hdc = BeginPaint(hwnd, &mut ps);
⋮----
let mem_dc = CreateCompatibleDC(Some(hdc));
let mem_bmp = CreateCompatibleBitmap(hdc, w, h);
let old_bmp = SelectObject(mem_dc, mem_bmp.into());
let brush_bg = CreateSolidBrush(COLORREF(COL_DARK_BG));
FillRect(mem_dc, &rect, brush_bg);
let _ = DeleteObject(brush_bg.into());
⋮----
SetPixel(mem_dc, px_screen, py_screen, COLORREF(fill_color));
⋮----
SetPixel(
⋮----
COLORREF((r << 16) | (g << 8) | b),
⋮----
SetBkMode(mem_dc, TRANSPARENT);
SetTextColor(mem_dc, COLORREF(0x00FFFFFF));
let h_font = CreateFontW(
⋮----
FONT_CHARSET(DEFAULT_CHARSET.0 as u8),
FONT_OUTPUT_PRECISION(OUT_DEFAULT_PRECIS.0 as u8),
FONT_CLIP_PRECISION(CLIP_DEFAULT_PRECIS.0 as u8),
FONT_QUALITY(CLEARTYPE_QUALITY.0 as u8),
⋮----
w!("Segoe UI"),
⋮----
let old_font = SelectObject(mem_dc, h_font.into());
let title_str = CFG_TITLE.lock().unwrap().clone();
let cur_lang = CFG_LANG.lock().unwrap().clone();
let cur_cancel = CFG_CANCEL.lock().unwrap().clone();
⋮----
let display_title = if !title_str.is_empty() {
⋮----
locale.text_input_title_default.to_string()
⋮----
DrawTextW(
⋮----
let h_font_small = CreateFontW(
⋮----
SelectObject(mem_dc, h_font_small.into());
SetTextColor(mem_dc, COLORREF(0x00AAAAAA));
let esc_text = if cur_cancel.is_empty() {
"Esc".to_string()
⋮----
format!("Esc / {}", cur_cancel)
⋮----
let hint = format!(
⋮----
DrawTextW(mem_dc, &mut hint_w, &mut r_hint, DT_CENTER | DT_SINGLELINE);
SelectObject(mem_dc, old_font);
let _ = DeleteObject(h_font.into());
let _ = DeleteObject(h_font_small.into());
⋮----
let pen = CreatePen(PS_SOLID, 2, COLORREF(0x00AAAAAA));
let old_pen = SelectObject(mem_dc, pen.into());
let _ = MoveToEx(mem_dc, c_cx - 5, c_cy - 5, None);
let _ = LineTo(mem_dc, c_cx + 5, c_cy + 5);
let _ = MoveToEx(mem_dc, c_cx + 5, c_cy - 5, None);
let _ = LineTo(mem_dc, c_cx - 5, c_cy + 5);
SelectObject(mem_dc, old_pen);
let _ = DeleteObject(pen.into());
let _ = BitBlt(hdc, 0, 0, w, h, Some(mem_dc), 0, 0, SRCCOPY);
SelectObject(mem_dc, old_bmp);
let _ = DeleteObject(mem_bmp.into());
let _ = DeleteDC(mem_dc);
let _ = EndPaint(hwnd, &mut ps);
⋮----
_ => DefWindowProcW(hwnd, msg, wparam, lparam),
</file>

<file path="src/overlay/utils.rs">
pub fn to_wstring(s: &str) -> Vec<u16> {
s.encode_utf16().chain(std::iter::once(0)).collect()
⋮----
pub fn get_context_quote(text: &str) -> String {
let words: Vec<&str> = text.split_whitespace().collect();
let len = words.len();
⋮----
format!("\"... {}\"", words[len - 50..].join(" "))
⋮----
format!("\"... {}\"", words.join(" "))
⋮----
pub fn copy_to_clipboard(text: &str, hwnd: HWND) {
⋮----
if OpenClipboard(Some(hwnd)).is_ok() {
let _ = EmptyClipboard();
let wide_text: Vec<u16> = text.encode_utf16().chain(std::iter::once(0)).collect();
let mem_size = wide_text.len() * 2;
if let Ok(h_mem) = GlobalAlloc(GMEM_MOVEABLE, mem_size) {
let ptr = GlobalLock(h_mem) as *mut u16;
std::ptr::copy_nonoverlapping(wide_text.as_ptr(), ptr, wide_text.len());
let _ = GlobalUnlock(h_mem);
let h_mem_handle = HANDLE(h_mem.0);
let _ = SetClipboardData(13u32, Some(h_mem_handle));
⋮----
let _ = CloseClipboard();
⋮----
eprintln!("Failed to copy to clipboard after 5 attempts");
⋮----
pub fn copy_image_to_clipboard(image_bytes: &[u8]) {
⋮----
.write_to(&mut cursor, image::ImageOutputFormat::Bmp)
.is_ok()
⋮----
if bmp_data.len() > 14 && bmp_data[0] == 0x42 && bmp_data[1] == 0x4D {
⋮----
if OpenClipboard(None).is_ok() {
⋮----
let mem_size = dib_data.len();
⋮----
let ptr = GlobalLock(h_mem) as *mut u8;
std::ptr::copy_nonoverlapping(dib_data.as_ptr(), ptr, mem_size);
⋮----
let _ = SetClipboardData(8, Some(h_mem_handle));
⋮----
let hdc = GetDC(None);
if !hdc.is_invalid() {
if dib_data.len() >= 4 {
⋮----
dib_data[0..4].try_into().unwrap_or([0; 4]),
⋮----
if (header_size as usize) < dib_data.len() {
⋮----
dib_data.as_ptr().add(header_size as usize);
⋮----
dib_data.as_ptr() as *const BITMAPINFOHEADER;
let pbmi = dib_data.as_ptr() as *const BITMAPINFO;
let hbitmap = CreateDIBitmap(
⋮----
Some(pbmih),
⋮----
Some(bits_ptr as *const std::ffi::c_void),
Some(pbmi),
⋮----
if !hbitmap.is_invalid() {
let _ = SetClipboardData(
⋮----
Some(HANDLE(hbitmap.0 as *mut _)),
⋮----
ReleaseDC(None, hdc);
⋮----
pub fn get_clipboard_image_bytes() -> Option<Vec<u8>> {
use windows::Win32::System::DataExchange::IsClipboardFormatAvailable;
⋮----
let has_dib = IsClipboardFormatAvailable(8).is_ok();
let has_dibv5 = IsClipboardFormatAvailable(17).is_ok();
⋮----
if let Ok(h_data) = GetClipboardData(format_to_try) {
let ptr = GlobalLock(HGLOBAL(h_data.0));
if !ptr.is_null() {
let size = GlobalSize(HGLOBAL(h_data.0));
⋮----
if dib_data.len() >= std::mem::size_of::<BITMAPINFOHEADER>() {
let header = &*(dib_data.as_ptr() as *const BITMAPINFOHEADER);
⋮----
let height = header.biHeight.abs();
⋮----
if dib_data.len() > pixel_offset {
⋮----
if px_start + bytes_per_pixel <= pixel_data.len() {
⋮----
rgba_buffer.push(r);
rgba_buffer.push(g);
rgba_buffer.push(b);
rgba_buffer.push(a);
⋮----
let _ = GlobalUnlock(HGLOBAL(h_data.0));
⋮----
.write_to(
⋮----
return Some(png_data);
⋮----
pub fn get_target_window_for_paste() -> Option<HWND> {
⋮----
let hwnd_foreground = GetForegroundWindow();
if hwnd_foreground.is_invalid() {
⋮----
let thread_id = GetWindowThreadProcessId(hwnd_foreground, None);
⋮----
if GetGUIThreadInfo(thread_id, &mut gui_info).is_ok() {
let has_caret = !gui_info.hwndCaret.is_invalid();
⋮----
let has_focus = !gui_info.hwndFocus.is_invalid();
⋮----
return Some(hwnd_foreground);
⋮----
pub fn force_focus_and_paste(hwnd_target: HWND) {
⋮----
if IsWindow(Some(hwnd_target)).as_bool() {
let cur_thread = GetCurrentThreadId();
let target_thread = GetWindowThreadProcessId(hwnd_target, None);
⋮----
let _ = AttachThreadInput(cur_thread, target_thread, true);
let _ = SetForegroundWindow(hwnd_target);
let _ = BringWindowToTop(hwnd_target);
let _ = SetFocus(Some(hwnd_target));
let _ = AttachThreadInput(cur_thread, target_thread, false);
⋮----
let state = GetAsyncKeyState(vk as i32);
⋮----
wVk: VIRTUAL_KEY(vk),
⋮----
SendInput(&[input], std::mem::size_of::<INPUT>() as i32);
⋮----
release_if_pressed(VK_MENU.0);
release_if_pressed(VK_SHIFT.0);
release_if_pressed(VK_LWIN.0);
release_if_pressed(VK_RWIN.0);
release_if_pressed(VK_CONTROL.0);
⋮----
send_input_event(VK_CONTROL.0, KEYBD_EVENT_FLAGS(0));
⋮----
send_input_event(VK_V.0, KEYBD_EVENT_FLAGS(0));
⋮----
send_input_event(VK_V.0, KEYEVENTF_KEYUP);
⋮----
send_input_event(VK_CONTROL.0, KEYEVENTF_KEYUP);
⋮----
pub fn get_error_message(error: &str, lang: &str, model_name: Option<&str>) -> String {
if error.starts_with("NO_API_KEY") {
let provider = if error.contains(':') {
let parts: Vec<&str> = error.split(':').collect();
if parts.len() > 1 {
⋮----
"vi" => format!("Bạn chưa nhập {} API key!", provider),
"ko" => format!("{} API 키를 입력하지 않았습니다!", provider),
"ja" => format!("{} APIキーが入力されていません!", provider),
"zh" => format!("您还没有输入 {} API key!", provider),
_ => format!("You haven't entered a {} API key!", provider),
⋮----
if error.starts_with("INVALID_API_KEY") {
⋮----
"vi" => format!("{} API key không hợp lệ!", provider),
"ko" => format!("{} API 키가 유효하지 않습니다!", provider),
"ja" => format!("{} APIキーが無効です!", provider),
"zh" => format!("{} API key 无效!", provider),
_ => format!("Invalid {} API key!", provider),
⋮----
if let Some(status_code) = extract_http_status_code(error) {
let provider = extract_provider_from_error(error);
return format_http_error(status_code, &provider, model_name, lang);
⋮----
"vi" => format!("Lỗi: {}", error),
"ko" => format!("오류: {}", error),
"ja" => format!("エラー: {}", error),
"zh" => format!("错误: {}", error),
_ => format!("Error: {}", error),
⋮----
fn extract_http_status_code(error: &str) -> Option<u16> {
if let Some(pos) = error.find("status code ") {
⋮----
let code_str: String = after.chars().take_while(|c| c.is_ascii_digit()).collect();
return code_str.parse().ok();
⋮----
let trimmed = error.trim();
if trimmed.len() >= 3 {
⋮----
.chars()
.rev()
.take(3)
⋮----
.collect();
if last_3.chars().all(|c| c.is_ascii_digit()) {
⋮----
if (400..=599).contains(&code) {
return Some(code);
⋮----
if error.contains(&code.to_string()) {
⋮----
fn extract_provider_from_error(error: &str) -> String {
if error.contains("api.groq.com") {
"Groq".to_string()
} else if error.contains("generativelanguage.googleapis.com") || error.contains("gemini") {
"Google Gemini".to_string()
} else if error.contains("api.openai.com") {
"OpenAI".to_string()
} else if error.contains("api.anthropic.com") || error.contains("claude") {
"Anthropic".to_string()
⋮----
"API".to_string()
⋮----
fn format_http_error(
⋮----
format!("{} ({})", model, provider)
⋮----
provider.to_string()
⋮----
"vi" => format!("Lỗi 429: Đã vượt quá hạn mức của mô hình {} (Rate Limit). Vui lòng chờ một lát rồi thử lại.", model_info),
"ko" => format!("오류 429: {} 모델의 요청 제한 초과 (Rate Limit). 잠시 후 다시 시도해 주세요.", model_info),
"ja" => format!("エラー 429: {} のレート制限を超えました。しばらくしてから再試行してください。", model_info),
"zh" => format!("错误 429: {} 模型请求超出限制 (Rate Limit)。请稍后再试。", model_info),
_ => format!("Error 429: Rate limit exceeded for model {}. Please wait a moment and try again.", model_info),
⋮----
"vi" => format!("Lỗi 400: Yêu cầu không hợp lệ đến {}. Vui lòng kiểm tra lại cài đặt.", model_info),
"ko" => format!("오류 400: {}에 대한 잘못된 요청입니다. 설정을 확인해 주세요.", model_info),
"ja" => format!("エラー 400: {} へのリクエストが無効です。設定を確認してください。", model_info),
"zh" => format!("错误 400: {} 请求无效。请检查设置。", model_info),
_ => format!("Error 400: Bad request to {}. Please check your settings.", model_info),
⋮----
"vi" => format!("Lỗi 401: API key của {} không hợp lệ hoặc đã hết hạn.", provider),
"ko" => format!("오류 401: {} API 키가 유효하지 않거나 만료되었습니다.", provider),
"ja" => format!("エラー 401: {} の API キーが無効または期限切れです。", provider),
"zh" => format!("错误 401: {} API 密钥无效或已过期。", provider),
_ => format!("Error 401: {} API key is invalid or expired.", provider),
⋮----
"vi" => format!("Lỗi 403: Không có quyền truy cập {}. Vui lòng kiểm tra API key.", provider),
"ko" => format!("오류 403: {}에 대한 접근 권한이 없습니다. API 키를 확인해 주세요.", provider),
"ja" => format!("エラー 403: {} へのアクセス権限がありません。API キーを確認してください。", provider),
"zh" => format!("错误 403: 无权访问 {}。请检查 API 密钥。", provider),
_ => format!("Error 403: Access forbidden to {}. Please check your API key.", provider),
⋮----
"vi" => format!("Lỗi 404: Không tìm thấy mô hình {} trên {}.", model_name.unwrap_or("này"), provider),
"ko" => format!("오류 404: {}에서 {} 모델을 찾을 수 없습니다.", provider, model_name.unwrap_or("해당")),
"ja" => format!("エラー 404: {} で {} が見つかりません。", provider, model_name.unwrap_or("このモデル")),
"zh" => format!("错误 404: 在 {} 上找不到模型 {}。", provider, model_name.unwrap_or("此")),
_ => format!("Error 404: Model {} not found on {}.", model_name.unwrap_or("this"), provider),
⋮----
"vi" => format!("Lỗi 500: Máy chủ {} gặp lỗi nội bộ. Vui lòng thử lại sau.", provider),
"ko" => format!("오류 500: {} 서버 내부 오류입니다. 나중에 다시 시도해 주세요.", provider),
"ja" => format!("エラー 500: {} サーバー内部エラー。後で再試行してください。", provider),
"zh" => format!("错误 500: {} 服务器内部错误。请稍后再试。", provider),
_ => format!("Error 500: {} internal server error. Please try again later.", provider),
⋮----
"vi" => format!("Lỗi 502: Bad Gateway - {} đang gặp sự cố. Vui lòng thử lại sau.", provider),
"ko" => format!("오류 502: Bad Gateway - {}에 문제가 발생했습니다. 나중에 다시 시도해 주세요.", provider),
"ja" => format!("エラー 502: Bad Gateway - {} に問題が発生しています。後で再試行してください。", provider),
"zh" => format!("错误 502: Bad Gateway - {} 遇到问题。请稍后再试。", provider),
_ => format!("Error 502: Bad Gateway - {} is having issues. Please try again later.", provider),
⋮----
"vi" => format!("Lỗi 503: Dịch vụ {} đang quá tải hoặc bảo trì. Vui lòng thử lại sau.", provider),
"ko" => format!("오류 503: {} 서비스가 과부하 상태이거나 점검 중입니다. 나중에 다시 시도해 주세요.", provider),
"ja" => format!("エラー 503: {} サービスが過負荷またはメンテナンス中です。後で再試行してください。", provider),
"zh" => format!("错误 503: {} 服务过载或维护中。请稍后再试。", provider),
_ => format!("Error 503: {} service is overloaded or under maintenance. Please try again later.", provider),
⋮----
"vi" => format!("Lỗi 504: Hết thời gian chờ phản hồi từ {}. Vui lòng thử lại.", model_info),
"ko" => format!("오류 504: {} 응답 시간 초과. 다시 시도해 주세요.", model_info),
"ja" => format!("エラー 504: {} からの応答がタイムアウトしました。再試行してください。", model_info),
"zh" => format!("错误 504: {} 响应超时。请重试。", model_info),
_ => format!("Error 504: Gateway timeout from {}. Please try again.", model_info),
⋮----
"vi" => format!("Lỗi {}: Có lỗi xảy ra với {} (HTTP {}).", status_code, model_info, status_code),
"ko" => format!("오류 {}: {}에서 오류가 발생했습니다 (HTTP {}).", status_code, model_info, status_code),
"ja" => format!("エラー {}: {} でエラーが発生しました (HTTP {}).", status_code, model_info, status_code),
"zh" => format!("错误 {}: {} 发生错误 (HTTP {}).", status_code, model_info, status_code),
_ => format!("Error {}: An error occurred with {} (HTTP {}).", status_code, model_info, status_code),
</file>

<file path="src/gui/settings_ui/node_graph/body.rs">
use super::node::ChainNode;
⋮----
use super::viewer::ChainViewer;
⋮----
use eframe::egui;
⋮----
pub fn show_body(
⋮----
.get_node(node_id)
.map(|n| n.id().to_string())
.unwrap_or_default();
⋮----
let node = snarl.get_node_mut(node_id).unwrap();
ui.vertical(|ui| {
ui.set_max_width(320.0);
⋮----
ui.set_min_width(173.0);
⋮----
viewer.preset_type.as_str()
⋮----
block_type.as_str()
⋮----
ui.horizontal(|ui| {
⋮----
if icon_button(ui, icon).clicked() {
⋮----
"plain".to_string()
⋮----
"markdown".to_string()
⋮----
match viewer.ui_language.as_str() {
⋮----
let popup_id = ui.make_persistent_id(format!(
⋮----
let btn = ui.add(
⋮----
.fill(egui::Color32::from_rgba_unmultiplied(
⋮----
.corner_radius(4.0),
⋮----
if btn.clicked() {
ui.memory_mut(|mem| mem.toggle_popup(popup_id));
⋮----
ui.set_min_width(60.0);
let (lbl_norm, lbl_md) = match viewer.ui_language.as_str() {
⋮----
.selectable_label(render_mode == "plain", lbl_norm)
.clicked()
⋮----
*render_mode = "plain".to_string();
⋮----
ui.memory_mut(|mem| mem.close_popup(popup_id));
⋮----
.selectable_label(render_mode == "markdown", lbl_md)
⋮----
*render_mode = "markdown".to_string();
⋮----
let _ = icon_button(ui, Icon::Copy)
.on_hover_text(viewer.text.input_auto_copy_tooltip);
⋮----
if icon_button(ui, copy_icon)
.on_hover_text(viewer.text.input_auto_copy_tooltip)
⋮----
if icon_button(ui, speak_icon)
.on_hover_text(viewer.text.input_auto_speak_tooltip)
⋮----
let target_model_type = match viewer.preset_type.as_str() {
⋮----
let model_label = match viewer.ui_language.as_str() {
⋮----
ui.label(model_label);
let model_def = get_model_by_id(model);
⋮----
.as_ref()
.map(|m| match viewer.ui_language.as_str() {
"vi" => m.name_vi.as_str(),
"ko" => m.name_ko.as_str(),
_ => m.name_en.as_str(),
⋮----
.unwrap_or(model.as_str());
let button_response = ui.button(display_name);
if button_response.clicked() {
egui::Popup::toggle_id(ui.ctx(), button_response.id);
⋮----
trigger_ollama_model_scan();
⋮----
egui::Popup::from_toggle_button_response(&button_response).show(|ui| {
ui.style_mut().wrap_mode = Some(egui::TextWrapMode::Extend);
if viewer.use_ollama && is_ollama_scan_in_progress() {
let loading_text = match viewer.ui_language.as_str() {
⋮----
ui.label(egui::RichText::new(loading_text).weak().italics());
ui.separator();
⋮----
for m in get_all_models_with_ollama() {
⋮----
&& viewer.is_provider_enabled(&m.provider)
⋮----
let name = match viewer.ui_language.as_str() {
⋮----
let quota = match viewer.ui_language.as_str() {
⋮----
let search_icon = if model_supports_search(&m.id) {
⋮----
let label = format!(
⋮----
if ui.selectable_label(is_selected, label).clicked() {
*model = m.id.clone();
⋮----
egui::Popup::toggle_id(ui.ctx(), popup_layer_id);
⋮----
// Only show prompt UI for LLM models (not QR scanner, GTX, Whisper, etc.)
if !model_is_non_llm(model) {
// Row 2: Prompt Label + Add Tag Button
⋮----
let prompt_label = match viewer.ui_language.as_str() {
⋮----
ui.label(prompt_label);
let btn_label = match viewer.ui_language.as_str() {
⋮----
let is_dark = ui.visuals().dark_mode;
⋮----
.add(
⋮----
.small()
.color(egui::Color32::WHITE),
⋮----
.fill(lang_btn_bg)
.corner_radius(8.0),
⋮----
insert_next_language_tag(prompt, language_vars);
⋮----
.desired_width(152.0)
.desired_rows(2),
⋮----
.changed()
⋮----
show_language_vars(
⋮----
match (render_mode.as_str(), *streaming_enabled) {
("markdown", _) => match viewer.ui_language.as_str() {
⋮----
(_, true) => match viewer.ui_language.as_str() {
⋮----
(_, false) => match viewer.ui_language.as_str() {
⋮----
.make_persistent_id(format!("render_mode_popup_{:?}", node_id));
⋮----
.selectable_label(
⋮----
*render_mode = "stream".to_string();
⋮----
// Only show prompt UI for LLM models (not GTX, etc.)
⋮----
for node in snarl.nodes_mut() {
if node.id() != current_node_uuid {
node.set_auto_copy(false);
</file>

<file path="src/gui/settings_ui/preset.rs">
use eframe::egui;
⋮----
use crate::gui::locale::LocaleText;
use super::get_localized_preset_name;
use egui_snarl::Snarl;
⋮----
pub fn render_preset_editor(
⋮----
if preset_idx >= config.presets.len() { return false; }
let mut preset = config.presets[preset_idx].clone();
⋮----
ui.set_max_width(510.0);
let is_default_preset = preset.id.starts_with("preset_");
⋮----
get_localized_preset_name(&preset.id, &config.ui_language)
⋮----
preset.name.clone()
⋮----
let is_dark = ui.visuals().dark_mode;
⋮----
ui.add_space(5.0);
⋮----
.fill(header_bg)
.stroke(header_stroke)
.inner_margin(12.0)
.corner_radius(10.0)
.show(ui, |ui| {
ui.horizontal(|ui| {
ui.label(egui::RichText::new(text.preset_name_label).strong());
⋮----
ui.label(egui::RichText::new(&display_name).strong().size(15.0));
⋮----
if ui.add(egui::TextEdit::singleline(&mut preset.name).font(egui::TextStyle::Body)).changed() {
⋮----
ui.add_space(10.0);
⋮----
if ui.checkbox(&mut preset.show_controller_ui, text.controller_checkbox_label).clicked() {
if !preset.show_controller_ui && preset.blocks.is_empty() {
preset.blocks.push(create_default_block_for_type(&preset.preset_type));
*snarl = blocks_to_snarl(&preset.blocks, &preset.block_connections, &preset.preset_type);
⋮----
ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
⋮----
if ui.add(egui::Button::new(egui::RichText::new(text.restore_preset_btn).color(egui::Color32::WHITE).small())
.fill(restore_bg)
.corner_radius(8.0))
.on_hover_text(text.restore_preset_tooltip)
.clicked() {
⋮----
if let Some(default_p) = default_config.presets.iter().find(|p| p.id == preset.id) {
preset = default_p.clone();
⋮----
request_node_graph_view_reset(ui.ctx());
⋮----
ui.add_space(6.0);
⋮----
ui.label(text.preset_type_label);
let selected_text = match preset.preset_type.as_str() {
⋮----
.selected_text(selected_text)
.show_ui(ui, |ui| {
if ui.selectable_value(&mut preset.preset_type, "image".to_string(), text.preset_type_image).clicked() {
if let Some(first) = preset.blocks.first_mut() {
first.block_type = "image".to_string();
first.model = "maverick".to_string();
⋮----
if ui.selectable_value(&mut preset.preset_type, "text".to_string(), text.preset_type_text).clicked() {
⋮----
first.block_type = "text".to_string();
first.model = "text_accurate_kimi".to_string();
⋮----
if ui.selectable_value(&mut preset.preset_type, "audio".to_string(), text.preset_type_audio).clicked() {
⋮----
first.block_type = "audio".to_string();
first.model = "whisper-accurate".to_string();
⋮----
ui.add_enabled_ui(false, |ui| {
let _ = ui.selectable_value(&mut preset.preset_type, "video".to_string(), text.preset_type_video);
⋮----
ui.add_space(15.0);
⋮----
ui.label(text.command_mode_label);
⋮----
.selected_text(if preset.prompt_mode == "dynamic" { text.prompt_mode_dynamic } else { text.prompt_mode_fixed })
⋮----
if ui.selectable_value(&mut preset.prompt_mode, "fixed".to_string(), text.prompt_mode_fixed).clicked() { changed = true; }
if ui.selectable_value(&mut preset.prompt_mode, "dynamic".to_string(), text.prompt_mode_dynamic).clicked() { changed = true; }
⋮----
ui.label(text.text_input_mode_label);
⋮----
.selected_text(if preset.text_input_mode == "type" { text.text_mode_type } else { text.text_mode_select })
⋮----
if ui.selectable_value(&mut preset.text_input_mode, "select".to_string(), text.text_mode_select).clicked() { changed = true; }
if ui.selectable_value(&mut preset.text_input_mode, "type".to_string(), text.text_mode_type).clicked() { changed = true; }
⋮----
if ui.checkbox(&mut preset.continuous_input, text.continuous_input_label).clicked() { changed = true; }
⋮----
let mode_label = match config.ui_language.as_str() {
⋮----
ui.label(mode_label);
let mode_record = match config.ui_language.as_str() {
⋮----
let mode_realtime = match config.ui_language.as_str() {
⋮----
.selected_text(selected_mode_text)
⋮----
if ui.selectable_value(&mut preset.audio_processing_mode, "record_then_process".to_string(), mode_record).clicked() { changed = true; }
if ui.selectable_value(&mut preset.audio_processing_mode, "realtime".to_string(), mode_realtime).clicked() { changed = true; }
⋮----
ui.add_space(8.0);
⋮----
let window_mode_label = match config.ui_language.as_str() {
⋮----
ui.label(window_mode_label);
let mode_standard = match config.ui_language.as_str() {
⋮----
let mode_minimal = match config.ui_language.as_str() {
⋮----
.selected_text(selected_window_mode)
⋮----
if ui.selectable_value(&mut preset.realtime_window_mode, "standard".to_string(), mode_standard).clicked() { changed = true; }
if ui.selectable_value(&mut preset.realtime_window_mode, "minimal".to_string(), mode_minimal).clicked() { changed = true; }
⋮----
ui.label(text.audio_source_label);
⋮----
if ui.selectable_value(&mut preset.audio_source, "mic".to_string(), text.audio_src_mic).clicked() { changed = true; }
if ui.selectable_value(&mut preset.audio_source, "device".to_string(), text.audio_src_device).clicked() { changed = true; }
⋮----
if ui.checkbox(&mut preset.hide_recording_ui, text.hide_recording_ui_label).clicked() { changed = true; }
⋮----
if ui.checkbox(&mut preset.auto_stop_recording, text.auto_stop_recording_label).clicked() { changed = true; }
⋮----
let has_any_auto_copy = preset.blocks.iter().any(|b| b.auto_copy);
⋮----
if ui.checkbox(&mut preset.auto_paste, text.auto_paste_label).clicked() { changed = true; }
let auto_copy_block = preset.blocks.iter().find(|b| b.auto_copy);
⋮----
if ui.checkbox(&mut preset.auto_paste_newline, text.auto_paste_newline_label).clicked() { changed = true; }
⋮----
ui.label(egui::RichText::new(text.hotkeys_section).strong());
⋮----
if *recording_hotkey_for_preset == Some(preset_idx) {
⋮----
ui.colored_label(text_color, text.press_keys);
⋮----
if ui.add(egui::Button::new(egui::RichText::new(text.cancel_label).color(egui::Color32::WHITE))
.fill(cancel_bg)
.corner_radius(10.0))
⋮----
if ui.add(egui::Button::new(egui::RichText::new(text.add_hotkey_button).color(egui::Color32::WHITE))
.fill(add_bg)
⋮----
.on_hover_cursor(egui::CursorIcon::PointingHand)
⋮----
*recording_hotkey_for_preset = Some(preset_idx);
⋮----
for (h_idx, hotkey) in preset.hotkeys.iter().enumerate() {
if ui.add(egui::Button::new(egui::RichText::new(format!("{} ×", hotkey.name)).color(egui::Color32::WHITE).small())
.fill(hotkey_bg)
⋮----
hotkey_to_remove = Some(h_idx);
⋮----
if let Some(h) = hotkey_to_remove { preset.hotkeys.remove(h); changed = true; }
⋮----
ui.colored_label(egui::Color32::RED, msg);
⋮----
ui.push_id("node_graph_area", |ui| {
⋮----
.fill(graph_bg)
.inner_margin(6.0)
.corner_radius(8.0)
⋮----
ui.set_min_height(325.0);
if render_node_graph(ui, snarl, &config.ui_language, &preset.prompt_mode, config.use_groq, config.use_gemini, config.use_openrouter, config.use_ollama, &preset.preset_type, text) {
⋮----
ui.add_space(20.0);
⋮----
.fill(bg_color)
.inner_margin(24.0)
.corner_radius(12.0)
⋮----
ui.set_min_height(260.0);
⋮----
match config.ui_language.as_str() {
⋮----
ui.label(egui::RichText::new(title).heading().color(accent_color));
ui.add_space(16.0);
⋮----
ui.label(egui::RichText::new(desc).color(text_color));
⋮----
fn create_default_block_for_type(preset_type: &str) -> ProcessingBlock {
⋮----
block_type: "audio".to_string(),
model: "whisper-accurate".to_string(),
prompt: "Transcribe this audio.".to_string(),
selected_language: "Vietnamese".to_string(),
⋮----
block_type: "text".to_string(),
model: "text_accurate_kimi".to_string(),
prompt: "Process this text.".to_string(),
⋮----
block_type: "image".to_string(),
model: "maverick".to_string(),
prompt: "Extract text from this image.".to_string(),
</file>

<file path="src/overlay/favorite_bubble/window.rs">
use super::render::update_bubble_visual;
⋮----
use crate::APP;
use std::sync::atomic::Ordering;
use windows::core::w;
⋮----
use windows::Win32::System::LibraryLoader::GetModuleHandleW;
⋮----
pub fn show_favorite_bubble() {
if BUBBLE_ACTIVE.swap(true, Ordering::SeqCst) {
⋮----
CURRENT_OPACITY.store(0, Ordering::SeqCst);
FADE_OUT_STATE.store(false, Ordering::SeqCst);
⋮----
create_bubble_window();
⋮----
pub fn hide_favorite_bubble() {
if !BUBBLE_ACTIVE.load(Ordering::SeqCst) {
⋮----
let hwnd_val = BUBBLE_HWND.load(Ordering::SeqCst);
⋮----
FADE_OUT_STATE.store(true, Ordering::SeqCst);
let hwnd = HWND(hwnd_val as *mut std::ffi::c_void);
⋮----
let _ = SetTimer(Some(hwnd), OPACITY_TIMER_ID, 16, None);
⋮----
pub fn trigger_blink_animation() {
⋮----
BLINK_STATE.store(1, Ordering::SeqCst);
⋮----
fn create_bubble_window() {
⋮----
let instance = GetModuleHandleW(None).unwrap_or_default();
let class_name = w!("SGTFavoriteBubble");
REGISTER_BUBBLE_CLASS.call_once(|| {
⋮----
lpfnWndProc: Some(bubble_wnd_proc),
hInstance: instance.into(),
⋮----
hCursor: LoadCursorW(None, IDC_HAND).unwrap_or_default(),
⋮----
RegisterClassW(&wc);
⋮----
let (initial_x, initial_y) = if let Ok(app) = APP.lock() {
app.config.favorite_bubble_position.unwrap_or_else(|| {
let screen_w = GetSystemMetrics(SM_CXSCREEN);
let screen_h = GetSystemMetrics(SM_CYSCREEN);
⋮----
let hwnd = CreateWindowExW(
⋮----
w!("FavBubble"),
⋮----
Some(instance.into()),
⋮----
.unwrap_or_default();
if hwnd.is_invalid() {
BUBBLE_ACTIVE.store(false, Ordering::SeqCst);
⋮----
BUBBLE_HWND.store(hwnd.0 as isize, Ordering::SeqCst);
update_bubble_visual(hwnd);
let _ = ShowWindow(hwnd, SW_SHOWNOACTIVATE);
⋮----
ensure_panel_created(hwnd, true);
⋮----
while GetMessageW(&mut msg, None, 0, 0).into() {
let _ = TranslateMessage(&msg);
DispatchMessageW(&msg);
⋮----
destroy_panel();
⋮----
BUBBLE_HWND.store(0, Ordering::SeqCst);
⋮----
unsafe extern "system" fn bubble_wnd_proc(
⋮----
let _ = KillTimer(Some(hwnd), PHYSICS_TIMER_ID);
PHYSICS_STATE.with(|p| *p.borrow_mut() = (0.0, 0.0));
IS_DRAGGING.store(true, Ordering::SeqCst);
IS_DRAGGING_MOVED.store(false, Ordering::SeqCst);
⋮----
DRAG_START_X.store(x as isize, Ordering::SeqCst);
DRAG_START_Y.store(y as isize, Ordering::SeqCst);
let _ = SetCapture(hwnd);
LRESULT(0)
⋮----
let was_dragging_moved = IS_DRAGGING_MOVED.load(Ordering::SeqCst);
IS_DRAGGING.store(false, Ordering::SeqCst);
let _ = ReleaseCapture();
⋮----
if IS_EXPANDED.load(Ordering::SeqCst) {
close_panel();
⋮----
show_panel(hwnd);
⋮----
let _ = SetTimer(Some(hwnd), PHYSICS_TIMER_ID, 16, None);
⋮----
if IS_DRAGGING.load(Ordering::SeqCst) && (wparam.0 & 0x0001) != 0 {
⋮----
if !IS_DRAGGING_MOVED.load(Ordering::SeqCst) {
let start_x = DRAG_START_X.load(Ordering::SeqCst) as i32;
let start_y = DRAG_START_Y.load(Ordering::SeqCst) as i32;
let dx = (x - start_x).abs();
let dy = (y - start_y).abs();
⋮----
IS_DRAGGING_MOVED.store(true, Ordering::SeqCst);
⋮----
if IS_DRAGGING_MOVED.load(Ordering::SeqCst) {
⋮----
let _ = GetWindowRect(hwnd, &mut rect);
⋮----
let _ = SystemParametersInfoW(
⋮----
Some(&mut work_area as *mut _ as *mut std::ffi::c_void),
SYSTEM_PARAMETERS_INFO_UPDATE_FLAGS(0),
⋮----
.clamp(work_area.left, work_area.right - BUBBLE_SIZE);
⋮----
.clamp(work_area.top, work_area.bottom - BUBBLE_SIZE);
⋮----
PHYSICS_STATE.with(|p| {
let (old_vx, old_vy) = *p.borrow();
⋮----
*p.borrow_mut() = (final_vx, final_vy);
⋮----
let _ = SetWindowPos(
⋮----
move_panel_to_bubble(new_x, new_y);
⋮----
if !IS_HOVERED.load(Ordering::SeqCst) {
IS_HOVERED.store(true, Ordering::SeqCst);
⋮----
let _ = TrackMouseEvent(&mut tme);
⋮----
IS_HOVERED.store(false, Ordering::SeqCst);
⋮----
let is_hovered = IS_HOVERED.load(Ordering::SeqCst);
let is_expanded = IS_EXPANDED.load(Ordering::SeqCst);
let blink_state = BLINK_STATE.load(Ordering::SeqCst);
let is_fading_out = FADE_OUT_STATE.load(Ordering::SeqCst);
⋮----
let current = CURRENT_OPACITY.load(Ordering::SeqCst);
⋮----
(current as u16 + step as u16).min(target as u16) as u8
⋮----
(current as i16 - step as i16).max(target as i16) as u8
⋮----
CURRENT_OPACITY.store(new_opacity, Ordering::SeqCst);
⋮----
let _ = KillTimer(Some(hwnd), OPACITY_TIMER_ID);
⋮----
let _ = PostMessageW(Some(hwnd), WM_CLOSE, WPARAM(0), LPARAM(0));
⋮----
BLINK_STATE.store(0, Ordering::SeqCst);
⋮----
BLINK_STATE.fetch_add(1, Ordering::SeqCst);
⋮----
let (mut vx, mut vy) = *p.borrow();
⋮----
if vx.abs() < 0.2 && vy.abs() < 0.2 {
⋮----
*p.borrow_mut() = (0.0, 0.0);
⋮----
*p.borrow_mut() = (vx, vy);
⋮----
move_panel_to_bubble(next_x as i32, next_y as i32);
⋮----
let _ = DestroyWindow(hwnd);
⋮----
PostQuitMessage(0);
⋮----
_ => DefWindowProcW(hwnd, msg, wparam, lparam),
</file>

<file path="src/overlay/result/refine_input.rs">
use std::collections::HashMap;
use std::num::NonZeroIsize;
use std::sync::Mutex;
use windows::core::w;
⋮----
struct RefineInputState {
⋮----
unsafe impl Send for RefineInputState {}
thread_local! {
⋮----
struct HwndWrapper(HWND);
impl HasWindowHandle for HwndWrapper {
fn window_handle(&self) -> Result<WindowHandle<'_>, HandleError> {
⋮----
Ok(unsafe { WindowHandle::borrow_raw(raw) })
⋮----
Err(HandleError::Unavailable)
⋮----
/// Window procedure for the refine input child window
unsafe extern "system" fn refine_wnd_proc(
⋮----
unsafe extern "system" fn refine_wnd_proc(
⋮----
// Apply pending text from cross-thread call
apply_pending_text();
LRESULT(0)
⋮----
// Apply history text replacement from cross-thread call
apply_history_text();
⋮----
_ => DefWindowProcW(hwnd, msg, wparam, lparam),
⋮----
/// Internal function to apply pending text (insert at cursor position)
fn apply_pending_text() {
⋮----
fn apply_pending_text() {
let pending = PENDING_TEXT.lock().unwrap().take();
⋮----
.replace('\\', "\\\\")
.replace('`', "\\`")
.replace("${", "\\${")
.replace('\n', " ") // Refine input is single line
.replace('\r', "");
REFINE_WEBVIEWS.with(|webviews| {
if let Some(wv) = webviews.borrow().get(&parent_key) {
// Insert at cursor position instead of replacing all text
let script = format!(
⋮----
let _ = wv.evaluate_script(&script);
⋮----
/// Internal function to apply history text (replace all content)
fn apply_history_text() {
⋮----
fn apply_history_text() {
let pending = PENDING_HISTORY_TEXT.lock().unwrap().take();
⋮----
.replace('\n', " ")
⋮----
// Replace all text (for history navigation)
⋮----
/// CSS for the compact refine input
const REFINE_CSS: &str = r#"
⋮----
/// Generate HTML for the refine input
fn get_refine_html(placeholder: &str) -> String {
⋮----
fn get_refine_html(placeholder: &str) -> String {
⋮----
let escaped = placeholder.replace('\'', "\\'");
format!(
⋮----
/// Show the refine input above the markdown view
/// Returns the child window handle for positioning
⋮----
/// Returns the child window handle for positioning
pub fn show_refine_input(parent_hwnd: HWND, placeholder: &str) -> bool {
⋮----
pub fn show_refine_input(parent_hwnd: HWND, placeholder: &str) -> bool {
⋮----
// Check if already exists
let exists = REFINE_WEBVIEWS.with(|webviews| webviews.borrow().contains_key(&parent_key));
⋮----
// Just focus existing
focus_refine_input(parent_hwnd);
⋮----
let _ = GetClientRect(parent_hwnd, &mut parent_rect);
⋮----
let width = parent_rect.right - 4; // 2px margin each side
// Create the child window for the WebView
let instance = GetModuleHandleW(None).unwrap();
// Use a simple static child window class
⋮----
let class_name = w!("SGT_RefineInput");
⋮----
wc.lpfnWndProc = Some(refine_wnd_proc);
wc.hInstance = instance.into();
⋮----
CLASS_ATOM = RegisterClassW(&wc);
⋮----
let child_hwnd = CreateWindowExW(
⋮----
w!("SGT_RefineInput"),
w!(""),
⋮----
input_height, // Position at top with small margin
Some(parent_hwnd),
⋮----
Some(instance.into()),
⋮----
if child_hwnd.is_err() {
⋮----
// Create WebView inside the child window
let html = get_refine_html(placeholder);
let child_hwnd = child_hwnd.unwrap();
let wrapper = HwndWrapper(child_hwnd);
// Initialize shared WebContext if needed (uses same data dir as other modules)
REFINE_WEB_CONTEXT.with(|ctx| {
if ctx.borrow().is_none() {
⋮----
*ctx.borrow_mut() = Some(WebContext::new(Some(shared_data_dir)));
⋮----
let result = REFINE_WEB_CONTEXT.with(|ctx| {
let mut ctx_ref = ctx.borrow_mut();
let builder = if let Some(web_ctx) = ctx_ref.as_mut() {
⋮----
.with_bounds(Rect {
⋮----
.with_html(&html)
.with_transparent(false)
.with_ipc_handler(move |msg: wry::http::Request<String>| {
let body = msg.body();
let mut states = REFINE_STATES.lock().unwrap();
if let Some(state) = states.get_mut(&parent_key_for_ipc) {
if body.starts_with("submit:") {
let text = body.strip_prefix("submit:").unwrap_or("").to_string();
// Save to history before submitting
⋮----
} else if body.starts_with("history_up:") {
let current = body.strip_prefix("history_up:").unwrap_or("");
⋮----
// Get the child window handle for posting message
⋮----
drop(states); // Release lock before posting
*PENDING_HISTORY_TEXT.lock().unwrap() =
Some((parent_key_for_ipc, text));
let _ = PostMessageW(
Some(child_hwnd),
⋮----
WPARAM(0),
LPARAM(0),
⋮----
} else if body.starts_with("history_down:") {
let current = body.strip_prefix("history_down:").unwrap_or("");
⋮----
drop(states);
⋮----
let app = crate::APP.lock().unwrap();
⋮----
.iter()
.position(|p| p.id == "preset_transcribe")
⋮----
.build_as_child(&wrapper)
⋮----
webviews.borrow_mut().insert(parent_key, webview);
⋮----
states.insert(
⋮----
let _ = DestroyWindow(child_hwnd);
⋮----
pub fn focus_refine_input(parent_hwnd: HWND) {
⋮----
let _ = SetForegroundWindow(parent_hwnd);
⋮----
if let Some(webview) = webviews.borrow().get(&parent_key) {
let _ = webview.focus();
let _ = webview.evaluate_script("document.getElementById('editor').focus();");
⋮----
pub fn poll_refine_input(parent_hwnd: HWND) -> (bool, bool, String) {
⋮----
if let Some(state) = states.get_mut(&parent_key) {
let result = (state.submitted, state.cancelled, state.text.clone());
⋮----
state.text.clear();
⋮----
pub fn hide_refine_input(parent_hwnd: HWND) {
⋮----
webviews.borrow_mut().remove(&parent_key);
⋮----
if let Some(state) = states.remove(&parent_key) {
⋮----
let _ = DestroyWindow(state.hwnd);
⋮----
pub fn is_refine_input_active(parent_hwnd: HWND) -> bool {
⋮----
let states = REFINE_STATES.lock().unwrap();
states.contains_key(&parent_key)
⋮----
pub fn bring_to_top(parent_hwnd: HWND) {
⋮----
if let Some(state) = states.get(&parent_key) {
⋮----
let _ = SetWindowPos(
⋮----
Some(HWND_TOP),
⋮----
pub fn is_any_refine_active() -> bool {
⋮----
!states.is_empty()
⋮----
pub fn get_active_refine_parent() -> Option<HWND> {
⋮----
.keys()
.next()
.map(|&k| HWND(k as *mut std::ffi::c_void))
⋮----
pub fn set_refine_text(parent_hwnd: HWND, text: &str) {
⋮----
states.get(&parent_key).map(|s| s.hwnd)
⋮----
*PENDING_TEXT.lock().unwrap() = Some((parent_key, text.to_string()));
⋮----
let _ = PostMessageW(Some(hwnd), WM_APP_SET_TEXT, WPARAM(0), LPARAM(0));
⋮----
pub fn resize_refine_input(parent_hwnd: HWND) {
⋮----
Some(HWND::default()),
⋮----
let _ = webview.set_bounds(Rect {
</file>

<file path="src/overlay/selection.rs">
use super::process::start_processing_pipeline;
⋮----
use std::sync::Arc;
⋮----
type MagInitializeFn = unsafe extern "system" fn() -> BOOL;
type MagUninitializeFn = unsafe extern "system" fn() -> BOOL;
type MagSetFullscreenTransformFn = unsafe extern "system" fn(f32, i32, i32) -> BOOL;
static mut MAG_DLL: HMODULE = HMODULE(std::ptr::null_mut());
⋮----
static mut SELECTION_OVERLAY_HWND: SendHwnd = SendHwnd(HWND(std::ptr::null_mut()));
⋮----
static mut SELECTION_HOOK: HHOOK = HHOOK(std::ptr::null_mut());
static mut CACHED_BITMAP: SendHbitmap = SendHbitmap(HBITMAP(std::ptr::null_mut()));
⋮----
unsafe fn load_magnification_api() -> bool {
let mag_dll = std::ptr::addr_of!(MAG_DLL).read();
if !mag_dll.is_invalid() {
⋮----
let dll_name = w!("Magnification.dll");
let dll = LoadLibraryW(dll_name);
⋮----
if let Some(init) = GetProcAddress(h, s!("MagInitialize")) {
MAG_INITIALIZE = Some(std::mem::transmute(init));
⋮----
if let Some(uninit) = GetProcAddress(h, s!("MagUninitialize")) {
MAG_UNINITIALIZE = Some(std::mem::transmute(uninit));
⋮----
if let Some(transform) = GetProcAddress(h, s!("MagSetFullscreenTransform")) {
MAG_SET_FULLSCREEN_TRANSFORM = Some(std::mem::transmute(transform));
⋮----
let init_ptr = std::ptr::addr_of!(MAG_INITIALIZE).read();
let trans_ptr = std::ptr::addr_of!(MAG_SET_FULLSCREEN_TRANSFORM).read();
return init_ptr.is_some() && trans_ptr.is_some();
⋮----
unsafe fn extract_crop_from_hbitmap(
⋮----
let hdc_screen = GetDC(None);
let hdc_mem = CreateCompatibleDC(Some(hdc_screen));
let old_obj = SelectObject(hdc_mem, capture.hbitmap.into());
let w = (crop_rect.right - crop_rect.left).abs();
let h = (crop_rect.bottom - crop_rect.top).abs();
⋮----
let mut buffer: Vec<u8> = vec![0; (w * h * 4) as usize];
let hdc_temp = CreateCompatibleDC(Some(hdc_screen));
let hbm_temp = CreateCompatibleBitmap(hdc_screen, w, h);
SelectObject(hdc_temp, hbm_temp.into());
let v_x = GetSystemMetrics(SM_XVIRTUALSCREEN);
let v_y = GetSystemMetrics(SM_YVIRTUALSCREEN);
⋮----
let _ = BitBlt(hdc_temp, 0, 0, w, h, Some(hdc_mem), src_x, src_y, SRCCOPY).ok();
GetDIBits(
⋮----
Some(buffer.as_mut_ptr() as *mut _),
⋮----
for chunk in buffer.chunks_exact_mut(4) {
chunk.swap(0, 2);
⋮----
let _ = DeleteObject(hbm_temp.into());
let _ = DeleteDC(hdc_temp);
SelectObject(hdc_mem, old_obj);
let _ = DeleteDC(hdc_mem);
ReleaseDC(None, hdc_screen);
image::ImageBuffer::from_raw(w as u32, h as u32, buffer).unwrap()
⋮----
pub fn is_selection_overlay_active_and_dismiss() -> bool {
⋮----
.read()
.is_invalid()
⋮----
let _ = PostMessageW(
Some(SELECTION_OVERLAY_HWND.0),
⋮----
WPARAM(0),
LPARAM(0),
⋮----
pub fn show_selection_overlay(preset_idx: usize) {
⋮----
SELECTION_ABORT_SIGNAL.store(false, Ordering::SeqCst);
let instance = GetModuleHandleW(None).unwrap();
let class_name = w!("SnippingOverlay");
⋮----
if !GetClassInfoW(Some(instance.into()), class_name, &mut wc).is_ok() {
wc.lpfnWndProc = Some(selection_wnd_proc);
wc.hInstance = instance.into();
wc.hCursor = LoadCursorW(None, IDC_CROSS).unwrap();
⋮----
wc.hbrBackground = CreateSolidBrush(COLORREF(0x00000000));
RegisterClassW(&wc);
⋮----
let x = GetSystemMetrics(SM_XVIRTUALSCREEN);
let y = GetSystemMetrics(SM_YVIRTUALSCREEN);
let w = GetSystemMetrics(SM_CXVIRTUALSCREEN);
let h = GetSystemMetrics(SM_CYVIRTUALSCREEN);
let hwnd = CreateWindowExW(
⋮----
w!("Snipping"),
⋮----
Some(instance.into()),
⋮----
.unwrap_or_default();
SELECTION_OVERLAY_HWND = SendHwnd(hwnd);
let hook = SetWindowsHookExW(
⋮----
Some(selection_hook_proc),
Some(GetModuleHandleW(None).unwrap().into()),
⋮----
sync_layered_window_contents(hwnd);
let _ = ShowWindow(hwnd, SW_SHOWNOACTIVATE);
let _ = SetTimer(Some(hwnd), FADE_TIMER_ID, 16, None);
⋮----
while PeekMessageW(&mut msg, None, 0, 0, PM_REMOVE).as_bool() {
let _ = TranslateMessage(&msg);
let _ = DispatchMessageW(&msg);
⋮----
if SELECTION_ABORT_SIGNAL.load(Ordering::SeqCst) {
let _ = SendMessageW(hwnd, WM_CLOSE, Some(WPARAM(0)), Some(LPARAM(0)));
⋮----
let _ = WaitMessage();
⋮----
let hook = std::ptr::addr_of!(SELECTION_HOOK).read();
if !hook.is_invalid() {
let _ = UnhookWindowsHookEx(hook);
SELECTION_HOOK = HHOOK(std::ptr::null_mut());
⋮----
unsafe extern "system" fn selection_hook_proc(
⋮----
SELECTION_ABORT_SIGNAL.store(true, Ordering::SeqCst);
let hwnd = std::ptr::addr_of!(SELECTION_OVERLAY_HWND).read().0;
if !hwnd.is_invalid() {
let _ = PostMessageW(Some(hwnd), WM_NULL, WPARAM(0), LPARAM(0));
⋮----
return LRESULT(1);
⋮----
CallNextHookEx(None, code, wparam, lparam)
⋮----
unsafe extern "system" fn selection_wnd_proc(
⋮----
let _ = GetCursorPos(std::ptr::addr_of_mut!(START_POS));
⋮----
SetCapture(hwnd);
⋮----
LRESULT(0)
⋮----
let _ = GetCursorPos(std::ptr::addr_of_mut!(LAST_PAN_POS));
⋮----
let _ = SetTimer(Some(hwnd), ZOOM_TIMER_ID, 16, None);
⋮----
let _ = ReleaseCapture();
⋮----
let _ = GetCursorPos(std::ptr::addr_of_mut!(CURR_POS));
⋮----
let _ = GetCursorPos(&mut curr_pan);
⋮----
let _ = GetCursorPos(&mut cursor);
⋮----
ZOOM_LEVEL = (ZOOM_LEVEL + ZOOM_STEP).min(MAX_ZOOM);
⋮----
ZOOM_LEVEL = (ZOOM_LEVEL - ZOOM_STEP).max(MIN_ZOOM);
⋮----
if load_magnification_api() {
⋮----
if init_fn().as_bool() {
⋮----
left: START_POS.x.min(CURR_POS.x),
top: START_POS.y.min(CURR_POS.y),
right: START_POS.x.max(CURR_POS.x),
bottom: START_POS.y.max(CURR_POS.y),
⋮----
let width = (rect.right - rect.left).abs();
let height = (rect.bottom - rect.top).abs();
⋮----
let _ = GetCursorPos(&mut pt);
let guard = APP.lock().unwrap();
⋮----
let old_bmp = SelectObject(hdc_mem, capture.hbitmap.into());
let sx = GetSystemMetrics(SM_XVIRTUALSCREEN);
let sy = GetSystemMetrics(SM_YVIRTUALSCREEN);
⋮----
let color = GetPixel(hdc_mem, local_x, local_y);
SelectObject(hdc_mem, old_bmp);
⋮----
let _ = ReleaseDC(None, hdc_screen);
⋮----
let hex_color = format!("#{:02X}{:02X}{:02X}", r, g, b);
⋮----
let _ = transform_fn(1.0, 0, 0);
⋮----
return LRESULT(0);
⋮----
.get(CURRENT_PRESET_IDX)
.map(|p| p.is_master)
.unwrap_or(false)
⋮----
let _ = GetCursorPos(&mut cursor_pos);
ZOOM_ALPHA_OVERRIDE = Some(60);
⋮----
Some(idx)
⋮----
SetTimer(Some(hwnd), FADE_TIMER_ID, 16, None);
⋮----
Some(CURRENT_PRESET_IDX)
⋮----
let mut guard = APP.lock().unwrap();
⋮----
.as_ref()
.expect("Screenshot handle missing");
let config_clone = guard.config.clone();
let preset_clone = guard.config.presets[preset_idx].clone();
let img = extract_crop_from_hbitmap(capture, rect);
⋮----
start_processing_pipeline(cropped_img, rect, config, preset);
⋮----
if diff_zoom.abs() > 0.001 {
⋮----
if dx.abs() > 0.1 || dy.abs() > 0.1 {
⋮----
let screen_w = GetSystemMetrics(SM_CXVIRTUALSCREEN);
let screen_h = GetSystemMetrics(SM_CYVIRTUALSCREEN);
let screen_x = GetSystemMetrics(SM_XVIRTUALSCREEN);
let screen_y = GetSystemMetrics(SM_YVIRTUALSCREEN);
⋮----
.max(screen_x as f32)
.min((screen_x + screen_w) as f32 - view_w);
⋮----
.max(screen_y as f32)
.min((screen_y + screen_h) as f32 - view_h);
let _ = transform_fn(RENDER_ZOOM, off_x as i32, off_y as i32);
⋮----
let _ = KillTimer(Some(hwnd), ZOOM_TIMER_ID);
⋮----
let _ = KillTimer(Some(hwnd), FADE_TIMER_ID);
let _ = DestroyWindow(hwnd);
PostQuitMessage(0);
⋮----
.min(TARGET_OPACITY as u16)
⋮----
let _ = BeginPaint(hwnd, &mut ps);
⋮----
let _ = EndPaint(hwnd, &mut ps);
⋮----
WM_ERASEBKGND => LRESULT(1),
⋮----
let _ = uninit_fn();
⋮----
if !std::ptr::addr_of!(CACHED_BITMAP).read().is_invalid() {
let _ = DeleteObject(CACHED_BITMAP.0.into());
⋮----
DefWindowProcW(hwnd, msg, wparam, lparam)
⋮----
_ => DefWindowProcW(hwnd, msg, wparam, lparam),
⋮----
unsafe fn sync_layered_window_contents(hwnd: HWND) {
let width = GetSystemMetrics(SM_CXVIRTUALSCREEN);
let height = GetSystemMetrics(SM_CYVIRTUALSCREEN);
⋮----
if std::ptr::addr_of!(CACHED_BITMAP).read().is_invalid()
⋮----
let hbm = CreateDIBSection(Some(hdc_screen), &bmi, DIB_RGB_COLORS, &mut bits, None, 0);
⋮----
CACHED_BITMAP = SendHbitmap(h);
⋮----
let mem_dc = CreateCompatibleDC(Some(hdc_screen));
let old_bmp = SelectObject(mem_dc, CACHED_BITMAP.0.into());
⋮----
zoom_alpha.min(CURRENT_ALPHA)
⋮----
pixels_u32.fill(bg_val);
⋮----
let w = (r.right - r.left).abs();
let h = (r.bottom - r.top).abs();
⋮----
let pen = CreatePen(PS_SOLID, 2, COLORREF(0x00FFFFFF));
let old_pen = SelectObject(mem_dc, pen.into());
let null_brush = GetStockObject(NULL_BRUSH);
let old_brush = SelectObject(mem_dc, null_brush);
let _ = RoundRect(mem_dc, r.left, r.top, r.right, r.bottom, 12, 12);
SelectObject(mem_dc, old_brush);
SelectObject(mem_dc, old_pen);
let _ = DeleteObject(pen.into());
let b_left = (r.left - 5).max(0);
let b_top = (r.top - 5).max(0);
let b_right = (r.right + 5).min(width);
let b_bottom = (r.bottom + 5).min(height);
⋮----
if row_start < pixels_u32.len() && row_end <= pixels_u32.len() {
⋮----
x: GetSystemMetrics(SM_XVIRTUALSCREEN),
y: GetSystemMetrics(SM_YVIRTUALSCREEN),
⋮----
let _ = UpdateLayeredWindow(
⋮----
Some(hdc_screen),
Some(&screen_pos),
Some(&wnd_size),
Some(mem_dc),
Some(&src_pos),
COLORREF(0),
Some(&blend),
⋮----
SelectObject(mem_dc, old_bmp);
let _ = DeleteDC(mem_dc);
</file>

<file path="src/gui/icons.rs">
use eframe::egui;
use std::f32::consts::PI;
⋮----
pub enum Icon {
⋮----
pub fn icon_button(ui: &mut egui::Ui, icon: Icon) -> egui::Response {
icon_button_sized(ui, icon, 24.0)
⋮----
pub fn icon_button_sized(ui: &mut egui::Ui, icon: Icon, size_val: f32) -> egui::Response {
⋮----
let (rect, response) = ui.allocate_exact_size(size, egui::Sense::click());
if response.hovered() {
ui.painter()
.rect_filled(rect.shrink(2.0), 4.0, ui.visuals().widgets.hovered.bg_fill);
⋮----
let color = if response.hovered() {
ui.visuals().widgets.hovered.fg_stroke.color
⋮----
ui.visuals().widgets.inactive.fg_stroke.color
⋮----
paint_internal(ui.painter(), rect, icon, color);
⋮----
pub fn draw_icon_static(ui: &mut egui::Ui, icon: Icon, size_override: Option<f32>) {
let side = size_override.unwrap_or(16.0);
let (rect, _) = ui.allocate_exact_size(egui::vec2(side, side), egui::Sense::hover());
let color = ui.visuals().text_color();
⋮----
pub fn paint_icon(painter: &egui::Painter, rect: egui::Rect, icon: Icon, color: egui::Color32) {
paint_internal(painter, rect, icon, color);
⋮----
fn paint_internal(painter: &egui::Painter, rect: egui::Rect, icon: Icon, color: egui::Color32) {
let center = rect.center();
let scale = rect.width().min(rect.height()) / 22.0;
⋮----
points.push(center + egui::vec2(theta_a.cos() * r, theta_a.sin() * r));
points.push(center + egui::vec2(theta_b.cos() * r, theta_b.sin() * r));
⋮----
points.push(points[0]);
painter.add(egui::Shape::line(points, stroke));
painter.circle_stroke(center, hole_r, stroke);
⋮----
let pts_top = bezier_points(p_left, p_top, p_right, 10);
let pts_bot = bezier_points(p_right, p_bot, p_left, 10);
⋮----
full_eye.extend(pts_bot);
painter.add(egui::Shape::line(full_eye, stroke));
painter.circle_filled(center, 2.5 * scale, color);
⋮----
let pts = bezier_points(p_left, p_top, p_right, 12);
painter.add(egui::Shape::line(pts, stroke));
⋮----
painter.line_segment(
⋮----
painter.rect_stroke(caps_rect, w / 2.0, stroke, egui::StrokeKind::Middle);
let y_start = caps_rect.top() + 3.5 * scale;
⋮----
let u_path = bezier_points(u_left, u_bot, u_right, 10);
painter.add(egui::Shape::line(u_path, stroke));
⋮----
let img_rect = rect.shrink(3.0 * scale);
painter.rect_stroke(img_rect, 2.0 * scale, stroke, egui::StrokeKind::Middle);
let p1 = img_rect.left_bottom() - egui::vec2(-1.0, 2.0) * scale;
let p2 = img_rect.left_bottom() + egui::vec2(3.0, -6.0) * scale;
let p3 = img_rect.left_bottom() + egui::vec2(6.0, -3.0) * scale;
let p4 = img_rect.left_bottom() + egui::vec2(9.0, -7.0) * scale;
let p5 = img_rect.right_bottom() - egui::vec2(1.0, 2.0) * scale;
painter.add(egui::Shape::line(vec![p1, p2, p3, p4, p5], stroke));
painter.circle_filled(
img_rect.left_top() + egui::vec2(3.5, 3.5) * scale,
⋮----
painter.add(egui::Shape::line(vec![p1, p2, p3, p4], stroke));
⋮----
let p1 = body_rect.left_top();
let p2 = body_rect.left_bottom();
let p3 = body_rect.right_bottom();
let p4 = body_rect.right_top();
let p5 = body_rect.left_top() + egui::vec2(tab_w, 0.0);
let p6 = body_rect.left_top() + egui::vec2(tab_w, -tab_h);
let p7 = body_rect.left_top() + egui::vec2(0.0, -tab_h);
painter.add(egui::Shape::line(
vec![p7, p1, p2, p3, p4, p5, p6, p7],
⋮----
painter.rect_stroke(back_rect, 1.0 * scale, stroke, egui::StrokeKind::Middle);
⋮----
painter.rect_filled(
⋮----
painter.ctx().style().visuals.panel_fill,
⋮----
painter.rect_stroke(front_rect, 1.0 * scale, stroke, egui::StrokeKind::Middle);
⋮----
painter.rect_stroke(back_rect, 0.8 * scale, stroke, egui::StrokeKind::Middle);
⋮----
painter.rect_stroke(front_rect, 0.8 * scale, stroke, egui::StrokeKind::Middle);
⋮----
painter.line_segment([p1, p2], stroke);
painter.line_segment([p3, p4], stroke);
⋮----
painter.rect_stroke(rect, 0.5 * scale, stroke, egui::StrokeKind::Middle);
let cone_pts = vec![
⋮----
painter.add(egui::Shape::closed_line(cone_pts, stroke));
⋮----
wave1_pts.push(egui::pos2(
wave_x + wave_r1 * angle.cos(),
center.y + wave_r1 * angle.sin(),
⋮----
painter.add(egui::Shape::line(wave1_pts, stroke));
⋮----
wave2_pts.push(egui::pos2(
wave_x + wave_r2 * angle.cos(),
center.y + wave_r2 * angle.sin(),
⋮----
painter.add(egui::Shape::line(wave2_pts, stroke));
⋮----
painter.circle_stroke(egui::pos2(center.x, bulb_cy), bulb_r, stroke);
⋮----
let wave_pts = vec![
⋮----
painter.add(egui::Shape::line(wave_pts, wave_stroke));
⋮----
points.push(egui::pos2(
center.x + r * angle.cos(),
center.y + r * angle.sin(),
⋮----
raw_points.push(egui::pos2(
⋮----
let p_start = lerp(p, p_prev, round_ratio);
let p_end = lerp(p, p_next, round_ratio);
let curve = bezier_points(p_start, p, p_end, 5);
path_points.extend(curve);
⋮----
path_points.push(p);
⋮----
painter.add(egui::Shape::Path(egui::epaint::PathShape {
⋮----
stroke: egui::Stroke::new(1.0 * scale, gold).into(),
⋮----
painter.circle_stroke(center, 4.0 * scale, stroke);
⋮----
let angle = (i as f32 * 45.0).to_radians();
let dir = egui::vec2(angle.cos(), angle.sin());
⋮----
painter.line_segment([start, end], stroke);
⋮----
painter.circle_filled(center, r, color);
⋮----
painter.rect_stroke(screen_rect, 1.0 * scale, stroke, egui::StrokeKind::Middle);
⋮----
painter.circle_filled(egui::pos2(cx, cy), r, color);
⋮----
fn lerp(a: egui::Pos2, b: egui::Pos2, t: f32) -> egui::Pos2 {
⋮----
fn lerp_quadratic(p0: egui::Pos2, p1: egui::Pos2, p2: egui::Pos2, t: f32) -> egui::Pos2 {
let l1 = lerp(p0, p1, t);
let l2 = lerp(p1, p2, t);
lerp(l1, l2, t)
⋮----
fn bezier_points(
⋮----
points.push(lerp_quadratic(p0, p1, p2, t));
</file>

<file path="src/overlay/favorite_bubble/state.rs">
use std::cell::RefCell;
⋮----
thread_local! {
⋮----
const ICON_PNG_BYTES: &[u8] = include_bytes!("../../../assets/app-icon-small.png");
const ICON_LIGHT_PNG_BYTES: &[u8] = include_bytes!("../../../assets/app-icon-small-light.png");
⋮----
fn decode_icon(bytes: &[u8]) -> Vec<u8> {
⋮----
let resized = img.resize_exact(
⋮----
resized.to_rgba8().into_raw()
⋮----
vec![]
</file>

<file path="src/overlay/mod.rs">
pub mod auto_copy_badge;
pub mod broom_assets;
pub mod input_history;
pub mod paint_utils;
pub mod preset_wheel;
pub mod process;
pub mod recording;
pub mod result;
mod selection;
pub mod text_input;
pub mod text_selection;
pub mod utils;
pub mod favorite_bubble;
pub mod html_components;
pub mod realtime_egui;
pub mod realtime_html;
pub mod realtime_webview;
pub mod tray_popup;
⋮----
pub use text_selection::show_text_selection_tag;
⋮----
pub fn get_shared_webview_data_dir() -> std::path::PathBuf {
let mut path = dirs::data_dir().unwrap_or_else(|| std::path::PathBuf::from("."));
path.push("SGT");
path.push("webview_data");
</file>

<file path="src/overlay/preset_wheel/html.rs">
use crate::config::Preset;
use crate::gui::settings_ui::get_localized_preset_name;
pub fn escape_html(s: &str) -> String {
s.replace('&', "&amp;")
.replace('<', "&lt;")
.replace('>', "&gt;")
.replace('"', "&quot;")
.replace('\'', "&#39;")
⋮----
fn calculate_row_distribution(n: usize) -> Vec<usize> {
⋮----
return vec![];
⋮----
return vec![1];
⋮----
let cols = ((n as f64 / squish_factor).sqrt().ceil() as usize).max(1);
⋮----
rows.push(base + 1);
⋮----
rows.push(base);
⋮----
pub fn generate_items_html(presets: &[(usize, Preset)], ui_lang: &str) -> String {
let n = presets.len();
let row_distribution = calculate_row_distribution(n);
⋮----
for (row_idx, &items_in_row) in row_distribution.iter().enumerate() {
html.push_str(&format!(
⋮----
if item_idx < presets.len() {
⋮----
let name = escape_html(&get_localized_preset_name(&preset.id, ui_lang));
let color_class = format!("color-{}", item_idx % 12);
⋮----
html.push_str("</div>");
⋮----
/// Returns the static HTML skeleton with CSS and JS (loaded once)
pub fn get_wheel_template(is_dark: bool) -> String {
⋮----
pub fn get_wheel_template(is_dark: bool) -> String {
⋮----
let css = generate_css(is_dark);
let js = get_js();
format!(
⋮----
/// Generate CSS for the wheel with light/dark theme support
pub fn generate_css(is_dark: bool) -> String {
⋮----
pub fn generate_css(is_dark: bool) -> String {
// Theme-specific colors
⋮----
fn get_js() -> &'static str {
</file>

<file path="src/overlay/result/markdown_view.rs">
use std::collections::HashMap;
use std::num::NonZeroIsize;
⋮----
use windows::core::w;
⋮----
static mut WARMUP_HWND: HWND = HWND(std::ptr::null_mut());
⋮----
thread_local! {
⋮----
struct HwndWrapper(HWND);
impl HasWindowHandle for HwndWrapper {
fn window_handle(&self) -> Result<WindowHandle<'_>, HandleError> {
⋮----
// hinstance is optional, can be null
⋮----
// Safety: the handle is valid for the lifetime of HwndWrapper
Ok(unsafe { WindowHandle::borrow_raw(raw) })
⋮----
Err(HandleError::Unavailable)
⋮----
/// Warmup markdown WebView - call from main.rs at app startup
/// This pre-initializes WebView2 infrastructure from the main thread context
⋮----
/// This pre-initializes WebView2 infrastructure from the main thread context
pub fn warmup() {
⋮----
pub fn warmup() {
⋮----
warmup_internal();
⋮----
fn warmup_internal() {
⋮----
let instance = GetModuleHandleW(None).unwrap();
let class_name = w!("SGT_MarkdownWarmup");
REGISTER_WARMUP_CLASS.call_once(|| {
⋮----
wc.lpfnWndProc = Some(warmup_wnd_proc);
wc.hInstance = instance.into();
⋮----
wc.hbrBackground = HBRUSH(std::ptr::null_mut());
let _ = RegisterClassW(&wc);
⋮----
// Create a small hidden window with WS_EX_NOACTIVATE to prevent focus stealing
let hwnd = CreateWindowExW(
⋮----
w!("MarkdownWarmup"),
⋮----
Some(instance.into()),
⋮----
.unwrap_or_default();
⋮----
// Make it transparent (invisible)
let _ = SetLayeredWindowAttributes(hwnd, COLORREF(0), 0, LWA_ALPHA);
// Initialize shared WebContext for this thread (reduces RAM by sharing browser processes)
// All modules use the same data directory, so WebView2 shares browser processes
⋮----
SHARED_WEB_CONTEXT.with(|ctx| {
if ctx.borrow().is_none() {
*ctx.borrow_mut() = Some(WebContext::new(Some(shared_data_dir)));
⋮----
// Create a WebView to warm up WebView2 infrastructure using shared context
// Include font CSS AND render text in those fonts to force browser to download them
let warmup_html = format!(
⋮----
let wrapper = HwndWrapper(hwnd);
let result = SHARED_WEB_CONTEXT.with(|ctx| {
let mut ctx_ref = ctx.borrow_mut();
if let Some(web_ctx) = ctx_ref.as_mut() {
⋮----
.with_bounds(Rect {
⋮----
.with_html(&warmup_html)
.with_transparent(false);
⋮----
.build_as_child(&wrapper)
⋮----
// Fallback without context
⋮----
WARMUP_WEBVIEW.with(|wv| {
*wv.borrow_mut() = Some(webview);
⋮----
// Mark as ready
if let Ok(mut ready) = WEBVIEW_READY.lock() {
⋮----
// Warmup failed - WebView2 may not work
⋮----
// Message loop to keep the warmup thread alive
⋮----
while GetMessageW(&mut msg, None, 0, 0).into() {
let _ = TranslateMessage(&msg);
DispatchMessageW(&msg);
⋮----
unsafe extern "system" fn warmup_wnd_proc(
⋮----
DefWindowProcW(hwnd, msg, wparam, lparam)
⋮----
fn get_font_style() -> String {
format!(
⋮----
fn is_html_content(content: &str) -> bool {
let trimmed = content.trim();
trimmed.starts_with("<!DOCTYPE") ||
trimmed.starts_with("<!doctype") ||
trimmed.starts_with("<html") ||
trimmed.starts_with("<HTML") ||
(trimmed.contains("<html") && trimmed.contains("</html>")) ||
(trimmed.contains("<head") && trimmed.contains("</head>")) ||
is_html_fragment(content)
⋮----
fn is_html_fragment(content: &str) -> bool {
let lower = content.to_lowercase();
(lower.contains("<script") || lower.contains("<style"))
&& !lower.contains("<!doctype")
&& !lower.contains("<html")
⋮----
fn wrap_html_fragment(fragment: &str) -> String {
⋮----
/// Inject localStorage/sessionStorage polyfill into HTML for WebView2 compatibility
/// WebView2's with_html() runs in a sandboxed context that denies storage access
⋮----
/// WebView2's with_html() runs in a sandboxed context that denies storage access
/// This provides an in-memory fallback so scripts don't crash
⋮----
/// This provides an in-memory fallback so scripts don't crash
fn inject_storage_polyfill(html: &str) -> String {
⋮----
fn inject_storage_polyfill(html: &str) -> String {
// First, wrap HTML fragments in a proper document structure
// This ensures WebView2 can properly parse the DOM (fixes "null" getElementById errors)
let html = if is_html_fragment(html) {
wrap_html_fragment(html)
⋮----
html.to_string()
⋮----
let lower = html.to_lowercase();
if let Some(pos) = lower.find("<head>") {
⋮----
let mut result = html[..insert_pos].to_string();
result.push_str(polyfill);
result.push_str(&html[insert_pos..]);
⋮----
} else if let Some(pos) = lower.find("<head ") {
if let Some(end) = html[pos..].find('>') {
⋮----
format!("{}{}", polyfill, html)
⋮----
} else if let Some(pos) = lower.find("<html>") {
⋮----
} else if let Some(pos) = lower.find("<html ") {
⋮----
fn inject_gridjs(html: &str) -> String {
if !html.contains("<table") {
return html.to_string();
⋮----
let gridjs_head = format!(
⋮----
let gridjs_body = format!(
⋮----
let mut result = html.to_string();
// Inject CSS/JS into <head>
if let Some(pos) = lower.find("</head>") {
result.insert_str(pos, &gridjs_head);
} else if let Some(pos) = lower.find("<body>") {
⋮----
result.insert_str(0, &gridjs_head);
⋮----
// Inject init script into <body>
let lower_updated = result.to_lowercase();
if let Some(pos) = lower_updated.find("</body>") {
result.insert_str(pos, &gridjs_body);
⋮----
result.push_str(&gridjs_body);
⋮----
/// Convert markdown text to styled HTML, or pass through raw HTML
pub fn markdown_to_html(
⋮----
pub fn markdown_to_html(
⋮----
let combined = if input_text.is_empty() {
preset_prompt.to_string()
⋮----
format!("{}\n\n{}", preset_prompt, input_text)
⋮----
return format!(
⋮----
// If input is already HTML, inject localStorage polyfill and Grid.js
if is_html_content(markdown) {
let with_storage = inject_storage_polyfill(markdown);
return inject_gridjs(&with_storage);
⋮----
options.insert(Options::ENABLE_TABLES);
options.insert(Options::ENABLE_STRIKETHROUGH);
options.insert(Options::ENABLE_TASKLISTS);
⋮----
// Grid.js Integration
let has_table = html_output.contains("<table");
⋮----
/// Create a WebView child window for markdown rendering
/// Must be called from the main thread!
⋮----
/// Must be called from the main thread!
pub fn create_markdown_webview(parent_hwnd: HWND, markdown_text: &str, is_hovered: bool) -> bool {
⋮----
pub fn create_markdown_webview(parent_hwnd: HWND, markdown_text: &str, is_hovered: bool) -> bool {
⋮----
let states = super::state::WINDOW_STATES.lock().unwrap();
if let Some(state) = states.get(&hwnd_key) {
⋮----
state.preset_prompt.clone(),
state.input_text.clone(),
⋮----
create_markdown_webview_ex(
⋮----
/// Create a WebView child window for markdown rendering (Internal version, call without lock if possible)
pub fn create_markdown_webview_ex(
⋮----
pub fn create_markdown_webview_ex(
⋮----
// Check if we already have a webview
let exists = WEBVIEWS.with(|webviews| webviews.borrow().contains_key(&hwnd_key));
⋮----
return update_markdown_content_ex(
⋮----
// Get parent window rect
⋮----
let _ = GetClientRect(parent_hwnd, &mut rect);
⋮----
let html_content = markdown_to_html(markdown_text, is_refining, preset_prompt, input_text);
let wrapper = HwndWrapper(parent_hwnd);
// Small margin on edges for resize handle accessibility (2px)
// 52px at bottom for buttons (btn_size 28 + margin 12 * 2) if hovered
⋮----
let content_width = ((rect.right - rect.left) as f64 - edge_margin * 2.0).max(50.0);
⋮----
((rect.bottom - rect.top) as f64 - edge_margin - button_area_height).max(50.0);
// Create WebView with small margins so resize handles remain accessible
// Use Physical coordinates since GetClientRect returns physical pixels
⋮----
// SIMPLIFIED FOR DEBUGGING - minimal WebView creation
// CRITICAL: with_transparent(false) matches text_input's working config
⋮----
.with_html(&html_content)
.with_transparent(false)
.with_navigation_handler(move |url: String| {
// Check if we should skip this navigation (triggered by history.back())
⋮----
let mut skip_map = SKIP_NEXT_NAVIGATION.lock().unwrap();
if skip_map.get(&hwnd_key_for_nav).copied().unwrap_or(false) {
skip_map.insert(hwnd_key_for_nav, false);
⋮----
// This navigation was from history.back(), don't increment depth
⋮----
// Detect when user navigates to an external URL (clicked a link)
// CRITICAL: Exclude wry internal URLs to prevent counting original content as browsing
let is_internal = url.contains("wry.localhost")
|| url.contains("localhost")
|| url.contains("127.0.0.1")
|| url.starts_with("data:")
|| url.starts_with("about:");
⋮----
(url.starts_with("http://") || url.starts_with("https://")) && !is_internal;
⋮----
if let Ok(mut states) = super::state::WINDOW_STATES.lock() {
if let Some(state) = states.get_mut(&hwnd_key_for_nav) {
⋮----
super::refine_input::hide_refine_input(HWND(
⋮----
Some(HWND(hwnd_key_for_nav as *mut std::ffi::c_void)),
⋮----
.with_ipc_handler(move |msg: wry::http::Request<String>| {
let body = msg.body();
if body.starts_with("opacity:") {
if let Ok(opacity_percent) = body["opacity:".len()..].parse::<f32>() {
⋮----
use windows::Win32::Foundation::COLORREF;
⋮----
SetLayeredWindowAttributes(parent_hwnd, COLORREF(0), alpha, LWA_ALPHA);
⋮----
.build_as_child(&wrapper);
⋮----
WEBVIEWS.with(|webviews| {
webviews.borrow_mut().insert(hwnd_key, webview);
⋮----
let mut states = WEBVIEW_STATES.lock().unwrap();
states.insert(hwnd_key, true);
⋮----
pub fn go_back(parent_hwnd: HWND) {
⋮----
let mut states = super::state::WINDOW_STATES.lock().unwrap();
if let Some(state) = states.get_mut(&hwnd_key) {
⋮----
(true, state.full_text.clone(), state.is_hovered)
⋮----
create_markdown_webview(parent_hwnd, &markdown_text, is_hovered);
⋮----
let _ = windows::Win32::Graphics::Gdi::InvalidateRect(Some(parent_hwnd), None, false);
⋮----
skip_map.insert(hwnd_key, true);
⋮----
if let Some(webview) = webviews.borrow().get(&hwnd_key) {
let _ = webview.evaluate_script("history.back();");
⋮----
pub fn go_forward(parent_hwnd: HWND) {
⋮----
let _ = webview.evaluate_script("history.forward();");
⋮----
pub fn update_markdown_content(parent_hwnd: HWND, markdown_text: &str) -> bool {
⋮----
update_markdown_content_ex(
⋮----
fn content_needs_recreation(html: &str) -> bool {
⋮----
lower.contains("<script")
&& (lower.contains("localstorage")
|| lower.contains("sessionstorage")
|| lower.contains("indexeddb")
|| lower.contains("const ")
|| lower.contains("let ")
|| lower.contains("var "))
⋮----
pub fn update_markdown_content_ex(
⋮----
let html = markdown_to_html(markdown_text, is_refining, preset_prompt, input_text);
if content_needs_recreation(&html) {
destroy_markdown_webview(parent_hwnd);
⋮----
if let Ok(states) = super::state::WINDOW_STATES.lock() {
states.get(&hwnd_key).map(|s| s.is_hovered).unwrap_or(false)
⋮----
return create_markdown_webview_ex(
⋮----
.replace('\\', "\\\\")
.replace('`', "\\`")
.replace("${", "\\${");
let script = format!(
⋮----
let _ = webview.evaluate_script(&script);
⋮----
pub fn resize_markdown_webview(parent_hwnd: HWND, is_hovered: bool) {
⋮----
((rect.bottom - rect.top) as f64 - top_offset - button_area_height).max(50.0);
⋮----
let _ = webview.set_bounds(Rect {
⋮----
pub fn hide_markdown_webview(parent_hwnd: HWND) {
⋮----
let _ = webview.set_visible(false);
⋮----
pub fn show_markdown_webview(parent_hwnd: HWND) {
⋮----
let _ = webview.set_visible(true);
⋮----
pub fn destroy_markdown_webview(parent_hwnd: HWND) {
⋮----
webviews.borrow_mut().remove(&hwnd_key);
⋮----
states.remove(&hwnd_key);
⋮----
pub fn has_markdown_webview(parent_hwnd: HWND) -> bool {
⋮----
let states = WEBVIEW_STATES.lock().unwrap();
states.get(&hwnd_key).copied().unwrap_or(false)
⋮----
fn generate_filename(content: &str) -> String {
let default_name = "game.html".to_string();
let groq_key = if let Ok(app) = crate::APP.lock() {
app.config.api_key.clone()
⋮----
if groq_key.is_empty() {
⋮----
let prompt_content = if content.len() > 4000 {
⋮----
let prompt = format!(
⋮----
.post("https://api.groq.com/openai/v1/chat/completions")
.set("Authorization", &format!("Bearer {}", groq_key))
.send_json(payload)
⋮----
.get("choices")
.and_then(|c| c.as_array())
.and_then(|c| c.first())
⋮----
.get("message")
.and_then(|m| m.get("content"))
.and_then(|s| s.as_str())
⋮----
let mut name = content.trim().to_string();
name = name.replace('"', "").replace('\'', "").replace('`', "");
// Remove potential .html extension if the model disobeyed
if name.to_lowercase().ends_with(".html") {
name = name[..name.len() - 5].to_string();
⋮----
if name.to_lowercase().ends_with("-html") {
⋮----
} else if name.to_lowercase().ends_with("_html") {
⋮----
.chars()
.filter(|c| !invalid_chars.contains(c))
.collect();
if name.is_empty() {
⋮----
name.push_str(".html");
⋮----
eprintln!("Failed to generate filename: {}", e);
⋮----
pub fn save_html_file(markdown_text: &str) -> bool {
use std::ffi::OsStr;
use std::os::windows::ffi::OsStrExt;
use windows::core::PCWSTR;
⋮----
use windows::Win32::UI::Shell::Common::COMDLG_FILTERSPEC;
use windows::Win32::UI::Shell::KNOWN_FOLDER_FLAG;
⋮----
let _ = CoInitializeEx(None, COINIT_APARTMENTTHREADED);
let dialog: IFileSaveDialog = match CoCreateInstance(&FileSaveDialog, None, CLSCTX_ALL) {
⋮----
CoUninitialize();
⋮----
.encode_wide()
.chain(std::iter::once(0))
⋮----
pszName: windows::core::PCWSTR(filter_name.as_ptr()),
pszSpec: windows::core::PCWSTR(filter_pattern.as_ptr()),
⋮----
let _ = dialog.SetFileTypes(&file_types);
let _ = dialog.SetFileTypeIndex(1);
⋮----
SHGetKnownFolderPath(&FOLDERID_Downloads, KNOWN_FOLDER_FLAG(0), None)
⋮----
SHCreateItemFromParsingName::<PCWSTR, _, IShellItem>(PCWSTR(downloads_path.0), None)
⋮----
let _ = dialog.SetFolder(&folder_item);
⋮----
let _ = dialog.SetDefaultExtension(windows::core::PCWSTR(default_ext.as_ptr()));
let filename = generate_filename(markdown_text);
⋮----
let _ = dialog.SetFileName(windows::core::PCWSTR(default_name.as_ptr()));
let _ = dialog.SetOptions(FOS_OVERWRITEPROMPT | FOS_STRICTFILETYPES);
if dialog.Show(None).is_err() {
⋮----
let result: windows::Win32::UI::Shell::IShellItem = match dialog.GetResult() {
⋮----
let path: windows::core::PWSTR = match result.GetDisplayName(SIGDN_FILESYSPATH) {
⋮----
let path_str = path.to_string().unwrap_or_default();
windows::Win32::System::Com::CoTaskMemFree(Some(path.0 as *const _));
⋮----
let html_content = markdown_to_html(markdown_text, false, "", "");
</file>

<file path="src/gui/app.rs">
mod init;
mod input_handler;
mod logic;
mod rendering;
mod types;
mod utils;
pub use types::SettingsApp;
pub use utils::signal_restore_window;
use eframe::egui;
⋮----
fn clear_color(&self, _visuals: &egui::Visuals) -> [f32; 4] {
⋮----
fn update(&mut self, ctx: &egui::Context, _frame: &mut eframe::Frame) {
⋮----
self.check_updater();
self.update_theme_and_tray(ctx);
self.update_startup(ctx);
self.update_bubble_sync();
self.update_splash(ctx);
self.check_restore_signal(ctx);
self.update_hotkey_recording(ctx);
self.handle_events(ctx);
self.handle_close_request(ctx);
self.update_tips_logic(ctx);
self.render_footer_and_tips_modal(ctx);
self.render_main_layout(ctx);
self.render_fade_overlay(ctx);
⋮----
splash.paint(ctx);
⋮----
self.render_drop_overlay(ctx);
⋮----
fn on_exit(&mut self, _gl: Option<&eframe::glow::Context>) {
</file>

<file path="src/overlay/process/chain.rs">
use crate::gui::settings_ui::get_localized_preset_name;
⋮----
use crate::overlay::text_input;
use crate::win_types::SendHwnd;
⋮----
use super::window::create_processing_window;
pub fn execute_chain_pipeline(
⋮----
let graphics_mode = config.graphics_mode.clone();
let processing_hwnd = unsafe { create_processing_window(rect, graphics_mode) };
⋮----
let _ = SendMessageW(processing_hwnd, WM_TIMER, Some(WPARAM(1)), Some(LPARAM(0)));
⋮----
let conf_clone = config.clone();
let blocks = preset.blocks.clone();
let connections = preset.block_connections.clone();
let preset_id = preset.id.clone();
let processing_hwnd_send = SendHwnd(processing_hwnd);
⋮----
reset_window_position_queue();
run_chain_step(
⋮----
Some(processing_hwnd_send),
⋮----
while GetMessageW(&mut msg, None, 0, 0).into() {
let _ = TranslateMessage(&msg);
DispatchMessageW(&msg);
if !IsWindow(Some(processing_hwnd)).as_bool() {
⋮----
pub fn execute_chain_pipeline_with_token(
⋮----
preset.id.clone(),
⋮----
pub fn run_chain_step(
⋮----
if cancel_token.load(Ordering::Relaxed) {
⋮----
let _ = PostMessageW(Some(h.0), WM_CLOSE, WPARAM(0), LPARAM(0));
⋮----
if block_idx >= blocks.len() {
⋮----
let model_id = block.model.clone();
⋮----
.clone()
.map(|m| m.provider)
.unwrap_or("groq".to_string());
let model_full_name = model_conf.map(|m| m.full_name).unwrap_or(model_id.clone());
let mut final_prompt = block.prompt.clone();
⋮----
final_prompt = final_prompt.replace(&format!("{{{}}}", key), value);
⋮----
if final_prompt.contains("{language1}") && !block.language_vars.contains_key("language1") {
final_prompt = final_prompt.replace("{language1}", &block.selected_language);
⋮----
final_prompt = final_prompt.replace("{language}", &block.selected_language);
⋮----
.iter()
.take(block_idx)
.filter(|b| b.show_overlay)
.count();
let bg_color = get_chain_color(visible_count_before);
⋮----
get_next_window_position(current_rect)
⋮----
context.clone()
⋮----
let m_id = model_id.clone();
let prov = provider.clone();
let prompt_c = final_prompt.clone();
⋮----
let render_md = block.render_mode.clone();
let parent_clone = parent_hwnd.clone();
⋮----
block.block_type == "input_adapter" && matches!(context, RefineContext::Image(_));
⋮----
use base64::Engine;
let base64_img = base64::engine::general_purpose::STANDARD.encode(png_data);
format!(
⋮----
let base64_audio = base64::engine::general_purpose::STANDARD.encode(wav_data);
⋮----
RefineContext::None => input_text.clone(),
⋮----
let initial_content_clone = initial_content.clone();
let cancel_token_thread = cancel_token.clone();
⋮----
// NOTE: wry handles COM internally, explicit initialization may interfere
let hwnd = create_result_window(
⋮----
// Assign cancellation token immediately for linking/grouping
// This is critical for input adapters since we don't wait for them in main thread
⋮----
let mut s = WINDOW_STATES.lock().unwrap();
if let Some(st) = s.get_mut(&(hwnd.0 as isize)) {
st.cancellation_token = Some(cancel_token_thread.clone());
⋮----
if let Ok(p_guard) = parent_clone.lock() {
⋮----
link_windows(ph.0, hwnd);
⋮----
// For image blocks: DON'T show window yet - keep it hidden
// It will be shown when first data arrives (in the streaming callback)
// For text blocks: show immediately with refining animation
⋮----
let _ = ShowWindow(hwnd, SW_SHOW);
⋮----
let _ = tx_hwnd.send(SendHwnd(hwnd));
⋮----
// If it's an image input adapter, set opacity to 255 (full opaque)
// This allows the image itself to be fully visible, while the slider controls the image opacity
⋮----
// Import SetLayeredWindowAttributes locally if needed, or assume it's available via windows crate
use windows::Win32::Foundation::COLORREF;
⋮----
let _ = SetLayeredWindowAttributes(hwnd, COLORREF(0), 255, LWA_ALPHA);
⋮----
while GetMessageW(&mut m, None, 0, 0).into() {
let _ = TranslateMessage(&m);
DispatchMessageW(&m);
if !IsWindow(Some(hwnd)).as_bool() {
⋮----
my_hwnd = rx_hwnd.recv().ok().map(|h| h.0);
⋮----
if let Some(st) = s.get_mut(&(h.0 as isize)) {
st.cancellation_token = Some(cancel_token.clone());
⋮----
if !skip_execution && my_hwnd.is_some() {
⋮----
if let Some(st) = s.get_mut(&(my_hwnd.unwrap().0 as isize)) {
⋮----
st.input_text = input_text.clone();
⋮----
let input_text_for_history = input_text.clone();
⋮----
input_text.clone()
⋮----
update_window_text(h, &input_text);
⋮----
let groq_key = config.api_key.clone();
let gemini_key = config.gemini_api_key.clone();
let use_json = block_idx == 0 && blocks.len() == 1 && blocks[0].block_type == "image";
⋮----
let acc_clone = accumulated.clone();
⋮----
.position(|b| b.block_type != "input_adapter")
.map(|pos| pos == block_idx)
.unwrap_or(false);
let model_name_for_error = model_full_name.clone();
⋮----
let window_shown_clone = window_shown.clone();
⋮----
let processing_hwnd_clone = processing_hwnd_shared.clone();
⋮----
&& matches!(context, RefineContext::Image(_))
⋮----
if let RefineContext::Image(img_data) = context.clone() {
⋮----
.expect("Failed to load png")
.to_rgba8();
let acc_clone_inner = acc_clone.clone();
⋮----
let window_shown_inner = window_shown_clone.clone();
let proc_hwnd_inner = processing_hwnd_clone.clone();
translate_image_streaming(
⋮----
let mut t = acc_clone_inner.lock().unwrap();
if chunk.starts_with(crate::api::WIPE_SIGNAL) {
t.clear();
t.push_str(&chunk[crate::api::WIPE_SIGNAL.len()..]);
⋮----
t.push_str(chunk);
⋮----
let mut shown = window_shown_inner.lock().unwrap();
⋮----
let _ = ShowWindow(h, SW_SHOW);
⋮----
let mut proc_hwnd = proc_hwnd_inner.lock().unwrap();
if let Some(ph) = proc_hwnd.take() {
⋮----
let _ = PostMessageW(
Some(ph.0),
⋮----
WPARAM(0),
LPARAM(0),
⋮----
update_window_text(h, &t);
⋮----
Err(anyhow::anyhow!("Missing image context"))
⋮----
let search_label = Some(get_localized_preset_name(&preset_id, &config.ui_language));
translate_text_streaming(
⋮----
let mut t = acc_clone.lock().unwrap();
⋮----
update_window_text(h, &txt);
⋮----
let lang = config.ui_language.clone();
⋮----
&e.to_string(),
⋮----
Some(&model_name_for_error),
⋮----
let mut shown = window_shown.lock().unwrap();
⋮----
let mut proc_hwnd = processing_hwnd_shared.lock().unwrap();
⋮----
PostMessageW(Some(ph.0), WM_CLOSE, WPARAM(0), LPARAM(0));
⋮----
update_window_text(h, &err);
⋮----
let has_content = !result_text.trim().is_empty();
⋮----
let img_data_clone = img_data.clone();
⋮----
let image_copied = is_input_adapter && matches!(context, RefineContext::Image(_));
⋮----
let txt_c = result_text.clone();
let txt_for_badge = result_text.clone();
⋮----
let preset_id_clone = preset_id.clone();
⋮----
let app = crate::APP.lock().unwrap();
⋮----
app.config.presets.iter().find(|p| p.id == preset_id_clone)
⋮----
if active_idx < app.config.presets.len() {
⋮----
let final_text = if !txt_c.trim().is_empty() {
⋮----
format!("{}\n", txt_c)
⋮----
txt_c.clone()
⋮----
if txt_c.trim().is_empty() {
⋮----
if block.auto_speak && !result_text.trim().is_empty() {
let txt_s = result_text.clone();
⋮----
crate::api::tts::TTS_MANAGER.speak(&txt_s, 0);
⋮----
if block.show_overlay && !result_text.trim().is_empty() {
let text_for_history = result_text.clone();
⋮----
let input_text_clone = input_text_for_history.clone();
⋮----
if let Ok(app) = crate::APP.lock() {
app.history.save_text(text_for_history, input_text_clone);
⋮----
if let RefineContext::Image(img_bytes) = context.clone() {
⋮----
let img_buffer = img_dynamic.to_rgba8();
⋮----
app.history.save_image(img_buffer, text_for_history);
⋮----
let should_continue = !result_text.trim().is_empty() || block.block_type == "input_adapter";
⋮----
.filter(|(from, _)| *from == block_idx)
.map(|(_, to)| *to)
.collect();
let next_blocks: Vec<usize> = if connections.is_empty() {
if block_idx + 1 < blocks.len() {
vec![block_idx + 1]
⋮----
vec![]
⋮----
if next_blocks.is_empty() {
⋮----
let next_parent = if my_hwnd.is_some() {
Arc::new(Mutex::new(my_hwnd.map(|h| SendHwnd(h))))
⋮----
let base_rect = if my_hwnd.is_some() {
⋮----
let parallel_branches: Vec<usize> = next_blocks.into_iter().skip(1).collect();
⋮----
let _s_w = unsafe { GetSystemMetrics(SM_CXSCREEN) };
let _s_h = unsafe { GetSystemMetrics(SM_CYSCREEN) };
for (branch_index, next_idx) in parallel_branches.iter().enumerate() {
let result_clone = result_text.clone();
let blocks_clone = blocks.clone();
let conns_clone = connections.clone();
let config_clone = config.clone();
let cancel_clone = cancel_token.clone();
let parent_clone = next_parent.clone();
⋮----
let branch_context = next_context.clone();
⋮----
let _ = CoInitializeEx(None, COINIT_APARTMENTTHREADED);
⋮----
blocks.clone(),
</file>

<file path="src/overlay/favorite_bubble/html.rs">
use crate::config::Preset;
use crate::gui::settings_ui::get_localized_preset_name;
pub fn generate_panel_html(presets: &[Preset], lang: &str, is_dark: bool) -> String {
let css = generate_panel_css(is_dark);
let favorites_html = get_favorite_presets_html(presets, lang, is_dark);
⋮----
format!(
⋮----
pub fn generate_panel_css(is_dark: bool) -> String {
⋮----
// Theme-specific colors
⋮----
pub fn get_favorite_presets_html(presets: &[Preset], lang: &str, is_dark: bool) -> String {
⋮----
for (idx, preset) in presets.iter().enumerate() {
⋮----
let name = if preset.id.starts_with("preset_") {
get_localized_preset_name(&preset.id, lang)
⋮----
preset.name.clone()
⋮----
let (icon_svg, color_hex) = match preset.preset_type.as_str() {
⋮----
let item = format!(
⋮----
html_items.push_str(&item);
⋮----
if html_items.is_empty() {
⋮----
html_items = format!(
⋮----
fn html_escape(s: &str) -> String {
s.replace('&', "&amp;")
.replace('<', "&lt;")
.replace('>', "&gt;")
.replace('"', "&quot;")
⋮----
pub fn escape_js(text: &str) -> String {
text.replace('\\', "\\\\")
.replace('"', "\\\"")
.replace('\n', "\\n")
.replace('\r', "")
</file>

<file path="src/overlay/preset_wheel/window.rs">
use crate::config::Preset;
use crate::APP;
use std::cell::RefCell;
⋮----
use windows::core::w;
⋮----
use windows::Win32::Graphics::Dwm::DwmExtendFrameIntoClientArea;
⋮----
use windows::Win32::System::LibraryLoader::GetModuleHandleW;
use windows::Win32::UI::Controls::MARGINS;
⋮----
thread_local! {
⋮----
struct HwndWrapper(HWND);
unsafe impl Send for HwndWrapper {}
unsafe impl Sync for HwndWrapper {}
⋮----
fn window_handle(
⋮----
std::num::NonZeroIsize::new(self.0 .0 as isize).expect("HWND cannot be null"),
⋮----
unsafe { Ok(raw_window_handle::WindowHandle::borrow_raw(handle)) }
⋮----
pub fn warmup() {
// Prevent multiple warmup threads from spawning
⋮----
.compare_exchange(false, true, Ordering::SeqCst, Ordering::SeqCst)
.is_err()
⋮----
internal_create_window_loop();
⋮----
pub fn show_preset_wheel(
⋮----
WHEEL_RESULT.store(-1, Ordering::SeqCst);
WHEEL_ACTIVE.store(true, Ordering::SeqCst);
*SELECTED_PRESET.lock().unwrap() = None;
⋮----
let app = APP.lock().unwrap();
⋮----
app.config.presets.clone(),
app.config.ui_language.clone(),
⋮----
// Generate themed CSS for injection
let themed_css = generate_css(is_dark);
⋮----
.iter()
.enumerate()
.filter(|(_, p)| {
⋮----
.map(|(i, p)| (i, p.clone()))
.collect();
if filtered.is_empty() {
WHEEL_ACTIVE.store(false, Ordering::SeqCst);
⋮----
let dismiss_label = match ui_lang.as_str() {
⋮----
let screen_w = GetSystemMetrics(SM_CXSCREEN);
let screen_h = GetSystemMetrics(SM_CYSCREEN);
⋮----
.max(0)
.min(screen_w - WHEEL_WIDTH);
⋮----
.min(screen_h - WHEEL_HEIGHT);
let items_html = generate_items_html(&filtered, &ui_lang);
*PENDING_ITEMS_HTML.lock().unwrap() = items_html;
*PENDING_DISMISS_LABEL.lock().unwrap() = dismiss_label.to_string();
*PENDING_CSS.lock().unwrap() = themed_css;
*PENDING_POS.lock().unwrap() = (win_x, win_y);
let hwnd_val = WHEEL_HWND.load(Ordering::SeqCst);
let wheel_hwnd = HWND(hwnd_val as *mut _);
if !wheel_hwnd.is_invalid() {
let _ = PostMessageW(Some(wheel_hwnd), WM_APP_SHOW, WPARAM(0), LPARAM(0));
⋮----
// Check if already warming up, if not, start it
if !IS_WARMING_UP.load(Ordering::SeqCst) {
warmup();
⋮----
// Polling loop: Wait up to 2 seconds for initialization to complete
// This prevents "failing once then working" or "spinning cursor" issues
⋮----
let res = WHEEL_RESULT.load(Ordering::SeqCst);
⋮----
if PeekMessageW(&mut msg, None, 0, 0, PM_REMOVE).as_bool() {
let _ = TranslateMessage(&msg);
DispatchMessageW(&msg);
⋮----
Some(res as usize)
⋮----
pub fn dismiss_wheel() {
⋮----
let _ = PostMessageW(Some(wheel_hwnd), WM_APP_HIDE, WPARAM(0), LPARAM(0));
⋮----
WHEEL_RESULT.store(-2, Ordering::SeqCst);
⋮----
pub fn is_wheel_active() -> bool {
WHEEL_ACTIVE.load(Ordering::SeqCst)
⋮----
fn internal_create_window_loop() {
⋮----
// Initialize COM for the thread (Critical for WebView2/Wry)
let _ = CoInitialize(None);
let instance = GetModuleHandleW(None).unwrap_or_default();
⋮----
let overlay_class = w!("SGTWheelOverlayPersistent");
REGISTER_OVERLAY_CLASS.call_once(|| {
⋮----
lpfnWndProc: Some(overlay_wnd_proc),
hInstance: instance.into(),
⋮----
hCursor: LoadCursorW(None, IDC_ARROW).unwrap_or_default(),
hbrBackground: HBRUSH(std::ptr::null_mut()),
⋮----
RegisterClassW(&wc);
⋮----
let overlay_hwnd = CreateWindowExW(
⋮----
w!("WheelOverlay"),
⋮----
Some(instance.into()),
⋮----
.unwrap_or_default();
OVERLAY_HWND.store(overlay_hwnd.0 as isize, Ordering::SeqCst);
let _ = SetLayeredWindowAttributes(overlay_hwnd, COLORREF(0), 1, LWA_ALPHA);
let class_name = w!("SGTPresetWheelPersistent");
REGISTER_WHEEL_CLASS.call_once(|| {
⋮----
lpfnWndProc: Some(wheel_wnd_proc),
⋮----
let hwnd = CreateWindowExW(
⋮----
w!("PresetWheel"),
WS_POPUP, // Removed WS_VISIBLE to prevent initial flash/artifacts
⋮----
// DELAYED STORE: Do not publish WHEEL_HWND yet. Wait until WebView is built.
// WHEEL_HWND.store(hwnd.0 as isize, Ordering::SeqCst);
// Use DWM to extend the "glass" frame into the entire client area for transparency
⋮----
let _ = DwmExtendFrameIntoClientArea(hwnd, &margins);
⋮----
let wrapper = HwndWrapper(hwnd);
WHEEL_WEB_CONTEXT.with(|ctx| {
if ctx.borrow().is_none() {
⋮----
*ctx.borrow_mut() = Some(WebContext::new(Some(shared_data_dir)));
⋮----
let webview_res = WHEEL_WEB_CONTEXT.with(|ctx| {
let mut ctx_ref = ctx.borrow_mut();
let builder = if let Some(web_ctx) = ctx_ref.as_mut() {
⋮----
let template_html = get_wheel_template(true); // Default dark for warmup
⋮----
.with_transparent(true)
.with_background_color((0, 0, 0, 0))
.with_html(template_html)
.with_bounds(Rect {
⋮----
.with_ipc_handler(move |msg: wry::http::Request<String>| {
let body = msg.body();
⋮----
let _ = PostMessageW(
Some(wheel_hwnd),
⋮----
WPARAM(0),
LPARAM(0),
⋮----
PostMessageW(Some(wheel_hwnd), WM_APP_HIDE, WPARAM(0), LPARAM(0));
⋮----
} else if let Some(idx_str) = body.strip_prefix("select:") {
⋮----
*SELECTED_PRESET.lock().unwrap() = Some(idx);
WHEEL_RESULT.store(idx as i32, Ordering::SeqCst);
⋮----
.build(&wrapper)
⋮----
WHEEL_WEBVIEW.with(|cell| {
*cell.borrow_mut() = Some(wv);
⋮----
let _ = ShowWindow(hwnd, SW_HIDE);
// Now that WebView is ready, publicize the HWND and mark warmup as done
WHEEL_HWND.store(hwnd.0 as isize, Ordering::SeqCst);
IS_WARMING_UP.store(false, Ordering::SeqCst);
⋮----
// Initialization failed - cleanup and exit
let _ = DestroyWindow(hwnd);
let _ = DestroyWindow(overlay_hwnd);
⋮----
OVERLAY_HWND.store(0, Ordering::SeqCst);
WHEEL_HWND.store(0, Ordering::SeqCst);
let _ = CoUninitialize(); // Cleanup COM
⋮----
while GetMessageW(&mut msg, None, 0, 0).into() {
⋮----
*cell.borrow_mut() = None;
⋮----
IS_WARMING_UP.store(false, Ordering::SeqCst); // Ensure flag is cleared on exit
⋮----
unsafe extern "system" fn overlay_wnd_proc(
⋮----
LRESULT(0)
⋮----
WM_CLOSE => LRESULT(0),
WM_ERASEBKGND => LRESULT(1), // Prevent GDI from clearing background to black/white
_ => DefWindowProcW(hwnd, msg, wparam, lparam),
⋮----
unsafe extern "system" fn wheel_wnd_proc(
⋮----
let items_html = PENDING_ITEMS_HTML.lock().unwrap().clone();
let dismiss_label = PENDING_DISMISS_LABEL.lock().unwrap().clone();
let themed_css = PENDING_CSS.lock().unwrap().clone();
// 1. Ensure Off-screen (-4000, -4000) but VISIBLE
// Remove calls to SetLayeredWindowAttributes here to prevent black artifacts
let _ = SetWindowPos(
⋮----
Some(HWND_TOPMOST),
⋮----
// Re-apply glass effect to ensure it's active
⋮----
WHEEL_WEBVIEW.with(|wv| {
if let Some(webview) = wv.borrow().as_ref() {
⋮----
.replace("\\", "\\\\")
.replace("`", "\\`")
.replace("$", "\\$");
let css_script = format!(
⋮----
let _ = webview.evaluate_script(&css_script);
let script = format!(
⋮----
let _ = webview.evaluate_script(&script);
let _ = webview.set_bounds(Rect {
⋮----
SetTimer(Some(hwnd), 99, 150, None);
⋮----
let _ = KillTimer(Some(hwnd), 99);
let (target_x, target_y) = *PENDING_POS.lock().unwrap();
let overlay_val = OVERLAY_HWND.load(Ordering::SeqCst);
let overlay = HWND(overlay_val as *mut _);
if !overlay.is_invalid() {
let _ = ShowWindow(overlay, SW_SHOWNOACTIVATE);
⋮----
let _ = InvalidateRect(Some(hwnd), None, true);
⋮----
let _ = PostMessageW(Some(hwnd), WM_APP_REAL_SHOW, WPARAM(0), LPARAM(0));
⋮----
let _ = ShowWindow(overlay, SW_HIDE);
⋮----
webview.evaluate_script("document.getElementById('grid').innerHTML = '';");
⋮----
let _ = PostMessageW(Some(hwnd), WM_APP_HIDE, WPARAM(0), LPARAM(0));
⋮----
PostQuitMessage(0);
</file>

<file path="src/overlay/favorite_bubble/panel.rs">
use super::render::update_bubble_visual;
⋮----
use super::utils::HwndWrapper;
use crate::APP;
use std::sync::atomic::Ordering;
use windows::core::w;
⋮----
use windows::Win32::Graphics::Gdi::HBRUSH;
use windows::Win32::System::LibraryLoader::GetModuleHandleW;
⋮----
use windows::Win32::UI::Input::KeyboardAndMouse::SetFocus;
⋮----
pub fn show_panel(bubble_hwnd: HWND) {
if IS_EXPANDED.load(Ordering::SeqCst) {
⋮----
let fg = GetForegroundWindow();
if !fg.is_invalid() {
LAST_FOREGROUND_HWND.store(fg.0 as isize, Ordering::SeqCst);
⋮----
ensure_panel_created(bubble_hwnd, true);
let panel_val = PANEL_HWND.load(Ordering::SeqCst);
⋮----
let panel_hwnd = HWND(panel_val as *mut std::ffi::c_void);
IS_EXPANDED.store(true, Ordering::SeqCst);
if let Ok(app) = APP.lock() {
⋮----
refresh_panel_layout_and_content(
⋮----
update_bubble_visual(bubble_hwnd);
⋮----
pub fn update_favorites_panel() {
let bubble_val = BUBBLE_HWND.load(Ordering::SeqCst);
⋮----
let bubble_hwnd = HWND(bubble_val as *mut std::ffi::c_void);
ensure_panel_created(bubble_hwnd, false);
⋮----
PostMessageW(Some(panel_hwnd), WM_REFRESH_PANEL, WPARAM(0), LPARAM(0));
⋮----
pub fn ensure_panel_created(bubble_hwnd: HWND, with_webview: bool) {
let panel_exists = PANEL_HWND.load(Ordering::SeqCst) != 0;
⋮----
create_panel_window_internal(bubble_hwnd);
⋮----
let has_webview = PANEL_WEBVIEW.with(|wv| wv.borrow().is_some());
⋮----
create_panel_webview(panel_hwnd);
⋮----
pub fn close_panel() {
if !IS_EXPANDED.swap(false, Ordering::SeqCst) {
⋮----
let webview_exists = PANEL_WEBVIEW.with(|wv| {
if let Some(webview) = wv.borrow().as_ref() {
let _ = webview.evaluate_script("if(window.closePanel) window.closePanel();");
⋮----
close_panel_internal();
⋮----
fn close_panel_internal() {
⋮----
let _ = ShowWindow(panel_hwnd, SW_HIDE);
⋮----
save_bubble_position();
⋮----
pub fn destroy_panel() {
let panel_val = PANEL_HWND.swap(0, Ordering::SeqCst);
⋮----
PANEL_WEBVIEW.with(|wv| {
*wv.borrow_mut() = None;
⋮----
let _ = DestroyWindow(panel_hwnd);
⋮----
pub fn move_panel_to_bubble(bubble_x: i32, bubble_y: i32) {
⋮----
let _ = GetWindowRect(panel_hwnd, &mut panel_rect);
⋮----
let screen_w = GetSystemMetrics(SM_CXSCREEN);
⋮----
let _ = SetWindowPos(
⋮----
panel_y.max(10),
⋮----
fn create_panel_window_internal(_bubble_hwnd: HWND) {
⋮----
let instance = GetModuleHandleW(None).unwrap_or_default();
let class_name = w!("SGTFavoritePanel");
REGISTER_PANEL_CLASS.call_once(|| {
⋮----
lpfnWndProc: Some(panel_wnd_proc),
hInstance: instance.into(),
⋮----
hCursor: LoadCursorW(None, IDC_ARROW).unwrap_or_default(),
hbrBackground: HBRUSH(std::ptr::null_mut()),
⋮----
RegisterClassW(&wc);
⋮----
let panel_hwnd = CreateWindowExW(
⋮----
w!("FavPanel"),
⋮----
Some(instance.into()),
⋮----
.unwrap_or_default();
if !panel_hwnd.is_invalid() {
PANEL_HWND.store(panel_hwnd.0 as isize, Ordering::SeqCst);
⋮----
unsafe fn refresh_panel_layout_and_content(
⋮----
let _ = GetWindowRect(bubble_hwnd, &mut bubble_rect);
⋮----
.iter()
.filter(|p| p.is_favorite && !p.is_upcoming)
.collect();
let fav_count = favs.len();
⋮----
(PANEL_WIDTH as i32 * 2).max(320)
⋮----
let panel_height = panel_height.max(50);
⋮----
let actual_panel_y = panel_y.max(10);
⋮----
let _ = ShowWindow(panel_hwnd, SW_SHOWNOACTIVATE);
⋮----
let _ = webview.set_bounds(Rect {
⋮----
let last_dark = LAST_THEME_IS_DARK.load(Ordering::SeqCst);
⋮----
let new_css = generate_panel_css(is_dark);
let escaped_css = escape_js(&new_css);
⋮----
let script = format!(
⋮----
let _ = webview.evaluate_script(&script);
⋮----
LAST_THEME_IS_DARK.store(is_dark, Ordering::SeqCst);
⋮----
let favorites_html = get_favorite_presets_html(presets, lang, is_dark);
update_panel_content(&favorites_html, num_cols);
⋮----
fn create_panel_webview(panel_hwnd: HWND) {
⋮----
let _ = GetClientRect(panel_hwnd, &mut rect);
⋮----
let html = if let Ok(app) = APP.lock() {
⋮----
generate_panel_html(&app.config.presets, &app.config.ui_language, is_dark)
⋮----
let wrapper = HwndWrapper(panel_hwnd);
PANEL_WEB_CONTEXT.with(|ctx| {
if ctx.borrow().is_none() {
⋮----
*ctx.borrow_mut() = Some(WebContext::new(Some(shared_data_dir)));
⋮----
let result = PANEL_WEB_CONTEXT.with(|ctx| {
let mut ctx_ref = ctx.borrow_mut();
let builder = if let Some(web_ctx) = ctx_ref.as_mut() {
⋮----
.with_bounds(Rect {
⋮----
.with_html(&html)
.with_transparent(true)
.with_ipc_handler(move |msg: wry::http::Request<String>| {
let body = msg.body();
⋮----
use windows::Win32::UI::Input::KeyboardAndMouse::ReleaseCapture;
let _ = ReleaseCapture();
SendMessageW(
⋮----
Some(WPARAM(HTCAPTION as usize)),
Some(LPARAM(0)),
⋮----
close_panel();
⋮----
} else if body.starts_with("trigger:") {
⋮----
IS_EXPANDED.store(false, Ordering::SeqCst);
trigger_preset(idx);
⋮----
} else if body.starts_with("trigger_only:") {
⋮----
.build_as_child(&wrapper)
⋮----
*wv.borrow_mut() = Some(webview);
⋮----
unsafe extern "system" fn panel_wnd_proc(
⋮----
LRESULT(0)
⋮----
WM_KILLFOCUS => LRESULT(0),
⋮----
let bubble_hwnd = HWND(BUBBLE_HWND.load(Ordering::SeqCst) as *mut std::ffi::c_void);
⋮----
DefWindowProcW(hwnd, msg, wparam, lparam)
⋮----
_ => DefWindowProcW(hwnd, msg, wparam, lparam),
⋮----
fn trigger_preset(preset_idx: usize) {
⋮----
let saved_fg = LAST_FOREGROUND_HWND.load(Ordering::SeqCst);
⋮----
let fg_hwnd = HWND(saved_fg as *mut std::ffi::c_void);
if !fg_hwnd.is_invalid() {
let _ = SetForegroundWindow(fg_hwnd);
let _ = SetFocus(Some(fg_hwnd));
⋮----
let class = w!("HotkeyListenerClass");
let title = w!("Listener");
let hwnd = FindWindowW(class, title).unwrap_or_default();
if !hwnd.is_invalid() {
⋮----
let _ = PostMessageW(Some(hwnd), WM_HOTKEY, WPARAM(hotkey_id as usize), LPARAM(0));
⋮----
fn save_bubble_position() {
⋮----
let _ = GetWindowRect(bubble_hwnd, &mut rect);
if let Ok(mut app) = APP.lock() {
app.config.favorite_bubble_position = Some((rect.left, rect.top));
⋮----
fn update_panel_content(html: &str, cols: usize) {
⋮----
let escaped = escape_js(html);
</file>

<file path="Cargo.toml">
[package]
name = "screen-goated-toolbox"
version = "3.9.0"
edition = "2021"

[build-dependencies]
winres = "0.1"
image = { version = "0.24", default-features = false, features = ["png", "bmp"] }

[dependencies]
# Network & Serialization
ureq = { version = "2.9", features = ["json"] }
tungstenite = { version = "0.21", features = ["native-tls"] }
native-tls = "0.2"
url = "2.5"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
anyhow = "1.0"
base64 = "0.21"
self_update = { version = "0.39", features = ["archive-zip", "compression-zip-deflate"] }
zip = "0.6"

# Image Processing (Only PNG feature to save space)
image = { version = "0.24", default-features = false, features = ["png", "bmp"] }

# Time
chrono = { version = "0.4", features = ["serde"] }

# System
dirs = "5.0"
lazy_static = "1.4"
textwrap = "0.16"
open = "5.0"
sys-locale = "0.3"
winreg = "0.50"
auto-launch = "0.5"
urlencoding = "2.1"

# Language Data (Kept as requested)
isolang = { version = "2.0", features = ["serde", "english_names"] }
whatlang = "0.18"

# Repository consolidation
ignore = "0.4" 

# GUI & Media
eframe = { version = "0.33", default-features = false, features = ["glow"] }
egui-snarl = { path = "libs/egui-snarl", features = ["serde"] }
tray-icon = "0.19.1"
cpal = "0.15"
hound = "3.5"
wasapi = "0.22"
minimp3 = "0.5"

# Markdown Rendering
pulldown-cmark = "0.10"
wry = "0.53.3"
raw-window-handle = "0.6"
windows-core = "0.62"

[dependencies.windows]
version = "0.62"
features = [
    "Win32_Foundation",
    "Win32_UI_WindowsAndMessaging",
    "Win32_UI_Controls",
    "Win32_Graphics_Gdi",
    "Win32_UI_Input_KeyboardAndMouse",
    "Win32_System_LibraryLoader",
    "Win32_System_SystemServices",
    "Win32_Graphics_Dwm",
    "Win32_UI_HiDpi",
    "Win32_System_Threading",
    "Win32_Security",
    "Win32_System_Com",
    "Win32_System_DataExchange",
    "Win32_System_Memory",
    "Win32_Media_Audio",
    "Win32_System_SystemInformation",
    "Win32_UI_Shell",
    "Win32_UI_Shell_Common",
    "Win32_UI_Magnification",
]

[profile.release]
opt-level = "z"
lto = true
codegen-units = 1
strip = true
panic = "unwind"

# AV-safe profile for nopack version - keeps debug info for better AV analysis
[profile.release-safe]
inherits = "release"
strip = "symbols"  # Keep minimal debug info
debug = 1          # Include basic debug info for AV scanners
</file>

<file path="src/overlay/tray_popup.rs">
use crate::APP;
use std::cell::RefCell;
⋮----
use windows::core::w;
⋮----
use windows::Win32::System::LibraryLoader::GetModuleHandleW;
⋮----
thread_local! {
⋮----
fn get_scaled_dimension(base: i32) -> i32 {
⋮----
struct HwndWrapper(HWND);
unsafe impl Send for HwndWrapper {}
unsafe impl Sync for HwndWrapper {}
⋮----
fn window_handle(
⋮----
std::num::NonZeroIsize::new(self.0 .0 as isize).expect("HWND cannot be null"),
⋮----
unsafe { Ok(raw_window_handle::WindowHandle::borrow_raw(handle)) }
⋮----
/// Show the tray popup at cursor position
pub fn show_tray_popup() {
⋮----
pub fn show_tray_popup() {
// CAS loop to handle state transitions atomically-ish or just check current state
// We used swap previously which is good, but we need to handle State 2 differently based on HWND.
// Let's check current state first.
let current = POPUP_STATE.load(Ordering::SeqCst);
⋮----
let hwnd_val = POPUP_HWND.load(Ordering::SeqCst);
⋮----
let hwnd = HWND(hwnd_val as *mut std::ffi::c_void);
let is_valid = unsafe { windows::Win32::UI::WindowsAndMessaging::IsWindow(Some(hwnd)).as_bool() };
⋮----
POPUP_STATE.store(0, Ordering::SeqCst);
POPUP_HWND.store(0, Ordering::SeqCst);
⋮----
hide_tray_popup();
⋮----
let prev = POPUP_STATE.swap(2, Ordering::SeqCst);
⋮----
create_popup_window(false);
⋮----
pub fn hide_tray_popup() {
if POPUP_STATE.load(Ordering::SeqCst) == 0 {
⋮----
let _ = PostMessageW(Some(hwnd), WM_CLOSE, WPARAM(0), LPARAM(0));
⋮----
POPUP_STATE.store(3, Ordering::SeqCst);
⋮----
pub fn warmup_tray_popup() {
if POPUP_STATE.compare_exchange(0, 1, Ordering::SeqCst, Ordering::SeqCst).is_ok() {
⋮----
create_popup_window(true);
⋮----
pub fn is_popup_open() -> bool {
POPUP_STATE.load(Ordering::SeqCst) == 2
⋮----
fn generate_popup_html() -> String {
use crate::config::ThemeMode;
let (settings_text, bubble_text, stop_tts_text, quit_text, bubble_checked, is_dark_mode) = if let Ok(app) = APP.lock() {
⋮----
let settings = match lang.as_str() {
⋮----
let bubble = match lang.as_str() {
⋮----
let stop_tts = match lang.as_str() {
⋮----
let quit = match lang.as_str() {
⋮----
let has_tts_pending = crate::api::tts::TTS_MANAGER.has_pending_audio();
⋮----
format!(
⋮----
// RAII Guard to ensure state reset
struct StateGuard;
impl Drop for StateGuard {
fn drop(&mut self) {
POPUP_ACTIVE_REF.store(0, Ordering::SeqCst);
POPUP_HWND_REF.store(0, Ordering::SeqCst);
// Also ensure WebView is dropped on thread exit which helps with cleanup
POPUP_WEBVIEW.with(|cell| {
*cell.borrow_mut() = None;
⋮----
// Accessors for Guard since it can't capture statics directly easily in Drop if they aren't accessible
// Actually statics are global so we can just use them.
// But to be clean we'll just refer to the statics in the Drop impl logic (which refers to global names).
// Wait, Drop implementation cannot capture 'self' context easily for statics unless I put them in a struct.
// But POPUP_STATE is static. I can access it directly.
// We need to define safe access or just use the statics.
// Since `POPUP_STATE` is static, we can access it.
⋮----
fn create_popup_window(is_warmup: bool) {
let _guard = StateGuard; // Will reset state to 0 on exit/panic
⋮----
let instance = GetModuleHandleW(None).unwrap_or_default();
let class_name = w!("SGTTrayPopup");
REGISTER_POPUP_CLASS.call_once(|| {
⋮----
lpfnWndProc: Some(popup_wnd_proc),
hInstance: instance.into(),
⋮----
hCursor: LoadCursorW(None, IDC_ARROW).unwrap_or_default(),
hbrBackground: HBRUSH(std::ptr::null_mut()),
⋮----
RegisterClassW(&wc);
⋮----
let popup_height = get_scaled_dimension(BASE_POPUP_HEIGHT);
let popup_width = get_scaled_dimension(BASE_POPUP_WIDTH);
⋮----
let _ = GetCursorPos(&mut pt);
let screen_w = GetSystemMetrics(SM_CXSCREEN);
let screen_h = GetSystemMetrics(SM_CYSCREEN);
let popup_x = (pt.x - popup_width / 2).max(0).min(screen_w - popup_width);
⋮----
.max(0)
.min(screen_h - popup_height);
⋮----
let hwnd = CreateWindowExW(
⋮----
w!("TrayPopup"),
⋮----
Some(instance.into()),
⋮----
.unwrap_or_default();
if hwnd.is_invalid() {
⋮----
POPUP_HWND.store(hwnd.0 as isize, Ordering::SeqCst);
⋮----
let _ = DwmSetWindowAttribute(
⋮----
let wrapper = HwndWrapper(hwnd);
let html = generate_popup_html();
POPUP_WEB_CONTEXT.with(|ctx| {
if ctx.borrow().is_none() {
⋮----
*ctx.borrow_mut() = Some(WebContext::new(Some(shared_data_dir)));
⋮----
let webview = POPUP_WEB_CONTEXT.with(|ctx| {
let mut ctx_ref = ctx.borrow_mut();
let builder = if let Some(web_ctx) = ctx_ref.as_mut() {
⋮----
.with_bounds(Rect {
⋮----
.with_transparent(true)
.with_html(&html)
.with_ipc_handler(move |msg: wry::http::Request<String>| {
let body = msg.body();
match body.as_str() {
⋮----
let h = POPUP_HWND.load(Ordering::SeqCst);
⋮----
let _ = PostMessageW(
Some(HWND(h as *mut _)),
⋮----
WPARAM(0),
LPARAM(0),
⋮----
let new_state = if let Ok(mut app) = APP.lock() {
⋮----
if let Some(webview) = cell.borrow().as_ref() {
let js = format!(
⋮----
let _ = webview.evaluate_script(&js);
⋮----
crate::api::tts::TTS_MANAGER.stop();
⋮----
.build(&wrapper)
⋮----
*cell.borrow_mut() = Some(wv);
⋮----
let current_state = POPUP_STATE.load(Ordering::SeqCst);
⋮----
let popup_y = (pt.y - popup_height - 10).max(0).min(screen_h - popup_height);
let _ = SetWindowPos(hwnd, None, popup_x, popup_y, popup_width, popup_height, SWP_NOZORDER);
let _ = ShowWindow(hwnd, SW_SHOW);
let _ = SetForegroundWindow(hwnd);
let _ = SetTimer(Some(hwnd), 888, 100, None);
⋮----
while GetMessageW(&mut msg, None, 0, 0).into() {
let _ = TranslateMessage(&msg);
DispatchMessageW(&msg);
⋮----
unsafe extern "system" fn popup_wnd_proc(
⋮----
LRESULT(0)
⋮----
let fg = GetForegroundWindow();
let root = GetAncestor(fg, GA_ROOT);
⋮----
return LRESULT(0);
⋮----
if now > IGNORE_FOCUS_LOSS_UNTIL.load(Ordering::SeqCst) {
let _ = KillTimer(Some(hwnd), 888);
⋮----
let _ = DestroyWindow(hwnd);
⋮----
PostQuitMessage(0);
⋮----
_ => DefWindowProcW(hwnd, msg, wparam, lparam),
</file>

<file path="src/gui/locale.rs">
pub struct LocaleText {
⋮----
pub preset_type_text: &'static str, // NEW
⋮----
// --- NEW TEXT INPUT FIELDS ---
⋮----
pub continuous_input_label: &'static str, // Checkbox for continuous input mode
⋮----
// --- COMPOUND SEARCH UI ---
⋮----
pub search_searching: &'static str,        // "searching" / "tìm kiếm"
⋮----
pub search_found_sources: &'static str,    // "FOUND {} SOURCES" / "ĐÃ TÌM THẤY {} NGUỒN"
⋮----
pub search_no_title: &'static str,      // "(No title)" / "(Không có tiêu đề)"
⋮----
pub search_analyzed_sources: &'static str, // "Analyzed {} sources" / "Đã phân tích {} nguồn"
⋮----
pub controller_checkbox_label: &'static str, // "Bộ điều khiển" / "Controller" / "컨트롤러"
// --- GLOBAL SETTINGS UI HEADERS ---
⋮----
// --- MODEL THINKING INDICATOR ---
⋮----
// App selection modal
⋮----
// --- TRAY MENU ---
⋮----
// --- FAVORITE BUBBLE ---
⋮----
// --- REALTIME EGUI SPECIFIC ---
⋮----
impl LocaleText {
pub fn get(lang_code: &str) -> Self {
⋮----
preset_type_text: "Hiểu văn bản", // NEW
⋮----
// --- NEW TEXT INPUT FIELDS VI ---
⋮----
// --- PROCESSING CHAIN UI VI ---
⋮----
tips_list: vec![
⋮----
tts_preview_texts: vec![
</file>

<file path="src/main.rs">
mod api;
mod config;
pub mod gui;
mod history;
mod icon_gen;
mod model_config;
mod overlay;
mod repo_consolidator;
mod updater;
pub mod win_types;
⋮----
use gui::locale::LocaleText;
use history::HistoryManager;
use lazy_static::lazy_static;
use std::collections::HashMap;
use std::panic;
⋮----
use windows::Win32::System::Com::CoInitialize;
⋮----
lazy_static! {
⋮----
pub struct GdiCapture {
⋮----
unsafe impl Send for GdiCapture {}
unsafe impl Sync for GdiCapture {}
impl Drop for GdiCapture {
fn drop(&mut self) {
⋮----
if !self.hbitmap.is_invalid() {
let _ = DeleteObject(self.hbitmap.into());
⋮----
pub struct AppState {
⋮----
fn enable_dark_mode_for_app() {
use windows::core::w;
⋮----
if let Ok(uxtheme) = LoadLibraryW(w!("uxtheme.dll")) {
⋮----
if let Some(set_preferred_app_mode) = GetProcAddress(uxtheme, proc_name) {
⋮----
func(ALLOW_DARK);
⋮----
fn main() -> eframe::Result<()> {
⋮----
let _ = CoInitialize(None);
⋮----
enable_dark_mode_for_app();
⋮----
if let Some(exe_dir) = exe_path.parent() {
let staging_path = exe_dir.join("update_pending.exe");
let backup_path = exe_path.with_extension("exe.old");
if staging_path.exists() {
⋮----
if std::fs::rename(&staging_path, &exe_path).is_ok() {
⋮----
let current_exe_name = exe_path.file_name().and_then(|n| n.to_str()).unwrap_or("");
⋮----
for entry in entries.filter_map(|e| e.ok()) {
let file_name = entry.file_name();
let name_str = file_name.to_string_lossy();
// Delete old ScreenGoatedToolbox_v*.exe files (keep only current)
if (name_str.starts_with("ScreenGoatedToolbox_v") && name_str.ends_with(".exe"))
&& name_str.as_ref() != current_exe_name
⋮----
let _ = std::fs::remove_file(entry.path());
⋮----
if name_str.ends_with(".exe.old") {
⋮----
let location = if let Some(location) = panic_info.location() {
format!("File: {}\nLine: {}", location.file(), location.line())
⋮----
"Unknown location".to_string()
⋮----
let payload = if let Some(s) = panic_info.payload().downcast_ref::<&str>() {
s.to_string()
} else if let Some(s) = panic_info.payload().downcast_ref::<String>() {
s.clone()
⋮----
"Unknown panic payload".to_string()
⋮----
let error_msg = format!(
⋮----
let wide_msg: Vec<u16> = error_msg.encode_utf16().chain(std::iter::once(0)).collect();
⋮----
.encode_utf16()
.chain(std::iter::once(0))
.collect();
⋮----
MessageBoxW(
⋮----
PCWSTR(wide_msg.as_ptr()),
PCWSTR(wide_title.as_ptr()),
⋮----
let _ = RESTORE_EVENT.as_ref();
⋮----
let instance = CreateMutexW(
⋮----
w!("Global\\ScreenGoatedToolboxSingleInstanceMutex"),
⋮----
if GetLastError() == ERROR_ALREADY_EXISTS {
if let Some(event) = RESTORE_EVENT.as_ref() {
let _ = SetEvent(event.0);
⋮----
let _ = CloseHandle(handle);
return Ok(());
⋮----
Some(handle)
⋮----
run_hotkey_listener();
⋮----
wait_for_popup_close();
⋮----
let initial_config = APP.lock().unwrap().config.clone();
⋮----
let has_favorites = initial_config.presets.iter().any(|p| p.is_favorite);
⋮----
let _ = tray_menu.append(&tray_favorite_bubble_item);
let _ = tray_menu.append(&tray_settings_item);
let _ = tray_menu.append(&tray_quit_item);
⋮----
.with_inner_size([WINDOW_WIDTH, WINDOW_HEIGHT])
.with_resizable(true)
.with_visible(false)
.with_transparent(false)
.with_decorations(true);
⋮----
viewport_builder = viewport_builder.with_icon(std::sync::Arc::new(icon_data));
⋮----
*gui::GUI_CONTEXT.lock().unwrap() = Some(cc.egui_ctx.clone());
⋮----
cc.egui_ctx.set_visuals(eframe::egui::Visuals::dark());
⋮----
cc.egui_ctx.set_visuals(eframe::egui::Visuals::light());
⋮----
Ok(Box::new(gui::SettingsApp::new(
⋮----
APP.clone(),
⋮----
cc.egui_ctx.clone(),
⋮----
fn register_all_hotkeys(hwnd: HWND) {
let mut app = APP.lock().unwrap();
⋮----
for (p_idx, preset) in presets.iter().enumerate() {
for (h_idx, hotkey) in preset.hotkeys.iter().enumerate() {
if [0x04, 0x05, 0x06].contains(&hotkey.code) {
⋮----
let _ = RegisterHotKey(
Some(hwnd),
⋮----
HOT_KEY_MODIFIERS(hotkey.modifiers),
⋮----
registered_ids.push(id);
⋮----
fn unregister_all_hotkeys(hwnd: HWND) {
let app = APP.lock().unwrap();
⋮----
let _ = UnregisterHotKey(Some(hwnd), id);
⋮----
unsafe extern "system" fn mouse_hook_proc(code: i32, wparam: WPARAM, lparam: LPARAM) -> LRESULT {
⋮----
WM_MBUTTONDOWN => Some(0x04),
⋮----
Some(0x05)
⋮----
Some(0x06)
⋮----
if (GetAsyncKeyState(VK_MENU.0 as i32) as u16 & 0x8000) != 0 {
⋮----
if (GetAsyncKeyState(VK_CONTROL.0 as i32) as u16 & 0x8000) != 0 {
⋮----
if (GetAsyncKeyState(VK_SHIFT.0 as i32) as u16 & 0x8000) != 0 {
⋮----
if (GetAsyncKeyState(VK_LWIN.0 as i32) as u16 & 0x8000) != 0
|| (GetAsyncKeyState(VK_RWIN.0 as i32) as u16 & 0x8000) != 0
⋮----
if let Ok(app) = APP.lock() {
for (p_idx, preset) in app.config.presets.iter().enumerate() {
⋮----
found_id = Some((p_idx as i32 * 1000) + (h_idx as i32) + 1);
⋮----
if found_id.is_some() {
⋮----
if let Ok(hwnd_target) = LISTENER_HWND.lock() {
if !hwnd_target.0.is_invalid() {
let _ = PostMessageW(
Some(hwnd_target.0),
⋮----
WPARAM(id as usize),
LPARAM(0),
⋮----
return LRESULT(1);
⋮----
CallNextHookEx(None, code, wparam, lparam)
⋮----
fn run_hotkey_listener() {
⋮----
let instance = match GetModuleHandleW(None) {
⋮----
eprintln!("Error: Failed to get module handle for hotkey listener");
⋮----
let class_name = w!("HotkeyListenerClass");
⋮----
lpfnWndProc: Some(hotkey_proc),
hInstance: instance.into(),
⋮----
let _ = RegisterClassW(&wc);
let hwnd = CreateWindowExW(
⋮----
w!("Listener"),
⋮----
Some(instance.into()),
⋮----
.unwrap_or_default();
if hwnd.is_invalid() {
eprintln!("Error: Failed to create hotkey listener window");
⋮----
if let Ok(mut guard) = LISTENER_HWND.lock() {
*guard = SendHwnd(hwnd);
⋮----
SetWindowsHookExW(WH_MOUSE_LL, Some(mouse_hook_proc), Some(instance.into()), 0)
⋮----
if let Ok(mut hook_guard) = MOUSE_HOOK.lock() {
*hook_guard = SendHhook(hhook);
⋮----
eprintln!("Warning: Failed to install low-level mouse hook");
⋮----
register_all_hotkeys(hwnd);
⋮----
if GetMessageW(&mut msg, None, 0, 0).as_bool() {
⋮----
unregister_all_hotkeys(hwnd);
⋮----
if let Ok(mut app) = APP.lock() {
⋮----
let _ = TranslateMessage(&msg);
DispatchMessageW(&msg);
⋮----
unsafe extern "system" fn hotkey_proc(
⋮----
return LRESULT(0);
⋮----
if preset_idx < app.config.presets.len() {
⋮----
let p_type = p.preset_type.clone();
let t_mode = p.text_input_mode.clone();
⋮----
let hk_name = if hk_idx < p.hotkeys.len() {
p.hotkeys[hk_idx].name.clone()
⋮----
"image".to_string(),
"select".to_string(),
⋮----
app.last_active_window = target_window.map(crate::win_types::SendHwnd);
⋮----
.load(std::sync::atomic::Ordering::SeqCst);
⋮----
let config = app.config.clone();
let preset = config.presets[preset_idx].clone();
let screen_w = GetSystemMetrics(SM_CXSCREEN);
let screen_h = GetSystemMetrics(SM_CYSCREEN);
⋮----
let hotkey_name_clone = hotkey_name.clone();
⋮----
let app_clone = APP.clone();
⋮----
std::thread::spawn(move || match capture_screen_fast() {
⋮----
if let Ok(mut app) = app_clone.lock() {
app.screenshot_handle = Some(capture);
⋮----
eprintln!("Capture Error: {}", e);
⋮----
LRESULT(0)
⋮----
_ => DefWindowProcW(hwnd, msg, wparam, lparam),
⋮----
fn capture_screen_fast() -> anyhow::Result<GdiCapture> {
⋮----
let x = GetSystemMetrics(SM_XVIRTUALSCREEN);
let y = GetSystemMetrics(SM_YVIRTUALSCREEN);
let width = GetSystemMetrics(SM_CXVIRTUALSCREEN);
let height = GetSystemMetrics(SM_CYVIRTUALSCREEN);
⋮----
return Err(anyhow::anyhow!(
⋮----
let hdc_screen = GetDC(None);
if hdc_screen.is_invalid() {
⋮----
let hdc_mem = CreateCompatibleDC(Some(hdc_screen));
if hdc_mem.is_invalid() {
let _ = ReleaseDC(None, hdc_screen);
⋮----
let hbitmap = CreateCompatibleBitmap(hdc_screen, width, height);
if hbitmap.is_invalid() {
let _ = DeleteDC(hdc_mem);
⋮----
SelectObject(hdc_mem, hbitmap.into());
BitBlt(
⋮----
Some(hdc_screen),
⋮----
ReleaseDC(None, hdc_screen);
Ok(GdiCapture {
</file>

<file path="src/gui/settings_ui/sidebar.rs">
use super::ViewMode;
⋮----
use crate::gui::locale::LocaleText;
use eframe::egui;
pub fn get_localized_preset_name(preset_id: &str, lang_code: &str) -> String {
⋮----
("preset_translate", "vi") => "Dịch vùng".to_string(),
("preset_extract_retranslate", "vi") => "Dịch vùng (CHUẨN)".to_string(),
("preset_translate_auto_paste", "vi") => "Dịch vùng (Tự dán)".to_string(),
("preset_translate_retranslate", "vi") => "Dịch vùng+Dịch lại".to_string(),
("preset_extract_retrans_retrans", "vi") => "D.vùng (CHUẨN)+D.lại".to_string(),
("preset_ocr", "vi") => "Lấy text từ ảnh".to_string(),
("preset_quick_screenshot", "vi") => "Chụp MH nhanh".to_string(),
("preset_quick_screenshot", "ko") => "빠른 스크린샷".to_string(),
("preset_quick_screenshot", _) => "Quick screenshot".to_string(),
("preset_ocr_read", "vi") => "Đọc vùng này".to_string(),
("preset_summarize", "vi") => "Tóm tắt vùng".to_string(),
("preset_desc", "vi") => "Mô tả ảnh".to_string(),
("preset_ask_image", "vi") => "Hỏi về ảnh".to_string(),
("preset_translate_select", "vi") => "Dịch".to_string(),
("preset_translate_arena", "vi") => "Dịch (Arena)".to_string(),
("preset_read_aloud", "vi") => "Đọc to".to_string(),
("preset_trans_retrans_select", "vi") => "Dịch+ Dịch lại".to_string(),
("preset_select_translate_replace", "vi") => "Dịch và Thay".to_string(),
("preset_fix_grammar", "vi") => "Sửa ngữ pháp".to_string(),
("preset_rephrase", "vi") => "Viết lại".to_string(),
("preset_make_formal", "vi") => "Chuyên nghiệp hóa".to_string(),
("preset_explain", "vi") => "Giải thích".to_string(),
("preset_ask_text", "vi") => "Hỏi về text...".to_string(),
("preset_edit_as_follows", "vi") => "Sửa như sau:".to_string(),
("preset_extract_table", "vi") => "Trích bảng".to_string(),
("preset_qr_scanner", "vi") => "Quét mã QR".to_string(),
("preset_trans_retrans_typing", "vi") => "Dịch+Dịch lại (Tự gõ)".to_string(),
("preset_ask_ai", "vi") => "Hỏi AI".to_string(),
("preset_internet_search", "vi") => "Tìm kiếm internet".to_string(),
("preset_make_game", "vi") => "Tạo con game".to_string(),
("preset_transcribe", "vi") => "Lời nói thành văn".to_string(),
("preset_fix_pronunciation", "vi") => "Chỉnh phát âm".to_string(),
("preset_study_language", "vi") => "Học ngoại ngữ".to_string(),
("preset_transcribe_retranslate", "vi") => "Trả lời ng.nc.ngoài 1".to_string(),
("preset_quicker_foreigner_reply", "vi") => "Trả lời ng.nc.ngoài 2".to_string(),
("preset_fact_check", "vi") => "Kiểm chứng thông tin".to_string(),
("preset_omniscient_god", "vi") => "Thần Trí tuệ".to_string(),
("preset_realtime_audio_translate", "vi") => "Dịch cabin".to_string(),
("preset_quick_ai_question", "vi") => "Hỏi nhanh AI".to_string(),
("preset_voice_search", "vi") => "Nói để search".to_string(),
("preset_hang_image", "vi") => "Treo ảnh".to_string(),
("preset_hang_text", "vi") => "Treo text".to_string(),
("preset_quick_note", "vi") => "Note nhanh".to_string(),
("preset_quick_record", "vi") => "Thu âm nhanh".to_string(),
("preset_record_device", "vi") => "Thu âm máy".to_string(),
("preset_image_master", "vi") => "Ảnh MASTER".to_string(),
("preset_text_select_master", "vi") => "Bôi MASTER".to_string(),
("preset_text_type_master", "vi") => "Gõ MASTER".to_string(),
("preset_audio_mic_master", "vi") => "Mic MASTER".to_string(),
("preset_audio_device_master", "vi") => "Tiếng MASTER".to_string(),
("preset_translate", "ko") => "영역 번역".to_string(),
("preset_extract_retranslate", "ko") => "영역 번역 (정확)".to_string(),
("preset_translate_auto_paste", "ko") => "영역 번역 (자동 붙.)".to_string(),
("preset_translate_retranslate", "ko") => "영역 번역+재번역".to_string(),
("preset_extract_retrans_retrans", "ko") => "영.번역 (정확)+재번역".to_string(),
("preset_ocr", "ko") => "텍스트 추출".to_string(),
("preset_ocr_read", "ko") => "영역 읽기".to_string(),
("preset_summarize", "ko") => "영역 요약".to_string(),
("preset_desc", "ko") => "이미지 설명".to_string(),
("preset_ask_image", "ko") => "이미지 질문".to_string(),
("preset_translate_select", "ko") => "번역 (선택 텍스트)".to_string(),
("preset_translate_arena", "ko") => "번역 (아레나)".to_string(),
("preset_read_aloud", "ko") => "크게 읽기".to_string(),
("preset_trans_retrans_select", "ko") => "번역+재번역 (선택)".to_string(),
("preset_select_translate_replace", "ko") => "선택-번역-교체".to_string(),
("preset_fix_grammar", "ko") => "문법 수정".to_string(),
("preset_rephrase", "ko") => "다시 쓰기".to_string(),
("preset_make_formal", "ko") => "공식적으로".to_string(),
("preset_explain", "ko") => "설명".to_string(),
("preset_ask_text", "ko") => "텍스트 질문...".to_string(),
("preset_edit_as_follows", "ko") => "다음과 같이 수정:".to_string(),
("preset_extract_table", "ko") => "표 추출".to_string(),
("preset_qr_scanner", "ko") => "QR 스캔".to_string(),
("preset_trans_retrans_typing", "ko") => "번역+재번역 (입력)".to_string(),
("preset_ask_ai", "ko") => "AI 질문".to_string(),
("preset_internet_search", "ko") => "인터넷 검색".to_string(),
("preset_make_game", "ko") => "게임 만들기".to_string(),
("preset_transcribe", "ko") => "음성 받아쓰기".to_string(),
("preset_fix_pronunciation", "ko") => "발음 교정".to_string(),
("preset_study_language", "ko") => "언어 학습".to_string(),
("preset_transcribe_retranslate", "ko") => "빠른 외국인 답변 1".to_string(),
("preset_quicker_foreigner_reply", "ko") => "빠른 외국인 답변 2".to_string(),
("preset_fact_check", "ko") => "정보 확인".to_string(),
("preset_omniscient_god", "ko") => "전지전능한 신".to_string(),
("preset_realtime_audio_translate", "ko") => "실시간 음성 번역".to_string(),
("preset_quick_ai_question", "ko") => "빠른 AI 질문".to_string(),
("preset_voice_search", "ko") => "음성 검색".to_string(),
("preset_hang_image", "ko") => "이미지 오버레이".to_string(),
("preset_hang_text", "ko") => "텍스트 오버레이".to_string(),
("preset_quick_note", "ko") => "빠른 메모".to_string(),
("preset_quick_record", "ko") => "빠른 녹음".to_string(),
("preset_record_device", "ko") => "시스템 녹음".to_string(),
("preset_image_master", "ko") => "이미지 마스터".to_string(),
("preset_text_select_master", "ko") => "선택 마스터".to_string(),
("preset_text_type_master", "ko") => "입력 마스터".to_string(),
("preset_audio_mic_master", "ko") => "마이크 마스터".to_string(),
("preset_audio_device_master", "ko") => "사운드 마스터".to_string(),
("preset_translate", _) => "Translate region".to_string(),
("preset_extract_retranslate", _) => "Trans reg (ACCURATE)".to_string(),
("preset_translate_auto_paste", _) => "Trans reg (Auto paste)".to_string(),
("preset_translate_retranslate", _) => "Trans reg+Retrans".to_string(),
("preset_extract_retrans_retrans", _) => "Trans (ACC)+Retrans".to_string(),
("preset_ocr", _) => "Extract text".to_string(),
("preset_ocr_read", _) => "Read this region".to_string(),
("preset_summarize", _) => "Summarize region".to_string(),
("preset_desc", _) => "Describe image".to_string(),
("preset_ask_image", _) => "Ask about image".to_string(),
("preset_translate_select", _) => "Trans (Select text)".to_string(),
("preset_translate_arena", _) => "Trans (Arena)".to_string(),
("preset_read_aloud", _) => "Read aloud".to_string(),
("preset_trans_retrans_select", _) => "Trans+Retrans (Select)".to_string(),
("preset_select_translate_replace", _) => "Select-Trans-Replace".to_string(),
("preset_fix_grammar", _) => "Fix Grammar".to_string(),
("preset_rephrase", _) => "Rephrase".to_string(),
("preset_make_formal", _) => "Make Formal".to_string(),
("preset_explain", _) => "Explain".to_string(),
("preset_ask_text", _) => "Ask about text...".to_string(),
("preset_edit_as_follows", _) => "Edit as follows:".to_string(),
("preset_extract_table", _) => "Extract Table".to_string(),
("preset_qr_scanner", _) => "QR Scanner".to_string(),
("preset_trans_retrans_typing", _) => "Trans+Retrans (Type)".to_string(),
("preset_ask_ai", _) => "Ask AI".to_string(),
("preset_internet_search", _) => "Internet Search".to_string(),
("preset_make_game", _) => "Make a Game".to_string(),
("preset_transcribe", _) => "Transcribe speech".to_string(),
("preset_fix_pronunciation", _) => "Fix pronunciation".to_string(),
("preset_study_language", _) => "Study language".to_string(),
("preset_transcribe_retranslate", _) => "Quick 4NR reply 1".to_string(),
("preset_quicker_foreigner_reply", _) => "Quick 4NR reply 2".to_string(),
("preset_fact_check", _) => "Fact Check".to_string(),
("preset_omniscient_god", _) => "Omniscient God".to_string(),
("preset_realtime_audio_translate", _) => "Live Translate".to_string(),
("preset_quick_ai_question", _) => "Quick AI Question".to_string(),
("preset_voice_search", _) => "Voice Search".to_string(),
("preset_hang_image", _) => "Image Overlay".to_string(),
("preset_hang_text", _) => "Text Overlay".to_string(),
("preset_quick_note", _) => "Quick Note".to_string(),
("preset_quick_record", _) => "Quick Record".to_string(),
("preset_record_device", _) => "Device Audio Record".to_string(),
("preset_image_master", _) => "Image MASTER".to_string(),
("preset_text_select_master", _) => "Select MASTER".to_string(),
("preset_text_type_master", _) => "Type MASTER".to_string(),
("preset_audio_mic_master", _) => "Mic MASTER".to_string(),
("preset_audio_device_master", _) => "Sound MASTER".to_string(),
⋮----
.strip_prefix("preset_")
.unwrap_or(preset_id)
.replace('_', " "),
⋮----
pub fn render_sidebar(
⋮----
let dragging_source_idx: Option<usize> = ui.memory(|mem| mem.data.get_temp(dragging_idx_id));
⋮----
for (i, p) in config.presets.iter().enumerate() {
match p.preset_type.as_str() {
"image" => image_indices.push(i),
"text" => text_indices.push(i),
"audio" | "video" => audio_video_indices.push(i),
_ => image_indices.push(i),
⋮----
let current_view_mode = view_mode.clone();
⋮----
thread_local! {
⋮----
let cached_grid_width = GRID_WIDTH.with(|w| w.get());
ui.horizontal(|ui| {
ui.spacing_mut().item_spacing.x = 8.0;
let is_dark = ui.visuals().dark_mode;
⋮----
if icon_button_sized(ui, theme_icon, 20.0)
.on_hover_text(tooltip)
.clicked()
⋮----
let original_lang = config.ui_language.clone();
let lang_flag = match config.ui_language.as_str() {
⋮----
.width(32.0)
.selected_text(lang_flag)
.show_ui(ui, |ui| {
ui.selectable_value(&mut config.ui_language, "en".to_string(), "🇺🇸 English");
ui.selectable_value(&mut config.ui_language, "vi".to_string(), "🇻🇳 Tiếng Việt");
ui.selectable_value(&mut config.ui_language, "ko".to_string(), "🇰🇷 한국어");
⋮----
.add(
⋮----
egui::RichText::new(format!("📜 {}", text.history_btn))
.color(egui::Color32::WHITE),
⋮----
.fill(history_bg)
.corner_radius(8.0),
⋮----
let used_width = ui.min_rect().width();
⋮----
ui.available_width() + used_width
⋮----
let remaining = (target_width - used_width - 120.0).max(0.0);
ui.add_space(remaining);
ui.spacing_mut().item_spacing.x = 4.0;
draw_icon_static(ui, Icon::Settings, None);
let is_global = matches!(current_view_mode, ViewMode::Global);
⋮----
.selectable_label(is_global, text.global_settings)
⋮----
ui.add_space(8.0);
⋮----
.iter()
.fold(config.presets.len() as u64, |acc, p| {
acc.wrapping_mul(31).wrapping_add(
p.id.bytes()
.fold(0u64, |h, b| h.wrapping_mul(31).wrapping_add(b as u64)),
⋮----
let grid_id = egui::Id::new("presets_grid").with(preset_hash);
⋮----
.num_columns(6)
.spacing([8.0, 4.0])
.min_col_width(67.0)
.show(ui, |ui| {
⋮----
ui.add(
⋮----
.color(egui::Color32::WHITE)
.strong(),
⋮----
.fill(img_bg)
.corner_radius(12.0),
⋮----
.then(|| preset_to_add_type = Some("image"));
ui.label("");
// Text
⋮----
.fill(txt_bg)
⋮----
.then(|| preset_to_add_type = Some("text"));
⋮----
// Audio
⋮----
.fill(aud_bg)
⋮----
.then(|| preset_to_add_type = Some("audio"));
⋮----
ui.end_row();
// ROW 2+: Preset Items
⋮----
.len()
.max(text_indices.len())
.max(audio_video_indices.len());
⋮----
// Column 1&2: Image
if let Some(&idx) = image_indices.get(i) {
render_preset_item_parts(
⋮----
// Column 3&4: Text
if let Some(&idx) = text_indices.get(i) {
⋮----
// Column 5&6: Audio
if let Some(&idx) = audio_video_indices.get(i) {
⋮----
// Update cached grid width for next frame
GRID_WIDTH.with(|w| w.set(grid_response.response.rect.width()));
⋮----
if let Some(preset) = config.presets.get_mut(idx) {
⋮----
let mut new_preset = config.presets[idx].clone();
new_preset.id = format!(
⋮----
let base_name = if config.presets[idx].id.starts_with("preset_") {
get_localized_preset_name(&config.presets[idx].id, &config.ui_language)
⋮----
new_preset.name.clone()
⋮----
let mut new_name = format!("{} Copy", base_name);
⋮----
while config.presets.iter().any(|p| p.name == new_name) {
new_name = format!("{} Copy {}", base_name, counter);
⋮----
new_preset.hotkeys.clear();
config.presets.push(new_preset);
*view_mode = ViewMode::Preset(config.presets.len() - 1);
⋮----
config.presets.swap(idx_a, idx_b);
⋮----
new_preset.preset_type = "text".to_string();
new_preset.name = format!("Text {}", config.presets.len() + 1);
new_preset.text_input_mode = "select".to_string();
if let Some(block) = new_preset.blocks.first_mut() {
block.block_type = "text".to_string();
block.model = "text_accurate_kimi".to_string();
block.prompt = "Translate this text.".to_string();
⋮----
new_preset.preset_type = "audio".to_string();
new_preset.name = format!("Audio {}", config.presets.len() + 1);
new_preset.audio_source = "mic".to_string();
⋮----
block.block_type = "audio".to_string();
block.model = "whisper-fast".to_string();
⋮----
new_preset.name = format!("Image {}", config.presets.len() + 1);
⋮----
config.presets.remove(idx);
⋮----
} else if config.presets.is_empty() {
⋮----
fn render_preset_item_parts(
⋮----
let display_name = if preset.id.starts_with("preset_") {
get_localized_preset_name(&preset.id, lang)
⋮----
preset.name.clone()
⋮----
let is_selected = matches!(current_view_mode, ViewMode::Preset(i) if *i == idx);
let has_hotkey = !preset.hotkeys.is_empty();
let icon_type = match preset.preset_type.as_str() {
⋮----
let rect = ui.available_rect_before_wrap();
⋮----
ui.painter().rect_filled(rect, 4.0, bg_color);
⋮----
ui.add_enabled_ui(false, |ui| {
draw_icon_static(ui, icon_type, Some(14.0));
let _ = ui.selectable_label(is_selected, &display_name);
⋮----
let response = ui.add(
⋮----
.sense(egui::Sense::click_and_drag()),
⋮----
if response.clicked() {
*preset_idx_to_select = Some(idx);
⋮----
if response.drag_started() {
ui.memory_mut(|mem| mem.data.insert_temp(dragging_id, idx));
⋮----
if response.dragged() {
ui.ctx().set_cursor_icon(egui::CursorIcon::Grabbing);
⋮----
if response.drag_stopped() {
ui.memory_mut(|mem| mem.data.remove::<usize>(dragging_id));
⋮----
if source_idx != idx && response.hovered() && ui.input(|i| i.pointer.any_released())
⋮----
if get_group(source_preset) == get_group(preset) {
*preset_swap_request = Some((source_idx, idx));
⋮----
ui.spacing_mut().item_spacing.x = 0.0;
⋮----
if icon_button_sized(ui, Icon::CopySmall, 22.0).clicked() {
*preset_idx_to_clone = Some(idx);
⋮----
if icon_button_sized(ui, star_icon, 22.0).clicked() {
*preset_idx_to_toggle_favorite = Some(idx);
⋮----
if presets.len() > 1 {
if icon_button_sized(ui, Icon::Delete, 22.0).clicked() {
*preset_idx_to_delete = Some(idx);
</file>

</files>
